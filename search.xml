<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CommonJs</title>
    <url>/2023/10/21/CommonJs/</url>
    <content><![CDATA[<p>require的伪代码如下：</p>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">require</span>(<span class="params">modulePath</span>) &#123;</span><br><span class="line">    <span class="comment">//1. 根据模块路径得到完整的绝对路径</span></span><br><span class="line">    <span class="keyword">var</span> moduleId = <span class="title function_">getModuleId</span>(modulePath);</span><br><span class="line">    <span class="comment">//2. 判断缓存</span></span><br><span class="line">    <span class="keyword">if</span>(cache[moduleId])&#123;</span><br><span class="line">        <span class="keyword">return</span> cache[moduleId]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 真正运行模块代码的辅助函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">__require</span>(<span class="params"><span class="built_in">exports</span>, <span class="built_in">require</span>, <span class="variable language_">module</span>, __filename, __dirname</span>)&#123;</span><br><span class="line">        <span class="comment">//目标模块代码在此函数环境里</span></span><br><span class="line">        <span class="comment">/* 解释了为什么可以用以上变量！ */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4. 准备运行的辅助函数</span></span><br><span class="line">    <span class="keyword">var</span> <span class="variable language_">module</span> = &#123;</span><br><span class="line">        <span class="attr">exports</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">exports</span> = <span class="variable language_">module</span>.<span class="property">exports</span></span><br><span class="line">    <span class="keyword">var</span> __filename = moduleId</span><br><span class="line">    <span class="keyword">var</span> __dirname = <span class="title function_">getDirname</span>(__filename)</span><br><span class="line">    <span class="comment">//用call改变模块里的this指向，初始this===exports===module.exports</span></span><br><span class="line">    __require.<span class="title function_">call</span>(<span class="built_in">exports</span>, <span class="built_in">exports</span>, <span class="built_in">require</span>, <span class="variable language_">module</span>, __filename, __dirname)</span><br><span class="line">    <span class="comment">//5. 缓存module.exports</span></span><br><span class="line">    cache[moduleId] = <span class="variable language_">module</span>.<span class="property">exports</span></span><br><span class="line">    <span class="comment">//6. 返回module.exports</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">module</span>.<span class="property">exports</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li>模块在函数环境里<ul>
<li>变量在函数作用域，不共享</li>
<li>var声明的变量挂载在函数</li>
<li>不用var或let或const声明的变量挂载在global上</li>
</ul>
</li>
<li>一开始模块里，this&#x3D;&#x3D;&#x3D;exports&#x3D;&#x3D;&#x3D;module.exports</li>
<li>模块最终导出的始终是module.exports</li>
<li>global在一个node.js环境中共享</li>
</ul>
<p>举个例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">b</span> = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">exports</span> = &#123;<span class="attr">c</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;<span class="attr">d</span>:<span class="number">4</span>&#125;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">e</span> = <span class="number">5</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">f</span> = <span class="number">6</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">this:           &#123;a:1, b:2, f:6&#125;</span></span><br><span class="line"><span class="comment">exports:        &#123;c:3, e:5&#125;</span></span><br><span class="line"><span class="comment">module.exports: &#123;d:4&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>commonjs</tag>
        <tag>require</tag>
        <tag>module.exports</tag>
        <tag>exports</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS详解</title>
    <url>/2024/04/21/HTTPS%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>HTTPS &#x3D; HTTP + SSL&#x2F;TLS</p>
<ol>
<li>http 明文传输，易被劫持，SEO降权</li>
<li>TLS 传输层安全协议，是SSL的升级方案</li>
</ol>
<span id="more"></span>

<h1 id="HTTPS如何加密"><a href="#HTTPS如何加密" class="headerlink" title="HTTPS如何加密"></a>HTTPS如何加密</h1><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><ol>
<li>浏览器给服务器一个随机数</li>
<li>服务器给浏览器一个随机数</li>
<li>浏览器和服务器都根据这两个随机数得出一个密钥，他们用这个密钥加密或解密信息。</li>
</ol>
<p>缺陷：容易被窃取</p>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><ol>
<li>每个主机都有一对密钥：公钥和私钥。公钥负责加密，私钥负责解密。</li>
<li>公钥在网络上公开，而私钥是保密的。</li>
</ol>
<p>缺陷：计算量大</p>
<h2 id="混合加密-——-HTTPS的加密方式"><a href="#混合加密-——-HTTPS的加密方式" class="headerlink" title="混合加密 —— HTTPS的加密方式"></a>混合加密 —— HTTPS的加密方式</h2><p>以非对称加密方式得到会话密钥，用会话密钥以对称<br><img src="/2024/04/21/HTTPS%E8%AF%A6%E8%A7%A3/TLS%E6%8F%A1%E6%89%8B.png" alt="TLS四次握手"></p>
<h3 id="校验证书"><a href="#校验证书" class="headerlink" title="校验证书"></a>校验证书</h3><p><img src="/2024/04/21/HTTPS%E8%AF%A6%E8%A7%A3/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.jpg" alt="数字签名"></p>
<ol>
<li><strong>证书</strong> &#x3D; 网站信息(包括公钥)+ 数字签名<ol>
<li><strong>数字签名</strong>是由网站信息计算出的hash值通过CA私钥机密后得到的</li>
</ol>
</li>
<li>公钥解密数字签名后和网站信息hash值比较，如果相同则代表校验通过</li>
</ol>
<blockquote>
<p>数字签名和非对称加密不同。是用公钥解密，私钥加密。</p>
</blockquote>
<h3 id="注册证书"><a href="#注册证书" class="headerlink" title="注册证书"></a>注册证书</h3><p><img src="/2024/04/21/HTTPS%E8%AF%A6%E8%A7%A3/%E6%B3%A8%E5%86%8C%E8%AF%81%E4%B9%A6.jpg" alt="注册证书"></p>
<blockquote>
<p>证书防止黑客伪造公钥</p>
</blockquote>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>IntersectionObserver</title>
    <url>/2023/11/24/IntersectionObserver/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">entries</span>&#125; Array 交叉状态数组 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">observer</span>&#125; Object 实例对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="keyword">function</span>(<span class="params">entries, observer</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(entries)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(observer)</span><br><span class="line">&#125;, options?)</span><br></pre></td></tr></table></figure>

<p><strong>options:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">root</span>: elementNode, <span class="comment">//监听元素的祖先元素Element对象，其边界盒将被视作视口</span></span><br><span class="line">    <span class="attr">rootMargin</span>: <span class="string">&quot;0px 0px 0px 0px&quot;</span>, <span class="comment">//计算交叉值时，边框相距rootMargin值也算交叉</span></span><br><span class="line">    <span class="attr">threshold</span>: <span class="number">0.0</span>      <span class="comment">// 0~1 0表示碰到就算交叉，1表示全部进入才算交叉</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="1-observe"><a href="#1-observe" class="headerlink" title="1. observe"></a>1. observe</h3><p><code>observer.observe(elementNode)</code> </p>
<h3 id="2-takeRecords"><a href="#2-takeRecords" class="headerlink" title="2. takeRecords"></a>2. takeRecords</h3><p><code>observer.takeRecords()</code> </p>
<h3 id="3-disconnect"><a href="#3-disconnect" class="headerlink" title="3. disconnect"></a>3. disconnect</h3><p><code>observer.disconnect()</code> 取消监听</p>
<h3 id="4-unobserve"><a href="#4-unobserve" class="headerlink" title="4. unobserve"></a>4. unobserve</h3><p><code>observer.unobserve(elementNode)</code> 取消对target的监听</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>IntersectionObserver</tag>
      </tags>
  </entry>
  <entry>
    <title>MutationObserver</title>
    <url>/2023/11/24/MutationObserver/</url>
    <content><![CDATA[<p>MutationObserver 用于观察<strong>DOM</strong>的任何变动</p>
<p>但是DOM的变动是同步的，而此方法是<strong>异步微任务</strong></p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">MutationRecord</span>&#125; Array 变动数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">obInstance</span>&#125; Object observer实例</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">MutationObserver</span>(<span class="function">(<span class="params">MutationRecord, obInstance</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MutationRecord</span>)  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obInstance)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="1-observe"><a href="#1-observe" class="headerlink" title="1. observe"></a>1. observe</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">node</span>&#125; DOMnode dom节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">options</span>&#125; Object 配置对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">observer.<span class="title function_">observe</span>(node, options?)</span><br></pre></td></tr></table></figure>

<p><strong>options：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">attributes</span>: <span class="literal">true</span>,   <span class="comment">// 监控 属性变化</span></span><br><span class="line">    <span class="attr">characterData</span>: <span class="literal">true</span>,    <span class="comment">// 监听 声明的 target 节点上所有字符的变化</span></span><br><span class="line">    <span class="attr">childList</span>: <span class="literal">true</span>,    <span class="comment">// 监听 target 节点中发生的节点的新增、删除与修改, 包括innerText</span></span><br><span class="line">    <span class="attr">subtree</span>: <span class="literal">true</span>,      <span class="comment">// 监听 作用于该节点的整个子树</span></span><br><span class="line">    <span class="comment">// attributeOldValue: true,    //是否需要记录变动前的属性值</span></span><br><span class="line">    <span class="comment">// characterDataOldValue: true  //是否需要记录变动前的属性值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<blockquote>
<p>childList 所指的子节点包括 文本内容也是一个节点</p>
</blockquote>
<h3 id="2-disconnect"><a href="#2-disconnect" class="headerlink" title="2. disconnect"></a>2. disconnect</h3><p><code>observer.disconnect()</code><br>停止监听</p>
<h3 id="3-takeRecords"><a href="#3-takeRecords" class="headerlink" title="3. takeRecords"></a>3. takeRecords</h3><p><code>observer.takeRecords</code> 用来清除变动记录，即不再处理未处理的变动。该方法返回变动记录的数组。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="1-图片懒加载"><a href="#1-图片懒加载" class="headerlink" title="1. 图片懒加载"></a>1. 图片懒加载</h3><h3 id="2-加载更多"><a href="#2-加载更多" class="headerlink" title="2. 加载更多"></a>2. 加载更多</h3>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MutationObserver</tag>
      </tags>
  </entry>
  <entry>
    <title>TS笔记</title>
    <url>/2023/10/11/TS%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>Ts笔记</p>
<span id="more"></span>

<h1 id="一、类型推断"><a href="#一、类型推断" class="headerlink" title="一、类型推断"></a>一、类型推断</h1><p>发生在没有指定类型时，会根据初始值自动推断变量类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;asdasdasds&#x27;</span></span><br><span class="line">str = <span class="number">0</span> <span class="comment">//报错： Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span></span><br></pre></td></tr></table></figure>



<h1 id="二、类型断言-注解-as"><a href="#二、类型断言-注解-as" class="headerlink" title="二、类型断言&#x2F;注解 as"></a>二、类型断言&#x2F;注解 as</h1><p>有些时候编译器不能推断出变量的类型，</p>
<p>但我们非常确定变量是某种类型时 : <code>as number/string/...</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> result = arr.<span class="title function_">find</span>(<span class="function"><span class="params">item</span>=&gt;</span> &#123;</span><br><span class="line">    item&gt; <span class="number">2</span></span><br><span class="line">&#125;) <span class="keyword">as</span> <span class="built_in">number</span>  </span><br></pre></td></tr></table></figure>

<h3 id="html元素"><a href="#html元素" class="headerlink" title="html元素"></a>html元素</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    HTMLAnchorElement,  &lt;a&gt;</span></span><br><span class="line"><span class="comment">    HTMLPargraphElement, &lt;p&gt;</span></span><br><span class="line"><span class="comment">    HTMLDivElement       &lt;div&gt;</span></span><br><span class="line"><span class="comment">    HTMLImageElement    &lt;img&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> a  = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#id&#x27;</span>) <span class="keyword">as</span> <span class="title class_">HTMLAnchorElement</span></span><br><span class="line">a &amp;&amp; a.<span class="property">href</span> <span class="comment">//这样才知道a有href属性</span></span><br></pre></td></tr></table></figure>



<h1 id="三、类型基础-联合类型-函数"><a href="#三、类型基础-联合类型-函数" class="headerlink" title="三、类型基础&amp;联合类型&amp;函数"></a>三、类型基础&amp;联合类型&amp;函数</h1><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基础类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v1</span>: <span class="built_in">string</span> = <span class="string">&#x27;asd&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v2</span>: <span class="built_in">number</span> = <span class="number">123</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v3</span>: <span class="built_in">boolean</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v4</span>: <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v5</span>: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">v6</span>: <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>(<span class="number">123</span>)</span><br><span class="line"><span class="keyword">let</span> <span class="attr">v7</span>: bigInt = <span class="title class_">BigInt</span>(<span class="string">&quot;223565679085&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//联合类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="built_in">string</span> | <span class="literal">null</span> = <span class="literal">null</span>        <span class="comment">//str可能是string类型也可能是null类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> = <span class="number">2</span>；   			<span class="comment">//限制值为 1或2或3</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: (<span class="built_in">number</span> | <span class="built_in">string</span>)[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="string">&#x27;asd&#x27;</span>]	<span class="comment">//数组里有可能同时两种类型，提示只有两者类型共有的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数</span></span><br><span class="line"><span class="comment">//void 专门用在函数返回值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyFn</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">string</span></span>):<span class="built_in">void</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a+b   <span class="comment">//报错 void没有返回值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyFn</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">string</span>, C?: <span class="built_in">boolean</span>, ...rest: <span class="built_in">number</span>[]</span>):<span class="built_in">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a+b   <span class="comment">//ok</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f = <span class="title class_">MyFn</span>(<span class="number">20</span>, <span class="string">&#x27;a&#x27;</span>, <span class="literal">true</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h1 id="复杂类型"><a href="#复杂类型" class="headerlink" title="复杂类型"></a>复杂类型</h1><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组 ---2种方式</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr1</span>: <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="comment">//元组</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">tup</span>: [<span class="built_in">number</span>, <span class="built_in">string</span>, <span class="built_in">number</span>?] = [<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>] 	<span class="comment">//可选可以[1, &#x27;a&#x27;]</span></span><br><span class="line">tup[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span> 			<span class="comment">//报错</span></span><br><span class="line"><span class="comment">//枚举</span></span><br><span class="line"><span class="comment">/*用来定义一些固定的值， </span></span><br><span class="line"><span class="comment">1. 可以通过下标直接访问</span></span><br><span class="line"><span class="comment">2. 默认从0下标开始</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">数字型枚举 </span></span><br><span class="line"><span class="comment"> 打印MyEnum</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &#x27;0&#x27;: &#x27;up&#x27;,</span></span><br><span class="line"><span class="comment">  &#x27;1&#x27;: &#x27;down&#x27;,</span></span><br><span class="line"><span class="comment">  &#x27;2&#x27;: &#x27;left&#x27;,</span></span><br><span class="line"><span class="comment">  &#x27;3&#x27;: &#x27;right&#x27;,</span></span><br><span class="line"><span class="comment">  up: 0,</span></span><br><span class="line"><span class="comment">  down: 1,</span></span><br><span class="line"><span class="comment">  left: 2,</span></span><br><span class="line"><span class="comment">  right: 3</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">    <span class="string">&#x27;up&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;down&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;left&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;right&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">MyEnum</span>.<span class="property">up</span> <span class="comment">//0</span></span><br><span class="line"><span class="title class_">MyEnum</span>[<span class="number">0</span>] <span class="comment">//up</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3. 属性可以不打引号</span></span><br><span class="line"><span class="comment">4. 可以指定下标，下面的属性会自动推断</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">     up = <span class="number">100</span>，</span><br><span class="line">     down</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5. 可以进行字符型枚举</span></span><br><span class="line"><span class="comment">    !失去了MyEnum[UP]==&#x27;up&#x27;的能力</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MyEnum</span> &#123;</span><br><span class="line">     up = <span class="string">&#x27;UP&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">MyEnum</span>.<span class="property">up</span> <span class="comment">// UP</span></span><br><span class="line"><span class="title class_">MyEnum</span>[<span class="string">&#x27;up&#x27;</span>] <span class="comment">// UP</span></span><br></pre></td></tr></table></figure>



<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><blockquote>
<ul>
<li>interface 只能定义对象, 也可以是实例对象</li>
<li>必须实现接口里面的所有内容，且不能多不能少</li>
<li>定义对象优先interface</li>
</ul>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*继承</span></span><br><span class="line"><span class="comment">1. 父接口所有属性方法不用再写一遍，</span></span><br><span class="line"><span class="comment">2. 不可以重写父类方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Itman</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">skill</span>: <span class="built_in">string</span>[],</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">p1</span>: <span class="title class_">Itman</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;blank&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">21</span>,</span><br><span class="line">    <span class="attr">skill</span>: [<span class="string">&#x27;js&#x27;</span>,<span class="string">&#x27;vue&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Student</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="attr">id</span>: T</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> stu : <span class="title class_">Student</span>&lt;<span class="built_in">number</span>&gt; = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">0x110</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;blank&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu);</span><br></pre></td></tr></table></figure>



<h1 id="别名-type"><a href="#别名-type" class="headerlink" title="别名 type"></a>别名 type</h1><blockquote>
<ul>
<li>type 可以定义所有类型</li>
</ul>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//值别名</span></span><br><span class="line"><span class="keyword">type</span> b = <span class="number">0</span> | <span class="number">1</span></span><br><span class="line"><span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyType</span> = <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line"><span class="keyword">type</span> myType2 = <span class="built_in">string</span> &amp; <span class="built_in">number</span></span><br><span class="line"><span class="comment">//--- 函数别名</span></span><br><span class="line"><span class="keyword">type</span> fnType = <span class="function">(<span class="params">a: <span class="built_in">number</span>, bb: <span class="built_in">number</span></span>)=&gt;</span> <span class="built_in">number</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">fn</span>: fnType = <span class="function">(<span class="params">a, b</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--- 对象别名</span></span><br><span class="line"><span class="keyword">type</span> student = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="built_in">number</span>,</span><br><span class="line">    girlfriend?: student,</span><br><span class="line">    <span class="attr">study</span>: <span class="function">(<span class="params">subject: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">back</span>: <span class="function">()=&gt;</span><span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">stu</span>: student = &#123;...&#125;</span><br><span class="line">stu.<span class="property">girlfriend</span>?.<span class="property">name</span>  <span class="comment">//对于可省略属性需要加 ?.</span></span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型 &lt;T&gt;"></a>泛型 &lt;T&gt;</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> myFn&lt;T&gt;(<span class="attr">a</span>: T, <span class="attr">b</span>: T): T[] &#123;</span><br><span class="line">    <span class="keyword">return</span> [a,b]</span><br><span class="line">&#125;</span><br><span class="line">myFn&lt;<span class="built_in">number</span>&gt;(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="title function_">myFn</span>(<span class="string">&#x27;a&#x27;</span>,<span class="number">2</span>) <span class="comment">//报错： 不写指明T，会根据第一个参数推断T</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="添加约束"><a href="#添加约束" class="headerlink" title="添加约束"></a>添加约束</h2><ol>
<li>泛型T可以继承接口，必须实现接口所有属性、方法，可以超出接口没有的</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ILength</span> &#123;</span><br><span class="line">    <span class="attr">length</span>: <span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">sayHi</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// T 继承了ILength， 所以T必须有ILength所有属性、方法</span></span><br><span class="line"><span class="keyword">function</span> getId&lt;T <span class="keyword">extends</span> <span class="title class_">ILength</span>&gt;(<span class="attr">val</span>: T) &#123;</span><br><span class="line">	val.<span class="property">length</span></span><br><span class="line">	val.<span class="title function_">sayHi</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//T 可以有超出 ILength的属性、方法</span></span><br><span class="line"><span class="keyword">let</span> so = &#123;</span><br><span class="line">    <span class="attr">length</span>: <span class="number">123</span>,</span><br><span class="line">    <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sayhi&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">father</span>: <span class="string">&#x27;lzy&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getId</span>(so)</span><br></pre></td></tr></table></figure>

<h2 id="多个变量"><a href="#多个变量" class="headerlink" title="多个变量"></a>多个变量</h2><p><code>K extends Keyof T</code> 即 Son类型限定了 传入的变量只能是Father类型的键</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> getProp&lt;T, K <span class="keyword">extends</span> keyof T&gt;(<span class="attr">obj</span>: T, <span class="attr">key</span>: K) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getProp</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;lzy&#x27;</span>&#125;, <span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getProp</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;lzy&#x27;</span>&#125;, <span class="string">&#x27;age&#x27;</span>)) <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>

<h1 id="class中使用ts"><a href="#class中使用ts" class="headerlink" title="class中使用ts"></a>class中使用ts</h1><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ILength</span> &#123;</span><br><span class="line">    <span class="attr">length</span>: <span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">sayHi</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现多个接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">ILength</span>,B&#123;</span><br><span class="line">    <span class="comment">//定义实例属性，必须要在下面得到初始化值</span></span><br><span class="line">    <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">length:<span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">length</span> = length</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title function_">A</span>(<span class="number">123</span>)</span><br></pre></td></tr></table></figure>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><ul>
<li>public: 公有的可以在任何地方可以被访问和修改(类中属性和方法默认为publish)</li>
<li>private: 私有的仅在当前类可访问和修改</li>
<li>protected: 仅当前类与子类(继承类)可以访问和修改</li>
<li>readonly: 只读修饰符, 仅可访问不可修改</li>
</ul>
<h1 id="any-类型"><a href="#any-类型" class="headerlink" title="any 类型"></a>any 类型</h1><blockquote>
<ol>
<li>失去了只能提示</li>
<li>隐式any：<ol>
<li>函数参数不定义类型</li>
<li>定义变量不定义类型也不给初始值</li>
</ol>
</li>
</ol>
</blockquote>
<h1 id="运行ts文件"><a href="#运行ts文件" class="headerlink" title="运行ts文件"></a>运行ts文件</h1><ol>
<li><pre><code class="bash">tsc demo.ts
# 生成一个demo.js 文件
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">2. 在node环境执行</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">ts-node demo.ts</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>TS</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack与Vite的区别与联系</title>
    <url>/2024/04/21/Webpack%E4%B8%8EVite%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/</url>
    <content><![CDATA[<h1 id="0-当前工程化痛点"><a href="#0-当前工程化痛点" class="headerlink" title="0. 当前工程化痛点"></a>0. 当前工程化痛点</h1><p>主流webpack需要把<i>整个项目编译好后</i>再交给dev server，因此大型项目devserver启动时间很长，HMR也需要很长时间。<br>因此，Vite应运而生</p>
<h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><p>当我们使用webpack启动项目时，webpack会根据我们配置文件中的入口文件，</p>
<ol>
<li>分析出项目项目所有依赖关系，</li>
<li>然后打包成一个文件（bundle.js），</li>
<li>交给浏览器去加载渲染。</li>
</ol>
<p>在Webpack中，构建过程大概分为这么几个阶段初始化Init、构建Make、生成Seal</p>
<ul>
<li><strong>初始化阶段：</strong> 修整配置参数，创建 Compiler、Compilation 等基础对象，并初始化插件及若干内置工厂、工具类，并最终根据 entry 配置，找到所有入口模块</li>
<li><strong>构建阶段：</strong> 从entry找到入口，调用loader编译模块，遍历 AST 找出模块依赖的模块，之后递归遍历所有依赖块，构建出 模块依赖关系图 (dependency graph)</li>
<li><strong>输出阶段：</strong> 根据output的配置，将模块拆解成不同的chunk对象，经过一系列优化，再将代码翻译成产物</li>
</ul>
<p>描述得比较简单， 实际完成这些过程是比较复杂的</p>
<h2 id="HMR"><a href="#HMR" class="headerlink" title="HMR"></a>HMR</h2><p>每次修改一个模块，webpack要遍历<strong>整个依赖图</strong>来找出所有依赖于该模块的其他模块。再进行<strong>局部</strong>的重新编译。<br>三个阶段：</p>
<ol>
<li>找出过期的模块</li>
<li>从缓存中删除过期的模块</li>
<li>把新模块添加到modules中</li>
</ol>
<blockquote>
<p>webpack4以前是通过jsonp来拉取更新模块的，webpack4以及以后通过ws通信+ajax请求</p>
</blockquote>
<h2 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h2><p>原理是通过在内存中创建<strong>虚拟文件系统</strong>来提供开发服务器功能。它监听文件变化并通过 WebSocket 与浏览器通信，以实现HMR，提供高效的开发环境。</p>
<ol>
<li>启动服务器；在本地启动http服务器</li>
<li>读入内存；把项目文件读入内存</li>
<li>编译构建；所有编译都在内存中完成，无需写入磁盘</li>
<li>请求转发；对于静态资源直接从内存中提供给客户端</li>
<li>HMR；通过http升级websocket。</li>
</ol>
<h2 id="优化打包速度"><a href="#优化打包速度" class="headerlink" title="优化打包速度"></a>优化打包速度</h2><ol>
<li>禁止大图片转base64</li>
<li>利用webpack-bound-analyze分析</li>
<li>CDN引入公共库，减少webpack打包量</li>
<li>开启缓存，以便在后续构建中重复使用之前的结果 <code>cache: true</code></li>
<li>开启多线程，利用<code>thread-loader</code></li>
</ol>
<h1 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h1><p><strong>底层</strong><br>基于esbuild和rollup，利用浏览器对ESM的支持</p>
<ul>
<li>esbuild: 预构建。把不同模块规范统一编译为ESM</li>
<li>rollup：在build时打包成生产环境代码</li>
</ul>
<p><strong>ESM</strong><br>ESM &#x3D;&#x3D;&#x3D; ES module, 大部分浏览器都支持<code>&lt;script type=&#39;module&#39;&gt;</code><br>在<code>&lt;script type=&quot;module&quot;&gt;</code>中，浏览器遇到内部的import引用时，会自动发起<strong>http请求</strong>，去加载对应的模块。</p>
<blockquote>
<p>ESM 支持编译时就能确定模块的依赖关系</p>
</blockquote>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ol>
<li>预构建。<ol>
<li>针对node_modules中的<i>第三方依赖</i>，由esbuild把所有模块编译为ESM。</li>
<li>整合模块，对于具有许多内部模块的，整合成一个模块。避免发送太多http请求。</li>
<li>缓存。把预构建好的ESM存到<code>node_modules/.vite</code>下。</li>
</ol>
</li>
<li>冷启动devServer。</li>
<li>按需编译。页面需要某些模块会发送http请求，此时vite再进行编译，编译后发给浏览器。<br> 此时编译是对<i>src源码的编译</i>，包括对ts、less、esm、图片、字体的处理<ol>
<li>利用http2.0 支持并发请求。</li>
<li>利用http缓存，<ol>
<li>node_modules 使用强制缓存</li>
<li>src下源码 使用协商缓存</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><b>注意：</b><br>按需编译，编译了：<br>typescript、vue、jsx、css预处理语言、静态资源等。实际上都转换为了浏览器可以解析的html&#x2F;js&#x2F;css，但是由于SouceMap方便开发者，我们在F12网络看到的资源依然是index.ts这样的后缀。</p>
<h3 id="HMR-1"><a href="#HMR-1" class="headerlink" title="HMR"></a>HMR</h3><p>当修改一个文件时vite精确定位到该模块，使其失活。vite重新编译该模块后再发送给浏览器。浏览器利用动态导入<code>import()</code>来替换。</p>
<p>原理：利用websocket连接浏览器，建立连接后监听文件变化。服务器向浏览器注入代码用于处理ws消息（重新请求模块、刷新页面）</p>
<blockquote>
<p>重新请求模块依然走ajax请求，而不是ws；目的是为了保证ws只用于通信上。</p>
</blockquote>
<h2 id="生产环境"><a href="#生产环境" class="headerlink" title="生产环境"></a>生产环境</h2><p>基于rollup打包，rollup轻量、打包更快。</p>
<h1 id="为什么vite比webpack快"><a href="#为什么vite比webpack快" class="headerlink" title="为什么vite比webpack快"></a>为什么vite比webpack快</h1><p>从几方面回答：</p>
<ol>
<li>vite基于esbuild、rollup<ol>
<li>esbuild基于Go，善于利用多核cpu</li>
<li>rollup轻量，打包更快</li>
</ol>
</li>
<li>vite的预构建、冷启动、按需编译</li>
<li>HMR的区别</li>
<li>vite内置功能多，使用成本低</li>
</ol>
]]></content>
      <categories>
        <category>工程化</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>vite</tag>
      </tags>
  </entry>
  <entry>
    <title>Websocket详解</title>
    <url>/2024/06/22/Websocket%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>更新中—</p>
<span id="more"></span>

<p>websocket是基于<code>tcp</code>的全双工通信协议。允许服务器主动向客户端推送数据。<br>只需要一次握手就可以建立持久的连接。<br><img src="/2024/06/22/Websocket%E8%AF%A6%E8%A7%A3/life_cycle.png" alt="websocket生命周期"></p>
<h2 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h2><p>文本或二进制</p>
<p>一个消息由消息头和消息体</p>
<p><strong>消息头</strong><br>消息头包括：</p>
<ol>
<li>FIN：1 or 0    表示是 or 不是 一条完整的消息</li>
<li>Opcode：表示消息类型</li>
<li>Payload length: 表示消息体长度</li>
<li><ol start="3">
<li>Mask： 表示是否加密</li>
</ol>
</li>
<li>Masking key：仅在需要加密时出现，用于对消息进行解密</li>
</ol>
<p>流程：</p>
<ol>
<li>服务器建立ws服务器</li>
<li>监听<ol>
<li>连接开放<code>ws.onopen</code></li>
<li>连接关闭<code>ws.onerror</code></li>
<li>接收消息<code>ws.onmessage</code></li>
</ol>
</li>
<li></li>
</ol>
<h2 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h2><p>Ping消息由客户端发送给服务端；Pong消息由服务端发送给客户端，作为响应</p>
<p>如果客户端在一段时间内没有接收到Pong消息，就会关闭连接。</p>
]]></content>
      <tags>
        <tag>websocket</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>content-type一些疑惑</title>
    <url>/2023/12/01/content-type%E4%B8%80%E4%BA%9B%E7%96%91%E6%83%91/</url>
    <content><![CDATA[<p>相信很初学者在使用<code>body-parser</code>时感到疑惑</p>
<p>我们先说说他的作用，其实很简单，就是把HTTP请求里的请求体传参解析出来</p>
<p>我们在使用接口测试工具时(例如：<code>postman</code> <code>Apipost</code>)</p>
<p><img src="/2023/12/01/content-type%E4%B8%80%E4%BA%9B%E7%96%91%E6%83%91/jietu.png" alt="ApiPost"></p>
<p>可以看到请求体传参有 <code>content-type</code> 分别是 <code>multipart/form-data</code> 和 <code>application/x-www-form-urlencoded</code></p>
<h1 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart&#x2F;form-data"></a>multipart&#x2F;form-data</h1><ul>
<li>一般传送<em>文件</em>或者<em>二进制数据</em>，也可以传文本</li>
<li>数据以多个part形式传输</li>
<li>会指定一个boundary来分割不同part</li>
</ul>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>multipart/form-data; boundary=</span><br><span class="line">--------------------------460532464492192001772468</span><br><span class="line"><span class="attribute">Content-Disposition</span><span class="punctuation">: </span>form-data; name=&quot;foo&quot;</span><br><span class="line"></span><br><span class="line">this is part 1.</span><br><span class="line">--------------------------460532464492192001772468</span><br><span class="line"><span class="attribute">Content-Disposition</span><span class="punctuation">: </span>form-data; name=&quot;baz&quot;</span><br><span class="line"></span><br><span class="line">this is part 2</span><br><span class="line">--------------------------460532464492192001772468</span><br></pre></td></tr></table></figure>

<h1 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application&#x2F;x-www-form-urlencoded"></a>application&#x2F;x-www-form-urlencoded</h1><ul>
<li>一般传输<em>文本</em></li>
<li>格式是<code>key=value&amp;key2=value2</code>，其实和<em>query参数一样</em>，只是后者在请求头，前者在请求体里</li>
<li>字符会经过<em>URL编码</em> <ol>
<li>转成ASCII码</li>
<li>用16进制表示</li>
<li>每个字节前加%</li>
<li>如果字符不能转成ASCII码，则转成UTF-8编码，<a href="/2023/10/21/%E7%BC%96%E7%A0%81">关于编码详见此处</a><blockquote>
<p>Eg:  “中”在UTF-8编码中表示为0xE4B8AD –&gt; %E4%B8%AD</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h1 id="raw"><a href="#raw" class="headerlink" title="raw"></a>raw</h1><ul>
<li>一般传输图片、视频、音频</li>
<li>表示原始未经处理的二进制数据，没有特定编码方式</li>
</ul>
<h2 id="body-parser"><a href="#body-parser" class="headerlink" title="body-parser"></a>body-parser</h2><p>我们再说回<code>body-parser</code></p>
<p>它支持解析<code>urlencoded</code>而不支持<code>form-data</code> </p>
<p>如果想要解析<code>form-data</code>可以使用<code>busboy</code></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>content-type</tag>
        <tag>body-parser</tag>
      </tags>
  </entry>
  <entry>
    <title>css计算过程</title>
    <url>/2023/12/12/css%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<ol>
<li>确定声明值</li>
<li>层叠<ol>
<li>!important 的作者样式</li>
<li>!important 的默认样式</li>
<li>作者样式</li>
<li>默认样式</li>
</ol>
</li>
<li>继承</li>
<li>默认</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>delete使用</title>
    <url>/2023/10/23/delete%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<ol>
<li>如果你试图删除的属性不存在，那么 delete 将不会起任何作用，但仍会返回 true。</li>
<li>delete 只影响自身属性</li>
<li>configurable：false的属性不可以delete</li>
<li>delete 函数参数永远不会生效</li>
<li>不能删除let、const、var声明的变量，但可以声明对象中的属性</li>
<li><code>delete a[1]</code> 后 <code>1 in a === false</code></li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>delete</tag>
      </tags>
  </entry>
  <entry>
    <title>egg.js笔记</title>
    <url>/2023/10/11/egg-js%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>egg.js</p>
<span id="more"></span>

<h1 id="app-文件夹"><a href="#app-文件夹" class="headerlink" title="&#x2F;app 文件夹"></a>&#x2F;app 文件夹</h1><h2 id="controller"><a href="#controller" class="headerlink" title="&#x2F;controller"></a>&#x2F;controller</h2><blockquote>
<ol>
<li>响应数据或渲染模板</li>
<li>与用户数据交互</li>
<li>与路由建立对应关系</li>
</ol>
</blockquote>
<h3 id="控制器里的this"><a href="#控制器里的this" class="headerlink" title="控制器里的this"></a>控制器里的this</h3><p>控制器里的  <code>this.app === this.ctx.app</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> </span><br><span class="line">	ctx<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		request<span class="punctuation">,</span></span><br><span class="line">		response<span class="punctuation">,</span></span><br><span class="line">		app<span class="punctuation">,</span></span><br><span class="line">        originalUrl<span class="punctuation">,</span></span><br><span class="line">        req<span class="punctuation">,</span></span><br><span class="line">        res<span class="punctuation">,</span></span><br><span class="line">        socket</span><br><span class="line">	<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">	app<span class="punctuation">,</span></span><br><span class="line">	config<span class="punctuation">,</span></span><br><span class="line">    service</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="home-js"><a href="#home-js" class="headerlink" title="home.js"></a>home.js</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="comment">//1. 导入 Controller 是egg提供的控制器类</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Controller</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;egg&#x27;</span>);</span><br><span class="line"><span class="comment">//2. 继承 自己定义一个控制器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HomeController</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Controller</span> &#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">index</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; ctx &#125; = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="comment">// ctx.body = &#x27;hi, egg&#x27;;</span></span><br><span class="line">    ctx.<span class="property">body</span> = <span class="string">&#x27;&lt;h1&gt;hello world!!!&lt;/h1&gt;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3. 暴露</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">HomeController</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><p>里面的async index方法即为 index页面</p>
</li>
<li><p>请求参数解析&#x3D;&#x3D;&#x3D; koa2</p>
<p>但是解析post请求参数不需要koa-body</p>
</li>
</ol>
</blockquote>
<h4 id="post请求的安全验证"><a href="#post请求的安全验证" class="headerlink" title="post请求的安全验证"></a>post请求的安全验证</h4><blockquote>
<p>为了防止 CSRF跨站请求伪造</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">config.<span class="property">security</span> = &#123;</span><br><span class="line">    <span class="attr">csrf</span>: &#123;</span><br><span class="line">        <span class="attr">enable</span>: <span class="literal">false</span>, <span class="comment">//关闭此安全检查</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果不关闭则<code>403: invalid csrf token</code></li>
</ul>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">ctx</span>.<span class="title function_">redirect</span>(<span class="string">&#x27;url&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="service"><a href="#service" class="headerlink" title="&#x2F;service"></a>&#x2F;service</h2><blockquote>
<p>对复杂业务场景进行封装：</p>
<pre><code> 1. 保持controller逻辑简介
 2. service中的业务逻辑可以被复用
</code></pre>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /app/service/myService.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Service</span> = <span class="built_in">require</span>(<span class="string">&#x27;egg&#x27;</span>).<span class="property">Service</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyService</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Service</span> &#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">fun</span>(<span class="params"></span>) &#123; </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">MyService</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">ctx</span>.<span class="property">service</span>.<span class="property">myService</span>.<span class="title function_">fun</span>()</span><br></pre></td></tr></table></figure>




<h2 id="public"><a href="#public" class="headerlink" title="&#x2F;public"></a>&#x2F;public</h2><blockquote>
<p>静态文件目录</p>
</blockquote>
<ul>
<li>目录下存在 index.html，可以通过<code>localhost:7001/public/index.html</code> 访问</li>
</ul>
<h2 id="router-js"><a href="#router-js" class="headerlink" title="router.js"></a>router.js</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app 是整个egg的实例对象, 从中结构出router和controller</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; router, controller &#125; = app;</span><br><span class="line">  router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, controller.<span class="property">home</span>.<span class="property">index</span>);</span><br><span class="line">  router.<span class="title function_">get</span>(<span class="string">&#x27;/news&#x27;</span>, controller.<span class="property">news</span>.<span class="property">list</span>);</span><br><span class="line">  router.<span class="title function_">get</span>(<span class="string">&#x27;/fruits&#x27;</span>, controller.<span class="property">fruits</span>.<span class="property">index</span>);</span><br><span class="line">  router.<span class="title function_">get</span>(<span class="string">&#x27;/fruits/:id&#x27;</span>, controller.<span class="property">fruits</span>.<span class="property">getId</span>)</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//restful api</span></span><br><span class="line">  router.<span class="title function_">resources</span>(<span class="string">&#x27;fruits&#x27;</span>,<span class="string">&#x27;/fruits&#x27;</span>,controller.<span class="property">fruits</span>) <span class="comment">//具体到fruits控制器就可以了</span></span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="restful-Api"><a href="#restful-Api" class="headerlink" title="restful Api"></a>restful Api</h3><table>
<thead>
<tr>
<th>Method</th>
<th>Path</th>
<th>Route Name</th>
<th>Controller.Action</th>
</tr>
</thead>
<tbody><tr>
<td>Get</td>
<td>&#x2F;posts</td>
<td>posts</td>
<td>app.controllers.posts.index</td>
</tr>
<tr>
<td>Get</td>
<td>&#x2F;posts&#x2F;new</td>
<td>new_post</td>
<td>app.controllers.posts.new</td>
</tr>
<tr>
<td>Get</td>
<td>&#x2F;post&#x2F;:id</td>
<td>post</td>
<td>app.controllers.posts.show</td>
</tr>
<tr>
<td>Get</td>
<td>&#x2F;post&#x2F;:id&#x2F;edit</td>
<td>edit_post</td>
<td>app.controllers.post.edit</td>
</tr>
<tr>
<td>Post</td>
<td>&#x2F;posts</td>
<td>posts</td>
<td>app.controllers.posts.create</td>
</tr>
<tr>
<td>Put</td>
<td>&#x2F;posts&#x2F;:id</td>
<td>posts</td>
<td>app.controllers.posts.update</td>
</tr>
<tr>
<td>Delete</td>
<td>&#x2F;posts&#x2F;:id</td>
<td>posts</td>
<td>app.controllers.posts.destroy</td>
</tr>
</tbody></table>
<blockquote>
<p>需要在controllers&#x2F;posts.js 下存在 <code>index/new/show/edit/create/update/destroy</code>等方法</p>
</blockquote>
<h1 id="config"><a href="#config" class="headerlink" title="&#x2F;config"></a>&#x2F;config</h1><h2 id="config-default-js"><a href="#config-default-js" class="headerlink" title="config.default.js"></a>config.default.js</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function"><span class="params">appInfo</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * built-in config</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@type</span> &#123;<span class="type">Egg.EggAppConfig</span>&#125;</span></span><br><span class="line"><span class="comment">   **/</span></span><br><span class="line">  <span class="keyword">const</span> config = <span class="built_in">exports</span> = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// use for cookie sign key, should change to your own and keep security</span></span><br><span class="line">  config.<span class="property">keys</span> = appInfo.<span class="property">name</span> + <span class="string">&#x27;_252238Lzy...&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// add your middleware config here  （所有路由都生效！！！， 想要单独在某路由上生效，请在控制器里写）</span></span><br><span class="line">  config.<span class="property">middleware</span> = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// add your user config here</span></span><br><span class="line">  <span class="keyword">const</span> userConfig = &#123;</span><br><span class="line">    <span class="comment">// myAppName: &#x27;egg&#x27;,</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  config.<span class="property">security</span> = &#123;</span><br><span class="line">    <span class="attr">csrf</span>: &#123;</span><br><span class="line">      <span class="attr">enable</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  config.<span class="property">view</span> = &#123;</span><br><span class="line">    <span class="attr">defaultViewEngine</span>: <span class="string">&#x27;nunjucks&#x27;</span>,</span><br><span class="line">    <span class="attr">mapping</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;.tpl&#x27;</span>: <span class="string">&#x27;nunjucks&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;.html&#x27;</span>: <span class="string">&#x27;nunjucks&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//数据库</span></span><br><span class="line">  config.<span class="property">mysql</span> = &#123;</span><br><span class="line">    <span class="comment">// 单数据库信息配置</span></span><br><span class="line">    <span class="attr">client</span>: &#123;</span><br><span class="line">      <span class="attr">host</span>: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">      <span class="attr">port</span>: <span class="string">&#x27;3306&#x27;</span>,</span><br><span class="line">      <span class="attr">user</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">      <span class="attr">password</span>: <span class="string">&#x27;252238Lzy&#x27;</span>,</span><br><span class="line">      <span class="attr">database</span>: <span class="string">&#x27;mytest&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多源</span></span><br><span class="line">    <span class="comment">// clients: &#123;</span></span><br><span class="line">    <span class="comment">//   db1: &#123;</span></span><br><span class="line">    <span class="comment">//     host: &#x27;localhost&#x27;,</span></span><br><span class="line">    <span class="comment">//     port: &#x27;3306&#x27;,</span></span><br><span class="line">    <span class="comment">//     user: &#x27;root&#x27;,</span></span><br><span class="line">    <span class="comment">//     password: &#x27;252238Lzy&#x27;,</span></span><br><span class="line">    <span class="comment">//     database: &#x27;mytest&#x27;,</span></span><br><span class="line">    <span class="comment">//   &#125;,</span></span><br><span class="line">    <span class="comment">//   db2: &#123;</span></span><br><span class="line">    <span class="comment">//     host: &#x27;localhost&#x27;,</span></span><br><span class="line">    <span class="comment">//     port: &#x27;3307&#x27;,</span></span><br><span class="line">    <span class="comment">//     user: &#x27;root&#x27;,</span></span><br><span class="line">    <span class="comment">//     password: &#x27;123456&#x27;,</span></span><br><span class="line">    <span class="comment">//     database: &#x27;api_gateway&#x27;,</span></span><br><span class="line">    <span class="comment">//   &#125;</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    <span class="comment">// //所有数据库配置默认</span></span><br><span class="line">    <span class="comment">// default: &#123;&#125;,</span></span><br><span class="line">    <span class="comment">// 是否加载到 app 上，默认开启</span></span><br><span class="line">    <span class="attr">app</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 是否加载到 agent 上，默认关闭</span></span><br><span class="line">    <span class="attr">agent</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  config.<span class="property">cors</span> = &#123;</span><br><span class="line">    <span class="comment">// 任何地址都可以访问</span></span><br><span class="line">    <span class="attr">origin</span>: <span class="string">&quot;*&quot;</span>,</span><br><span class="line">    <span class="comment">// 指定地址才可以访问</span></span><br><span class="line">    <span class="comment">// origin: &#x27;http://localhost:8080&#x27;,</span></span><br><span class="line">    <span class="attr">allowMethods</span>: <span class="string">&#x27;GET,PUT,POST,DELETE&#x27;</span>,</span><br><span class="line">    <span class="attr">allowHeaders</span>: <span class="string">&#x27;Authorization,Content-Type&#x27;</span>,</span><br><span class="line">    <span class="comment">// cookie跨域配置</span></span><br><span class="line">    <span class="attr">credentials</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  config.<span class="property">jwt</span> = &#123;</span><br><span class="line">    <span class="attr">secret</span>: <span class="string">&quot;blank_lzy&quot;</span>,</span><br><span class="line">    <span class="attr">expiredIn</span>: <span class="string">&#x27;1d&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...config,</span><br><span class="line">    ...userConfig,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="plugin-js"><a href="#plugin-js" class="headerlink" title="plugin.js"></a>plugin.js</h2><h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><blockquote>
<p>洋葱模型</p>
</blockquote>
<ol>
<li><pre><code class="js">// 在app/middleware/checkToken.js 1.编写
function checkToken(options) &#123;
    return async function (ctx, next) &#123; 
        
        const decode = ctx.app.jwt.verify(token, ctx.app.config.jwt.secret)
        await next()
        ...
    &#125;
&#125;
//暴露出去
module.exports = checkToken
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```js</span><br><span class="line">   // 在config.default.js 2.注册</span><br><span class="line">   // 元素顺序是中间件的执行顺序</span><br><span class="line">   config.middleware = [&#x27;checkToken&#x27;]</span><br><span class="line">   config.checkToken: &#123;</span><br><span class="line">       ... //配置</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="js">// 在 router.js 3.使用中间件
router.resources(&#39;students&#39;,&#39;/students&#39;,app.middleware.checkToken(), controller.students)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 1.  options :  是 app.config.checkToken</span><br><span class="line">&gt; 2.  使用中间件时可以传递参数`app.middleware.checkToken(&#123;expiredIn:&#x27;7d&#x27;&#125;) ` 被`options`接收</span><br><span class="line">&gt; 3.  中间件里怎么用插件： `ctx.app.jwt`</span><br><span class="line"></span><br><span class="line">### 中间件里的ctx </span><br><span class="line"></span><br><span class="line">可以看到和控制器里this里的ctx一样</span><br><span class="line"></span><br><span class="line">```json</span><br><span class="line">&#123;</span><br><span class="line">    request,</span><br><span class="line">    response,</span><br><span class="line">    app,</span><br><span class="line">    originalUrl,</span><br><span class="line">    req,</span><br><span class="line">    res,</span><br><span class="line">    socket</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h1 id="项目打包发布"><a href="#项目打包发布" class="headerlink" title="项目打包发布"></a>项目打包发布</h1><ol>
<li><pre><code class="bash">npm run build
#	把dist内的文件都复制到服务器public目录下

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 我们要访问的首页是`localhost:7001/public/index.html` ，但是相关打包文件的请求地址却是`http://localhost:7001/js/chunk-vendors.3c79a5b3.js` 会报404，因为文件在`... :7001/public/js/...`</span><br><span class="line"></span><br><span class="line">   ```js</span><br><span class="line">   // config.default.js</span><br><span class="line">   const path = require(&#x27;path&#x27;)</span><br><span class="line">     //设置静态文件路径</span><br><span class="line">   config.static = &#123;</span><br><span class="line">       prefix: &#x27;/&#x27;,</span><br><span class="line">       dir: path.join(appInfo.baseDir, &#x27;app/public&#x27;)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>访问地址变成了<code>localhost:7001/index.html</code></p>
</li>
</ol>
<blockquote>
<p>服务器运行方式除了 <code>npm run dev</code> 还有 <code>npm start</code></p>
</blockquote>
<h1 id="nunjucks插件模板引擎"><a href="#nunjucks插件模板引擎" class="headerlink" title="nunjucks插件模板引擎"></a>nunjucks插件模板引擎</h1><ol>
<li><pre><code class="bash">npm i --save egg-view-nunjucks
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 在plugin.js 和 config.default.js 中配置</span><br><span class="line"></span><br><span class="line">   ```js</span><br><span class="line">   //plugin.js</span><br><span class="line">   module.exports = &#123;</span><br><span class="line">     nunjucks: &#123;</span><br><span class="line">       enable: true,</span><br><span class="line">       package: &#x27;egg-view-nunjucks&#x27;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   //config.default.js</span><br><span class="line">   module.exports = appInfo =&gt; &#123;</span><br><span class="line">       ...</span><br><span class="line">      config.view = &#123;</span><br><span class="line">       defaultViewEngine: &#x27;nunjucks&#x27;,</span><br><span class="line">       // mapping: &#123;</span><br><span class="line">       //   &#x27;.tpl&#x27;: &#x27;nunjucks&#x27;</span><br><span class="line">       // &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>在 &#x2F;app&#x2F;view 下创建index.html</p>
</li>
<li><p>在controller 下某个控制器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> ctx.<span class="title function_">render</span>(<span class="string">&#x27;index&#x27;</span>，&#123;<span class="attr">params</span>: <span class="string">&#x27;参数&#x27;</span>&#125;) <span class="comment">//启用模板, 传参给模板</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="cors跨域插件"><a href="#cors跨域插件" class="headerlink" title="cors跨域插件"></a>cors跨域插件</h1><ol>
<li><pre><code class="bash">npm i --save egg-cors
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```js</span><br><span class="line">   //plugin.js </span><br><span class="line">   cors: &#123;</span><br><span class="line">       enable: true,</span><br><span class="line">       package: &#x27;egg-cors&#x27;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   //config.default.js</span><br><span class="line">   config.cors = &#123;</span><br><span class="line">     // 任何地址都可以访问</span><br><span class="line">     origin:&quot;*&quot;,</span><br><span class="line">     // 指定地址才可以访问</span><br><span class="line">     // origin: &#x27;http://localhost:8080&#x27;,</span><br><span class="line">     allowMethods: &#x27;GET,PUT,POST,DELETE&#x27;,</span><br><span class="line">     allowHeaders: &#x27;Authorization,Content-Type&#x27;,</span><br><span class="line">     // cookie跨域配置</span><br><span class="line">     credentials: true</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h1 id="Json-Web-Token插件"><a href="#Json-Web-Token插件" class="headerlink" title="Json Web Token插件"></a>Json Web Token插件</h1><ol>
<li><pre><code class="bash">npm i --save egg-jwt
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```js</span><br><span class="line">   //plugin.js</span><br><span class="line">   jwt: &#123;</span><br><span class="line">       enable: true,</span><br><span class="line">       package: &#x27;egg-jwt&#x27;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   //config.default.js</span><br><span class="line">   config.jwt = &#123;</span><br><span class="line">       secret: &#x27;private_key&#x27;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="js">//使用
//1. 签名
let token = this.app.jwt.sign(userInfo, this.app.config.jwt.secret, &#123; expiresIn: &#39;1d&#39;&#125;)
//2. 解密
let decode = this.app.jwt.verify(token, this.app.config.jwt.secret)
</code></pre>
</li>
</ol>
<blockquote>
<p>当token错误或过期，verify会直接报错，推荐用try-catch包裹起来</p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>egg.js</tag>
      </tags>
  </entry>
  <entry>
    <title>git的使用</title>
    <url>/2023/10/17/git%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="git-基本使用"><a href="#git-基本使用" class="headerlink" title="git 基本使用"></a>git 基本使用</h1><p>git 分为 3 个区</p>
<ul>
<li>工作区 —— 存放文件</li>
<li>暂存区 —— 工作区变更，提交到暂存区</li>
<li>版本库 —— 暂存区的内容，提交到版本库</li>
</ul>
<span id="more"></span>

<p>status 颜色</p>
<ul>
<li>红: 工作区变更了,但是<strong>没有提交到暂存区</strong>,此时 <code>git checkout .</code> 会撤回变更无法找回</li>
<li>绿: 已经提交到暂存区</li>
<li>无: 都被 git 管理起来了</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status <span class="comment"># 查看文件状态（红）</span></span><br><span class="line"></span><br><span class="line">git add . <span class="comment"># 工作区-&gt; 暂存区（变绿）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git rest HEAD <span class="comment"># 把  工作区 &lt;- 暂存区（由绿变红）</span></span><br><span class="line">git checkout . <span class="comment">#工作区 变更撤回</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&#x27;注释&#x27;</span> <span class="comment"># 暂存区 -&gt; 版本库</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span>  <span class="comment"># 查看版本库 详细</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>空文件夹不会被 git 管理</p>
</blockquote>
<h1 id="git-忽略文件"><a href="#git-忽略文件" class="headerlink" title="git 忽略文件"></a>git 忽略文件</h1><ol>
<li>根目录下新建<code>.gitignore</code>文件</li>
<li>在里面写需要忽略的文件<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mode_models  # 直接忽略该目录</span><br><span class="line">.idea  # 忽略 该文件</span><br><span class="line">*.log  # 忽略 以.log结尾的文件</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="git-多分支"><a href="#git-多分支" class="headerlink" title="git 多分支"></a>git 多分支</h1><p>小公司常用方案: master 分支、dev 分支、bug 分支 、个人分支</p>
<blockquote>
<p>以前默认 master 是主分支, 现在默认 main 分支</p>
</blockquote>
<p>常用分支操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch <span class="comment">#查看已建立的分支</span></span><br><span class="line"></span><br><span class="line">git branch 分支名   <span class="comment"># 建立分支</span></span><br><span class="line">git branch -f 分支1 分支2  <span class="comment"># 强制分支1指向分支2， 可以分支回退</span></span><br><span class="line"></span><br><span class="line">git checkout 分支名 <span class="comment"># 切换分支 或git switch</span></span><br><span class="line">git checkout -b 分支名 [节点]<span class="comment"># 创建分支 并指向节点，把HEAD指向该分支</span></span><br><span class="line"></span><br><span class="line">git merge 分支名    <span class="comment"># 合并分支</span></span><br><span class="line">git rebase 节点1 [节点2]  <span class="comment"># 取出一系列的提交记录（节点2从节点1的族系分离点开始的所有节点），“复制”它们，然后在另外一个地方逐个的放下去。使得两个分支的功能看起来像是按顺序开发； 把节点2放到节点1下面，节点2缺省默认是HEAD</span></span><br><span class="line"></span><br><span class="line">git rebase -i 分支名 <span class="comment"># 可视化, 选择指定节点后面的一些节点添加到指定节点后</span></span><br><span class="line"></span><br><span class="line">git pull origin master<span class="comment"># 获取最新的更改，并将它们合并到当前所在的本地分支中</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>git pull:</p>
<ol>
<li>暂存区 工作区 版本库 都会被替换成远程仓库分支的版本。</li>
</ol>
</blockquote>
<h1 id="git-搭建远程仓库"><a href="#git-搭建远程仓库" class="headerlink" title="git 搭建远程仓库"></a>git 搭建远程仓库</h1><p>github:<br>创建一个空仓库</p>
<p>本地:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&#x27;comment&#x27;</span></span><br><span class="line"></span><br><span class="line">git remote add origin 仓库路径 <span class="comment">#添加一个远程仓库地址名字叫origin（仅本地有效）</span></span><br><span class="line">git push origin master <span class="comment"># 把本地版本库-&gt; origin对应的远程仓库的master上</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>origin: 在本地仓库中对远程仓库起的别名, 一般叫 origin</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 仓库地址</span><br></pre></td></tr></table></figure>
<h2 id="拉取远程仓库到本地"><a href="#拉取远程仓库到本地" class="headerlink" title="拉取远程仓库到本地"></a>拉取远程仓库到本地</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch &lt;remote&gt; [place] <span class="comment"># 并不会改变你本地仓库的状态。它不会更新你的 main 分支，也不会修改你磁盘上的文件。</span></span><br><span class="line">git fetch &lt;remote&gt; [[<span class="built_in">source</span>]:&lt;destination&gt;] </span><br><span class="line">git pull 仓库地址 <span class="comment"># == git fetch + git merge ， 本地的远程分支同步改变</span></span><br></pre></td></tr></table></figure>



<h2 id="推送本地到远程仓库"><a href="#推送本地到远程仓库" class="headerlink" title="推送本地到远程仓库"></a>推送本地到远程仓库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push &lt;remote&gt; [place] <span class="comment"># 本地的远程分支同步改变</span></span><br><span class="line">git push &lt;remote&gt; [[<span class="built_in">source</span>]:&lt;destination&gt;] <span class="comment"># 把本地的source分支推送到远程的destination分支， destination不存在会创建</span></span><br></pre></td></tr></table></figure>

<p><code>git push origin main </code> 则是，把main分支推送到origin仓库里</p>
<p><code>git push origin main --force</code> 强制推送</p>
<h2 id="跟踪本地的远程分支"><a href="#跟踪本地的远程分支" class="headerlink" title="跟踪本地的远程分支"></a>跟踪本地的远程分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -u origin/main foo</span><br><span class="line">git checkout -b foo o/main</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>git push origin :foo</code> 删除远程仓库的foo分支</p>
<p><code>git fetch origin :bar</code> 在本地创建一个bar分支</p>
</blockquote>
<h2 id="回退"><a href="#回退" class="headerlink" title="回退"></a>回退</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard 版本号/分支名    <span class="comment">#本地版本回退， 版本号可以git log 看到</span></span><br><span class="line"></span><br><span class="line">git push origin master -f  <span class="comment">#强行推到远端，完全以我为准</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="整理提交记录-git-cherry-pick"><a href="#整理提交记录-git-cherry-pick" class="headerlink" title="整理提交记录 git cherry-pick"></a>整理提交记录 git cherry-pick</h1><p><code>git cherry-pick 版本号</code> 指定某些提交记录复制到当前所在的位置（<code>HEAD</code>）下面的话</p>
<ul>
<li>例如<code>git cherry-pick c1 c2 c3</code></li>
</ul>
<h1 id="标签-tag"><a href="#标签-tag" class="headerlink" title="标签 tag"></a>标签 tag</h1><p>唯一标记一个节点，不可移动</p>
<ul>
<li><code>git tag &lt;tagname&gt; 节点 </code></li>
</ul>
<p>不过不带节点，默认标记HEAD所指节点</p>
<ul>
<li><code>git describe 节点</code><ul>
<li>查找距离这个节点最近的tag</li>
<li>节点省略默认是HEAD</li>
<li>输出格式 <code>&lt;tagName&gt;_&lt;step&gt;_g&lt;hash&gt;</code></li>
</ul>
</li>
</ul>
<h1 id="公司常见git使用情况"><a href="#公司常见git使用情况" class="headerlink" title="公司常见git使用情况"></a>公司常见git使用情况</h1><ol>
<li>每个人在仓库里有自己的分支<br> <img src="/2023/10/17/git%E7%9A%84%E4%BD%BF%E7%94%A8/%E5%88%86%E6%94%AF.png" alt="多分支"></li>
<li>每个人先fork到自己仓库<br> <img src="/2023/10/17/git%E7%9A%84%E4%BD%BF%E7%94%A8/fork.png" alt="fork"></li>
</ol>
<h2 id="push不上-–-冲突"><a href="#push不上-–-冲突" class="headerlink" title="push不上 – 冲突"></a>push不上 – 冲突</h2><p><img src="/2023/10/17/git%E7%9A%84%E4%BD%BF%E7%94%A8/push.png" alt="push"></p>
<ol>
<li>没有权限</li>
<li>本地版本比线上落后<ul>
<li>解决：先<code>git pull</code>一下</li>
<li>解决：变基 rebase <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout feature    <span class="comment">#切换到feature分支</span></span><br><span class="line">git rebase master       <span class="comment">#</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><p><img src="https://img-blog.csdnimg.cn/36efc2704d174acab598c4b9addd3694.png"></p>
<p>执行上面两行代码后</p>
<p><img src="https://img-blog.csdnimg.cn/12b959efcc454da5a15b9fdec493d61b.png"></p>
<p>原理：当执行rebase操作时，git会从两个分支的共同祖先开始提取待变基分支上的修改，然后将待变基分支指向主分支的最新提交，最后将刚才提取的修改应用到主分支的最新提交的后面。</p>
<p>如果B后面没有M <code>git rebase</code>就与<code>git merge</code>没有区别</p>
<h1 id="冲突情况"><a href="#冲突情况" class="headerlink" title="冲突情况"></a>冲突情况</h1><ol>
<li>多人开发同一分支</li>
<li>不同分支同一文件被修改,然后 merge</li>
</ol>
<blockquote>
<p>解决: 多 pull</p>
</blockquote>
<h2 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h2><blockquote>
<p> 远程已经更新到新版本，而自己基于旧版本的新代码怎么发布</p>
</blockquote>
<p><img src="/2023/10/17/git%E7%9A%84%E4%BD%BF%E7%94%A8/media/situation1.png"></p>
<p><strong>解决方法1</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git rebase</span><br><span class="line">git push</span><br><span class="line"><span class="comment">### git pull --rebase  == git fetch + git rebase</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/10/17/git%E7%9A%84%E4%BD%BF%E7%94%A8/media/solution1.png"></p>
<p><strong>解决方法2</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch </span><br><span class="line">git merge  </span><br><span class="line">git push</span><br><span class="line"><span class="comment">#等价于 git pull + git push</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/10/17/git%E7%9A%84%E4%BD%BF%E7%94%A8/media/solution1-2.png"></p>
<h2 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h2><blockquote>
<p>远程服务器拒绝 可能是main被锁定了, 需要一些<code>Pull Request</code>来合并修改。如果你直接提交(commit)到本地main, 然后试图推送(push)修改, 你将会收到这样类似的信息:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">! [远程服务器拒绝] main -&gt; main (TF402455: 不允许推送(push)这个分支; 你必须使用pull request来更新这个分支.)</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>解决方法</strong></p>
<p>创建一个新分支</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/12/30/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>http详解</title>
    <url>/2023/10/16/http%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="http-1-0"><a href="#http-1-0" class="headerlink" title="http 1.0"></a>http 1.0</h1><ul>
<li>简单、灵活、易扩展、跨平台<ol>
<li>基本格式：header+body </li>
<li>header、status 都可以自定义</li>
<li>https &#x3D; http + tls&#x2F;ssl</li>
</ol>
</li>
<li>无状态： 服务器不会记录请求的状态</li>
<li>默认关闭 <code>keepalive</code>，每次请求都建立一次tcp连接，服务器处理后立即断开tcp连接</li>
</ul>
<blockquote>
<p>http1.0有队头阻塞， 即没收到第一个请求对应的响应 就不能发送第二个请求</p>
</blockquote>
<span id="more"></span>

<h1 id="http-1-1"><a href="#http-1-1" class="headerlink" title="http 1.1"></a>http 1.1</h1><ul>
<li>默认<code>keepalive|长连接</code></li>
<li><code>流水线模式</code>基于长连接，但是默认关闭</li>
</ul>
<blockquote>
<p>流水线模式解决了请求阻塞，不用等待前一个请求收到响应就可以发送下一个请求<br>但是对于响应队头阻塞没有解决。例如，服务器依次收到A和B，但是先完成了B却需要等待A完成先发送A。</p>
</blockquote>
<h2 id="keepalive的缺点"><a href="#keepalive的缺点" class="headerlink" title="keepalive的缺点"></a>keepalive的缺点</h2><p>keepalive会保持tcp连接一段时间，如果服务器要响应<strong>大量不同用</strong>户一次性的请求，会造成服务器同时保活多个tcp连接</p>
<h1 id="http-2-0"><a href="#http-2-0" class="headerlink" title="http 2.0"></a>http 2.0</h1><ol>
<li>二进制格式: 把传输消息分成更小的帧，并使用二进制格式编码。头部和数据体都是二进制格式</li>
<li>并发传输：引入Stream概念，每个请求分配到唯一的StreamID，多个Stream复用一条Tcp连接。每个Stream的帧之间是有序的，不同stream的帧是可以乱序的。</li>
<li>首部压缩：减小首部大小。先给对方一份 首部各字段和对应值 的编码表，之后首部只需要填入对应编码就可以。</li>
<li>服务端推送： 收到用户的请求后，预测用户可能会请求其他资源，主动将这些资源发送给客户端。</li>
</ol>
<blockquote>
<p>解决了响应队头阻塞<br>但是没有解决tcp层面的队头阻塞</p>
</blockquote>
<h2 id="tcp的队头阻塞"><a href="#tcp的队头阻塞" class="headerlink" title="tcp的队头阻塞"></a>tcp的队头阻塞</h2><p><img src="/./http%E8%AF%A6%E8%A7%A3/tcp%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E1.jpg"><br><img src="/./http%E8%AF%A6%E8%A7%A3/tcp%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E2.jpg"><br>多个Stream共用一个Tcp连接，即共用一个滑动窗口。那么当某个前面的stream的某个帧丢失，tcp协议规定必须按顺序读取，所以此时后面的stream全部被阻塞。</p>
<h1 id="http-3-0"><a href="#http-3-0" class="headerlink" title="http 3.0"></a>http 3.0</h1><p>回顾http1.1 未解决响应队头阻塞<br>回顾http2.0 未解决tcp层次的队头阻塞。<br>所以http3.0采用 <code>UDP + QUIC</code></p>
<ul>
<li>UDP: <ul>
<li>无序</li>
<li>不可靠</li>
</ul>
</li>
<li>QUIC：<ul>
<li>无队头阻塞</li>
<li>更快建立连接</li>
<li>连接迁移</li>
</ul>
</li>
</ul>
<ol>
<li>无队头阻塞？<br>  也有类似Stream与多路复用的概念，可以在同一条连接上并发传输多个Stream。当某个Stream丢包只阻塞这个Stream不影响其他Stream</li>
<li>更快的建立连接<br>  QUIC握手整合了TLS握手</li>
<li>连接迁移<br>  http2.0采用TCP四元组来标识一个连接，当用户切换网络就要重新建立连接。<br>  http3.0采用<strong>连接ID</strong>来标识，只要还有TLS密钥就可以无缝连接<blockquote>
<p>TCP四元组：（源IP+源端口+目的IP+目的端口）</p>
</blockquote>
</li>
</ol>
<h1 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h1><p>先思考一个场景，服务器需要主动给用户发送请求，而http貌似只能由用户发起请求，服务器在响应该请求</p>
<p>要解决这个痛点，有两种办法</p>
<ol>
<li>定时轮询: 前端定时发送请求给服务器<ol>
<li>例如：扫码登录</li>
</ol>
</li>
<li>长轮询: 设定一个时间比较长的超时时间，服务器收到请求后，先不响应，而是等待用户完成扫码操作，再响应。</li>
<li></li>
</ol>
<p>这种简单的请求可以用如上方法，但是如果是游戏场景呢？</p>
<p>websocket解决了，全双工。</p>
<p>http1.1 半双工</p>
<h1 id="http中谁主动断开tcp连接？"><a href="#http中谁主动断开tcp连接？" class="headerlink" title="http中谁主动断开tcp连接？"></a>http中谁主动断开tcp连接？</h1><p>两方都可以，但是客户端主动比较好。因为主动断开方最后需要等待2msl时间，会占用资源</p>
<p>如果响应头包含 <code>content-length</code>，则客户端知道什么时候接收完毕，客户端主动断开。<br>否则则服务端断开。</p>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>流程：</p>
<ol>
<li>第一次请求后缓存response的资源和header，并在下一次请求同一资源时<ol>
<li>根据expires和cache-control判断是否命中强缓存，如果命中则不再发起真实请求，但是状态码返回200.</li>
<li>未命中强缓存，则发起请求 .<ol>
<li>服务器根据请求头的IF-Modified-Since 或 IF-None-Match ， 他们的值分别表示 Last-Modified 缓存文件最晚一次修改时期，Etag 资源唯一标识(一般是hash) , 来判断缓存是否命。如果命中，服务器响应状态码为304。</li>
<li>未命中：浏览器发送资源以及新的header信息。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><ul>
<li>第一次响应后，响应头的 <code>Expires</code>和 <code>Cache-Control</code> 被保存起来<ul>
<li>Expires： 资源过期日期。</li>
<li>Cache-Control：<ul>
<li>max-age: 资源有效时长， 结合响应头的 <code>Date</code> 算出资源过期时间。</li>
<li>no-cache：使用协商缓存策略。</li>
<li><strong>优先级</strong>高于Expires</li>
</ul>
</li>
</ul>
</li>
<li>如果命中，则使用本地资源。</li>
<li>如果未命中，则走协商缓存策略。</li>
</ul>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p><img src="/./http%E8%AF%A6%E8%A7%A3/%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98.png" alt="img"></p>
<ul>
<li>协商缓存由服务器决定资源是否可用</li>
<li>主要涉及到两对属性， 第一次响应头里的 <code>last-Modified</code>或 <code>Etag</code> 以及 后续请求头里的 <code>If-Modified-Since</code> 或 <code>If-None-Match</code> ，它们的值对应相等。</li>
<li>第二次请求时，请求头带上 <code>If-Modified-Since</code> 或 <code>If-None-Match</code> ，服务器通过这两个属性判断资源是否变化，从而判断资源是否可用。<ul>
<li>如果资源不可用（更新了），则返回200，和最新资源以及新的 <code>last-Modified</code> 或 <code>Etag</code></li>
<li>如果资源可用（不变），则返回304，表示直接从缓存里拿资源</li>
</ul>
</li>
</ul>
<h1 id="tcp粘包"><a href="#tcp粘包" class="headerlink" title="tcp粘包"></a>tcp粘包</h1><p>首先tcp是面向字节流的，在发送数据时需要把数据分成一个个报文</p>
<p>报文有两种情况：</p>
<ul>
<li>大于等于mss（最小报文长度）—— 直接发送</li>
<li>小于mss —— 等待以下一个报文一起发送</li>
</ul>
<p>可能出现如下情况，就是粘包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mss1.1 ===&gt; 发送</span><br><span class="line"></span><br><span class="line">mss1.2 + mss2.1 ===&gt; 发送</span><br><span class="line"></span><br><span class="line">mss2.2 + mss3.1 ===&gt; 发送</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>nextTick原理与作用</title>
    <url>/2023/12/24/nextTick%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h1 id="nextTick-作用"><a href="#nextTick-作用" class="headerlink" title="nextTick 作用"></a>nextTick 作用</h1><p>在一轮里，对一个数据进行多次修改时，不会每次都渲染而是一轮结束时渲染。<br>nextTick里的回调会在当前轮次渲染结束后在执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">nextTick</span>(<span class="function">()=&gt;</span> &#123;&#125;)</span><br><span class="line"><span class="title function_">nextTick</span>().<span class="title function_">then</span>()</span><br></pre></td></tr></table></figure>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><ol>
<li>在<code>updated生命周期</code>之后立即执行</li>
<li>为了避免不必要的计算，数据更新会放入微队列，vue会在下一个<code>tick</code>里执行已去重的任务</li>
<li>nextTick本身不会主动触发渲染</li>
</ol>
<h2 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h2><ol>
<li>promise</li>
<li>MutationObserver</li>
<li>setInterval</li>
<li>setTimeout</li>
</ol>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>nextTick</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx</title>
    <url>/2023/10/11/nginx/</url>
    <content><![CDATA[<ul>
<li>在<code>nignx.exe</code>所在目录启动nginx   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></table></figure></li>
<li>查看所有进程信息  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef | grep nginx 查看nginx所有进程信息</span><br></pre></td></tr></table></figure></li>
<li>查看端口占用情况  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#80表示查看80端口的</span></span><br><span class="line">lsof -i:80</span><br></pre></td></tr></table></figure></li>
<li>停止nignx   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -s quit   <span class="comment">#优雅停止</span></span><br><span class="line">nginx -s stop   <span class="comment">#立即停止</span></span><br><span class="line">nginx -s reload <span class="comment">#重载配置文件</span></span><br></pre></td></tr></table></figure></li>
<li>查看配置  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -V <span class="comment">#查看配置</span></span><br><span class="line">nginx -t <span class="comment">#检查配置是否出错</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="nginx-基本配置"><a href="#nginx-基本配置" class="headerlink" title="nginx 基本配置"></a>nginx 基本配置</h1><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">event</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/mime.types;     <span class="comment">#导入文件MIME类型</span></span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> localhost;</span><br><span class="line">        <span class="attribute">root</span>  /dist; <span class="comment"># 访问80端口返回root页面</span></span><br><span class="line">        <span class="attribute">index</span> egg.html; <span class="comment">#默认访问index.html，配置后以配置优先 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="location-的使用"><a href="#location-的使用" class="headerlink" title="location 的使用"></a>location 的使用</h2><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="section">location</span> / &#123;        <span class="comment"># 访问根目录下的请求都从/dist目录下开始寻找资源</span></span><br><span class="line">        <span class="attribute">root</span> /dist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 完全指定请求地址对应的资源地址</span></span><br><span class="line"><span class="section">location</span> = /app/index.html &#123; </span><br><span class="line">    <span class="attribute">root</span> /dist;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 也可以开启正则</span></span><br><span class="line"><span class="section">location</span> <span class="regexp">~ /videos/video[6-9].avi</span> &#123;</span><br><span class="line">    <span class="attribute">root</span> /videos/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>node.js基本使用</title>
    <url>/2023/10/24/node-js%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>node中模块分为：</p>
<ul>
<li>内置模块：fs，path，os，http</li>
<li>自定义</li>
<li>第三方</li>
</ul>
<span id="more"></span>

<h1 id="global"><a href="#global" class="headerlink" title="global"></a>global</h1><h1 id="process"><a href="#process" class="headerlink" title="process"></a>process</h1><p>当前node.js进程</p>
<p><code>process.nextTick()</code>下一轮事件循环</p>
<h1 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h1><h2 id="readFile"><a href="#readFile" class="headerlink" title="readFile"></a>readFile</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="comment">//异步</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(path [, options], <span class="function">(<span class="params">error,data</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>());</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>options: </p>
<ul>
<li>encoding 编码格式，默认null，一般传入<code>utf-8</code></li>
<li>flag 读取方式，默认只读r</li>
</ul>
</li>
<li><p>回调：</p>
<ul>
<li>error表示错误</li>
<li>data：可能是字符串也可能是Buffer</li>
</ul>
</li>
</ul>
<h2 id="writeFile"><a href="#writeFile" class="headerlink" title="writeFile"></a>writeFile</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2. 写入fs.writeFile(path, data [, options], callback)类似于fs.readFile</span></span><br><span class="line"><span class="comment">// data支持&lt;string&gt; 、 &lt;Buffer&gt; 、 &lt;TypedArray&gt; 、&lt;DataView&gt;&lt;/DataView&gt;</span></span><br><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;./demo.txt&#x27;</span>,<span class="string">&#x27;123123123123&#x27;</span>,<span class="function">(<span class="params">error</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(error)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;写入失败&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>options:<ul>
<li>flag ：<ul>
<li>默认，’w’，覆盖，不存在就创建</li>
<li>‘a’ 代表追加</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="readdir"><a href="#readdir" class="headerlink" title="readdir"></a>readdir</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dir = fs.<span class="title function_">readdirSync</span>(__dirname)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dir)</span><br><span class="line"><span class="comment">//返回string[]</span></span><br></pre></td></tr></table></figure>



<h1 id="path"><a href="#path" class="headerlink" title="path"></a>path</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> p = <span class="string">&#x27;./Adir/a.txt&#x27;</span></span><br><span class="line"><span class="comment">// /Adir/a.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//0. 获取根目录绝对地址</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(__dirname);</span><br><span class="line"><span class="comment">//__filename 当前文件的绝对地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 获取目录</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">dirname</span>(p));</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 获取文件名+后缀</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">basename</span>(p));</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 获取文件后缀</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">extname</span>(p));</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 将路径解析为绝对路径，可以接收任意个参数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">resolve</span>(__dirname,p));</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. join 连接路径</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;./file.txt&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="url"><a href="#url" class="headerlink" title="url"></a>url</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;https://www.google.com:8080/a/b?x=1&amp;y=2&amp;y=3&amp;y=4#qq=2522&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// parse(&#x27;url&#x27;, bool ) //布尔表示把query参数转换成对象</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(url.<span class="title function_">parse</span>(str,<span class="literal">true</span>));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Url &#123;</span></span><br><span class="line"><span class="comment">  protocol: &#x27;https:&#x27;,   协议</span></span><br><span class="line"><span class="comment">  slashes: true,</span></span><br><span class="line"><span class="comment">  auth: null,       </span></span><br><span class="line"><span class="comment">  host: &#x27;www.google.com:8080&#x27;,  //主机= 域名+端口</span></span><br><span class="line"><span class="comment">  port: &#x27;8080&#x27;,                 //端口</span></span><br><span class="line"><span class="comment">  hostname: &#x27;www.google.com&#x27;,   //域名</span></span><br><span class="line"><span class="comment">  hash: #qq=2522,               //hash值</span></span><br><span class="line"><span class="comment">  search: &#x27;?x=1&amp;y=2&amp;y=3&amp;y=4&#x27;,</span></span><br><span class="line"><span class="comment">  query: &#x27;x=1&amp;y=2&amp;y=3&amp;y=4&#x27;,     //query参数</span></span><br><span class="line"><span class="comment">  pathname: &#x27;/a/b&#x27;,             //路径</span></span><br><span class="line"><span class="comment">  path: &#x27;/a/b?x=1&amp;y=2&amp;y=3&amp;y=4&#x27;,</span></span><br><span class="line"><span class="comment">  href: &#x27;https://www.google.com:8080/a/b?x=1&amp;y=2&amp;y=3&amp;y=4#qq=2522&#x27;//原地址</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>#Buffer</p>
<p>用来存储二进制数据，（以0~F表示）</p>
<p>每个元素1B</p>
<p>一旦确定Buffer大小，后续不能改变</p>
<p>默认都是utf-8</p>
<p>常用方法：</p>
<ol>
<li><code>Buffer.from（str [,encoding])</code>:  把一个字符转换为Buffer</li>
<li><code>Buffer.alloc(size)</code>: 创建指定大小的Buffer</li>
<li><code>Buffer.allocUnsafe(size)</code>: 创建时不会清理地址原始数据</li>
<li><code>buf.toString()</code>： 把Buffer转换为字符串</li>
</ol>
]]></content>
      <categories>
        <category>node.js</category>
      </categories>
      <tags>
        <tag>node.js</tag>
        <tag>fs</tag>
        <tag>path</tag>
      </tags>
  </entry>
  <entry>
    <title>promise笔记</title>
    <url>/2023/10/11/promise%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Porimise-resolve-obj-Promise-reject-obj"><a href="#Porimise-resolve-obj-Promise-reject-obj" class="headerlink" title="Porimise.resolve(obj) Promise.reject(obj)"></a>Porimise.resolve(obj) Promise.reject(obj)</h1><ol>
<li>obj是非Promise对象,其状态PromiseState一定是 fulfilled</li>
<li>obj是Promise对象, 则根据obj的状态PromiseState是 fulfilled或 rejected 来决定整体的</li>
<li>resolve或 reject 本质是把 PromiseState 从 pending –&gt; fulfilled&#x2F; rejected</li>
<li>状态不为pending 就会调用then</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">&quot;ok!&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Promise</span></span><br><span class="line"><span class="comment">[[Prototype]]: Promise</span></span><br><span class="line"><span class="comment">[[PromiseState]]: &quot;rejected&quot;</span></span><br><span class="line"><span class="comment">[[PromiseResult]]: &quot;ok!&quot;</span></span><br><span class="line"><span class="comment">Uncaught (in promise) ok!</span></span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res&quot;</span>,res);</span><br><span class="line">&#125;, <span class="function">(<span class="params">err</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err&quot;</span>,err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//方式二：</span></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;res&quot;</span>,res);</span><br><span class="line">    &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err&quot;</span>,err)</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">//err ok!</span></span><br></pre></td></tr></table></figure>

<h1 id="Promise-all-Promise"><a href="#Promise-all-Promise" class="headerlink" title="Promise.all(Promise[])"></a>Promise.all(Promise[])</h1><p>一次性执行多个异步,返回数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;p1&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;p2&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;p3&#x27;</span>);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([p1,p2,p3]).<span class="title function_">then</span>(<span class="function"><span class="params">results</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(results)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">errs</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(errs)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// [&#x27;p1&#x27;, &#x27;p2&#x27;, &#x27;p3&#x27;]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果是</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;p1&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;p2&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;p3&#x27;</span>);</span><br><span class="line"><span class="comment">//只输出p2， 因为运行到p2就直接捕获错误了，</span></span><br></pre></td></tr></table></figure>

<h1 id="Promise-race-Promise"><a href="#Promise-race-Promise" class="headerlink" title="Promise.race(Promise[])"></a>Promise.race(Promise[])</h1><p>返回遇到的第一个状态转为成功的promise对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;a1&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> a2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;a2&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> a3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;a3&quot;</span>); </span><br><span class="line"><span class="keyword">const</span> a = <span class="title class_">Promise</span>.<span class="title function_">race</span>([a1,a2,a3])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) </span><br><span class="line"><span class="comment">//Promise&#123;PromiseState:&#x27;rejected&#x27;, PromiseResult:&#x27;a1&#x27;&#125;</span></span><br><span class="line"><span class="comment">//Uncaught (in promise) a1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;a1&quot;</span>).<span class="title function_">catch</span>(); <span class="comment">//处理a1的报错</span></span><br><span class="line"><span class="keyword">const</span> a2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;a2&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> a3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&quot;a3&quot;</span>); </span><br><span class="line"><span class="keyword">const</span> a = <span class="title class_">Promise</span>.<span class="title function_">race</span>([a1,a2,a3])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) </span><br><span class="line"><span class="comment">//Promise&#123;PromiseState:&#x27;fulfilled&#x27;, PromiseResult:&#x27;a2&#x27;&#125; 顺利返回a2</span></span><br></pre></td></tr></table></figure>

<h1 id="then-链式调用"><a href="#then-链式调用" class="headerlink" title=".then()链式调用"></a>.then()链式调用</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;resolve&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result) <span class="comment">//输出 resolve</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// 输出 undefined</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, rejedct</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;resolve2&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// 输出 resolve2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;reject&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(err)) <span class="comment">//输出 reject</span></span><br></pre></td></tr></table></figure>

<h1 id="异常穿透"><a href="#异常穿透" class="headerlink" title="异常穿透"></a>异常穿透</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result)<span class="comment">// 输出 p</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res) <span class="comment">// 输出 undefined</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;reject 1&quot;</span>) <span class="comment">//返回状态rejected，直接跳过后面所有then进入catch ！！！</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;执行了&#x27;</span>) <span class="comment">// 不输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&quot;reject 2&quot;</span>) <span class="comment">//第二个错误也不会理会</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;err&quot;</span>, err) <span class="comment">// 只输出 reject 1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="中断链式调用"><a href="#中断链式调用" class="headerlink" title="中断链式调用"></a>中断链式调用</h1><p>当PromiseState: pending时，不会进入then()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;then&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">() =&gt;</span> &#123; &#125;) <span class="comment">//返回状态为pending的Promise对象</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;then2&quot;</span>) <span class="comment">//不输出</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="async-await"><a href="#async-await" class="headerlink" title="async &amp; await"></a>async &amp; await</h1><p><strong>async</strong></p>
<ol>
<li>async 返回Promise对象</li>
<li>async function fn(){} 返回结果由fn的结果决定</li>
</ol>
<p><strong>await</strong></p>
<ol>
<li>右边一般是Promise对象</li>
<li>如果表达式是Promise对象, 返回Promise成功的值</li>
<li>如果表达式是其他值,直接返回</li>
</ol>
<blockquote>
<p>注意: i.  await必须写在async中<br>    ii.  await右边promise失败（状态为rejected）会抛出异常,需要用try catch<br>   iii. await 不可以在文件顶层使用（用立即执行函数包裹）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> asyncFn2 =  <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>)</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;ok&#x27;</span>)</span><br><span class="line">        &#125;, <span class="number">1500</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">await</span> <span class="title function_">asyncFn2</span>())</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>toString &amp; valueOf</title>
    <url>/2023/10/11/toString-valueOf/</url>
    <content><![CDATA[<h1 id="valueOf-和-toString"><a href="#valueOf-和-toString" class="headerlink" title="valueOf 和 toString"></a>valueOf 和 toString</h1><p>都是Object原型上的方法，很多重要类型的原型都重写了他们</p>
<p>valueOf ： </p>
<ol>
<li>返回包装类型对象的原始值</li>
</ol>
<p>toString:</p>
<ol>
<li>对于<code>Number、Boolean、String、Array、Date、RegExp、Function</code> 重写了，</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line">num.<span class="title function_">toString</span>(); <span class="comment">// &#x27;123&#x27;</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;12df&#x27;</span>);</span><br><span class="line">str.<span class="title function_">toString</span>(); <span class="comment">// &#x27;12df&#x27;</span></span><br><span class="line"><span class="keyword">var</span> bool = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="string">&#x27;fd&#x27;</span>);</span><br><span class="line">bool.<span class="title function_">toString</span>(); <span class="comment">// &#x27;true&#x27;</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>([<span class="number">123</span>,<span class="number">23</span>,<span class="number">45</span>,<span class="string">&#x27;asdsad&#x27;</span>])</span><br><span class="line">arr.<span class="title function_">toString</span>(); <span class="comment">// &#x27;123,23,45,asdsad&#x27;</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">d.<span class="title function_">toString</span>(); <span class="comment">// &quot;Sun Jul 22 2018 12:38:42 GMT+0800 (中国标准时间)&quot;</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="keyword">function</span> (<span class="params">params</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(params)</span><br><span class="line">&#125;</span><br><span class="line">fn.<span class="title function_">toString</span>(); <span class="comment">// &#x27;function (params) &#123;\n    console.log(params)\n&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>对于<code>Object、Math</code>都是返回对象的类型<code>[object type]</code>其中type就是对象类型。 例如：<code>[object object]  [object math]</code></li>
</ol>
]]></content>
      <categories>
        <category>js红宝书</category>
      </categories>
      <tags>
        <tag>toString</tag>
        <tag>valueOf</tag>
      </tags>
  </entry>
  <entry>
    <title>v-model</title>
    <url>/2024/02/11/v-model/</url>
    <content><![CDATA[<h2 id="在原生上实现v-model效果"><a href="#在原生上实现v-model效果" class="headerlink" title="在原生上实现v-model效果"></a>在原生上实现v-model效果</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;msg&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;(e) =&gt; &#123; msg = parseInt(e.target.value) &#125;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>事件第一个参数是事件对象</p>
</blockquote>
<h2 id="Vue3-4以前-在组件上实现v-model效果"><a href="#Vue3-4以前-在组件上实现v-model效果" class="headerlink" title="Vue3.4以前 在组件上实现v-model效果"></a>Vue3.4以前 在组件上实现v-model效果</h2><ul>
<li>自定义事件<ul>
<li>事件名为 <code>update:value</code></li>
</ul>
</li>
<li></li>
</ul>
<p><strong>App.vue</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Comp</span> <span class="attr">:value</span>=<span class="string">&quot;msg&quot;</span> @<span class="attr">update:value</span>=<span class="string">&quot;val =&gt; msg = val&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Comp</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>Comp.vue</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">&quot;props.value&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;emits(&#x27;update:value&#x27;, $event.target.value)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Vue3-4-defineModel"><a href="#Vue3-4-defineModel" class="headerlink" title="Vue3.4 defineModel"></a>Vue3.4 defineModel</h2><blockquote>
<p>帮助我们封装组件</p>
</blockquote>
<ul>
<li>可以同步</li>
<li>一个组件可以同时使用多个v-model</li>
<li>宏指令<ul>
<li>用于setup语法糖里</li>
<li>编译时</li>
</ul>
</li>
</ul>
<p><strong>App.vue</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Computer</span> <span class="attr">v-model:first-num</span>=<span class="string">&quot;val1&quot;</span> <span class="attr">v-model:second-num</span>=<span class="string">&quot;val2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Computer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>Computer.vue</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> firstNum = <span class="title function_">defineModel</span>(<span class="string">&#x27;firstNum&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> secondNum = <span class="title function_">defineModel</span>(<span class="string">&#x27;secondNum&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="comment">//如果父组件的v-model没有arg v-model=&quot;val&quot; ， 则 const val = defineModel() </span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">v-model.number</span>=<span class="string">&quot;firstNum&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span> +</span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">v-model.number</span>=<span class="string">&quot;secondNum&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span> =</span><br><span class="line">      &#123;&#123; firstNum + secondNum &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义指令手写v-mode"><a href="#自定义指令手写v-mode" class="headerlink" title="自定义指令手写v-mode"></a>自定义指令手写v-mode</h2><p><strong>Question</strong></p>
<ol>
<li>为什么不能用 <code>binding.value</code>  <ul>
<li>因为binding.value <text style="color:red">是值而不是引用</text>，不能实现 view—&gt;model 层的流动</li>
</ul>
</li>
<li>为什么要用  <code>toRef(binding.instance, binding.arg)</code><ol>
<li>首先不能 <code>binding.instance[binding.arg]</code> 它会被解包成值类型</li>
<li>所以创建一个ref， 它与 外部传进来的ref 保持同步</li>
</ol>
</li>
<li>为什么要<code>defineExpose(&#123;msg&#125;)</code><ul>
<li>setup语法糖要手动暴露自身内部变量 </li>
<li><code>defineExpose</code>暴露出去的变量才会挂载到<code>binding.instance</code> 即这个组件实例上</li>
</ul>
</li>
</ol>
<p><strong>已解决</strong></p>
<ol>
<li>双向绑定</li>
<li>同时使用多个v-oh-model</li>
</ol>
<blockquote>
<p>依然无法解决的问题</p>
<ol>
<li><strong>写法不同</strong> 必须要加args，但是value可以省略。 写成：v-oh-model:msg </li>
<li><strong>defineExpose</strong> <code>&lt;script setup&gt;</code> 下必须要手动暴露</li>
</ol>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span> <span class="attr">lang</span>=<span class="string">&#x27;ts&#x27;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; ref, toRef, watchEffect &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> <span class="title class_">VOhModel</span> = &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">mounted</span>(<span class="params">el, binding</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> _val = <span class="title function_">toRef</span>(binding.<span class="property">instance</span>, binding.<span class="property">arg</span>)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// model ---&gt; view</span></span></span><br><span class="line"><span class="language-javascript">    el.<span class="property">$onWatchEffect</span> = <span class="title function_">watchEffect</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      el.<span class="property">value</span> = _val.<span class="property">value</span></span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// view ---&gt; model</span></span></span><br><span class="line"><span class="language-javascript">    el.<span class="property">$onInput</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      _val.<span class="property">value</span> = el.<span class="property">value</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    el.<span class="title function_">addEventListener</span>(<span class="string">&#x27;input&#x27;</span>, el.<span class="property">$onInput</span>)</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">unmounted</span>(<span class="params">el, binding</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    el.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;input&#x27;</span>, el.<span class="property">$onInput</span>)</span></span><br><span class="line"><span class="language-javascript">    el.$onWatchEffect()</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">const</span> msg = <span class="title function_">ref</span>(<span class="string">&quot;Hello Vue.js&quot;</span>)</span></span><br><span class="line"><span class="language-javascript"><span class="title function_">defineExpose</span>(&#123; msg &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-oh-model:msg</span>=<span class="string">&quot;msg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;msg += 1&quot;</span>&gt;</span> + <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据这次体验，我感觉自动解包有时候真是副作用。<br>或许这就是Vue的设计模式，但是也确实限制了程序员的发挥。</p>
<p>如果这里能直接拿到msg变量的引用，哪还需要这么麻烦</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2和vue3都重写了数组方法</title>
    <url>/2024/06/13/vue2%E5%92%8Cvue3%E9%83%BD%E9%87%8D%E5%86%99%E4%BA%86%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="vue2和vue3都重写了数组方法"><a href="#vue2和vue3都重写了数组方法" class="headerlink" title="vue2和vue3都重写了数组方法"></a>vue2和vue3都重写了数组方法</h1><h2 id="vue2的defineProperty"><a href="#vue2的defineProperty" class="headerlink" title="vue2的defineProperty"></a>vue2的defineProperty</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> _val = obj[key];</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> _val;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set&#x27;</span>)</span><br><span class="line">            _val = newVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>defineProperty利用闭包， 对_val进行set和get，称为数据劫持。</p>
</blockquote>
<ul>
<li>defineProperty的缺陷</li>
</ul>
<p>由此可见defineProperty的响应式粒度是key级别的。也就是说，已知的属性才有办法劫持其getter和setter，所以其根本没有办法对<strong>未知的key</strong>劫持做响应。</p>
<ul>
<li>为什么vue2不对数组进行劫持？而是重写数组方法？</li>
</ul>
<span id="more"></span>

<p>在vue2直接通过下标修改数组是不会响应式更新的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr[<span class="number">0</span>] = <span class="string">&#x27;xxx&#x27;</span>  <span class="comment">//×</span></span><br><span class="line"><span class="variable language_">this</span>.$set(arr,<span class="number">0</span>,<span class="string">&#x27;xxx&#x27;</span>) <span class="comment">//√</span></span><br></pre></td></tr></table></figure>
<p>原因：</p>
<ol>
<li>数组如果很大，会产生大量闭包，耗费大量内存。</li>
<li>一般开发者只关心数组本身的变化，而不关心每个元素内部的变化。而这些数组方法恰好只关注数组本身的变化。</li>
<li>要对数组劫持的话，对于<strong>未知的key</strong>无法配置getter和setter。</li>
</ol>
<ul>
<li>那为什么对象就劫持了呢？<br>因为对象和数组关注点不同，数组自身可能变化；而对象自生一般不变化，关注属性的变化。</li>
</ul>
<h2 id="vue3的重写数组方法"><a href="#vue3的重写数组方法" class="headerlink" title="vue3的重写数组方法"></a>vue3的重写数组方法</h2><p>基于<code>Proxy</code>实现响应式，其粒度在对象级别, 所以对于<strong>未知的key</strong>也能实现响应式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>vue3还要重写数组方法？<br>因为利用<code>Proxy</code>返回的是代理对象，和原本对象不相等。所以需要重写一些查找相关的方法。<br>但是vue3还重写了一些修改相关的方法。为什么，有必要吗？</li>
</ul>
<p>因为调用push等方法会</p>
<ol>
<li>访问push属性</li>
<li>访问length属性</li>
<li>修改length属性</li>
</ol>
<p>当访问length属性也被收集做依赖，那么接下来修改length会导致此方法被无限调用</p>
<ul>
<li>而且Vue3代理是惰性的</li>
</ul>
<p>不像defineProperty一样需要先遍历所有key，对所有key做劫持。而是读到该属性为对象时才会递归reactive</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">target</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;计数&#x27;</span>) <span class="comment">//只打印一次</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get&#x27;</span>, prop)</span><br><span class="line">            <span class="keyword">if</span> (target[prop] <span class="keyword">instanceof</span> <span class="title class_">Object</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">reactive</span>(target[prop])</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;set&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;lzy&#x27;</span>,</span><br><span class="line">    <span class="attr">friend</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3的性能提升</title>
    <url>/2024/03/04/vue3%E7%9A%84%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="1-diff-算法的优化"><a href="#1-diff-算法的优化" class="headerlink" title="1. diff 算法的优化"></a>1. diff 算法的优化</h1><p>增加了静态标记， 被标记为-1的节点不会参与diff比较。</p>
<p>因为为vue3可以实现精准定位到动态节点，即那些可能需要重新渲染的节点。</p>
<p>曾经diff需要一层层比较整个新旧虚拟dom树找到哪些值改变。</p>
<ul>
<li>现在vue3在编译时，利用静态标记patchFlag 标记节点的动态属性。</li>
</ul>
<p>例如class、style、props，含有动态属性的节点就是动态节点。</p>
<ul>
<li><p>每个组件的顶层vnode会有一个<code>dynamicChildren</code>属性，以数组形式存放该节点下所有动态节点。</p>
</li>
<li><p>在运行render后，会遍历这个数组进行靶向更新。也就是说只需要比较动态节点的新旧变化了</p>
</li>
</ul>
<h1 id="2-静态提升"><a href="#2-静态提升" class="headerlink" title="2. 静态提升"></a>2. 静态提升</h1><p>对于静态节点，把创建dom节点的放在render函数之外。这样就只用创建一次，多次复用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createBlock</span>(_Fragment, <span class="literal">null</span>, [</span><br><span class="line">    <span class="title function_">_createVNode</span>(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;你好&quot;</span>),</span><br><span class="line">    <span class="title function_">_createVNode</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, <span class="title function_">_toDisplayString</span>(_ctx.<span class="property">message</span>), <span class="number">1</span> <span class="comment">/* TEXT */</span>)</span><br><span class="line">  ], <span class="number">64</span> <span class="comment">/* STABLE_FRAGMENT */</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提升后</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _hoisted_1 = <span class="comment">/*#__PURE__*/</span><span class="title function_">_createVNode</span>(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;你好&quot;</span>, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createBlock</span>(_Fragment, <span class="literal">null</span>, [</span><br><span class="line">    _hoisted_1,</span><br><span class="line">    <span class="title function_">_createVNode</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, <span class="title function_">_toDisplayString</span>(_ctx.<span class="property">message</span>), <span class="number">1</span> <span class="comment">/* TEXT */</span>)</span><br><span class="line">  ], <span class="number">64</span> <span class="comment">/* STABLE_FRAGMENT */</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the console for the AST</span></span><br></pre></td></tr></table></figure>

<h1 id="3-事件监听缓存"><a href="#3-事件监听缓存" class="headerlink" title="3. 事件监听缓存"></a>3. 事件监听缓存</h1><p>用一个cache缓存事件处理函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createBlock</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">    <span class="title function_">_createVNode</span>(<span class="string">&quot;button&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">onClick</span>: _cache[<span class="number">1</span>] || (_cache[<span class="number">1</span>] = <span class="function">(<span class="params">...args</span>) =&gt;</span> (_ctx.<span class="title function_">onClick</span>(...args)))</span><br><span class="line">    &#125;, <span class="string">&quot;点我&quot;</span>)</span><br><span class="line">  ]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-Tree-shaking"><a href="#4-Tree-shaking" class="headerlink" title="4. Tree shaking"></a>4. Tree shaking</h1><p>tree shaking 是一种清除多于代码的优化打包体积的技术。</p>
<ul>
<li>vue2中所有功能代码都被打包，因为vue2是单例模式，所有方法都在vue构造函数生成的单例上，treeshaking无法区分某个属性、方法是否用到。</li>
<li>vue3利用ES6 module。 静态编译时就可以把未使用的功能排除</li>
</ul>
<h1 id="5-响应式系统"><a href="#5-响应式系统" class="headerlink" title="5. 响应式系统"></a>5. 响应式系统</h1><ul>
<li>vue2 使用 <code>defineProperty</code> 来劫持对象，深度遍历所有属性给每个属性添加 <code>getter setter</code></li>
<li>vue3 使用 <code>Proxy</code> 代理对象。<ul>
<li><code>defineProperty</code> 只能劫持对象属性，所以需要遍历所有属性。而<code>Proxy</code>是直接代理对象。</li>
<li>vue2由于<code>defineProperty</code> 而不能监听数组，所以要重写数组方法。</li>
<li>当一个对象的属性还是一个对象时，<code>Proxy</code> 采用懒递归，在getter发现读到的属性时对象时才会创建该对象的代理并返回。</li>
</ul>
</li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue底层原理</title>
    <url>/2023/10/20/vue%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="虚拟Dom"><a href="#虚拟Dom" class="headerlink" title="虚拟Dom"></a>虚拟Dom</h1><p>虚拟DOM是一个在内存中的数据结构，它是真实DOM的抽象表示。虚拟DOM是由一系列的虚拟节点（VNode）组成的，每一个虚拟节点都对应一个真实的DOM节点。</p>
<p><strong>作用：</strong><br>虚拟DOM的主要作用是提供一个在内存中操作DOM的平台，使得我们可以在不直接操作真实DOM的情况下进行复杂的操作。当状态变化时，Vue会生成一个新的虚拟节点树，然后和旧的虚拟节点树进行对比，找出差异，然后只更新差异部分到真实的DOM上，这个过程称为“打补丁”。</p>
<p><strong>优势：</strong></p>
<p>性能优化：由于直接操作DOM通常是前端性能瓶颈的主要原因，虚拟DOM通过在内存中进行计算，避免了直接操作DOM，从而提高了性能。<br>跨平台：虚拟DOM不仅可以表示浏览器中的DOM，还可以表示其他的平台，比如移动应用的UI。<br><strong>缺陷：</strong></p>
<p>首次渲染开销大：虚拟DOM需要在内存中构建一颗DOM树，所以在首次渲染时，虚拟DOM的开销会比直接操作DOM大。<br>内存消耗：虚拟DOM需要在内存中维护一颗DOM树，这会消耗一定的内存。</p>
<blockquote>
<p>一个虚拟Dom节点至少包括三个属性：type、attr、children</p>
</blockquote>
<h1 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h1><h2 id="effect-副作用"><a href="#effect-副作用" class="headerlink" title="effect 副作用"></a>effect 副作用</h2><p>effect是一个‘桶’， 他收集并触发指定方法</p>
<p><img src="/2023/10/20/vue%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/effect.png"><br><img src="/2023/10/20/vue%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/effect2.png"></p>
<!-- more -->

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. </span></span><br><span class="line"><span class="comment"> * effect 函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fn 执行方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> 以 ReactiveEffect 实例为 this 的执行函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">effect</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> _effect = <span class="keyword">new</span> <span class="title class_">ReactiveEffect</span>(fn)</span><br><span class="line">    _effect.<span class="title function_">run</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2. </span></span><br><span class="line"><span class="comment"> * 响应性触发依赖时的执行类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">let</span> activeEffect <span class="comment">//当前副作用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReactiveEffect</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">fn</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">fn</span> = fn</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//告诉全局当前执行的 ReactiveEffect 的实例</span></span><br><span class="line">        activeEffect = <span class="variable language_">this</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">fn</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>计算属性的实现流程</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fullName = <span class="title function_">computed</span>(<span class="function">()=&gt;</span> firstName.<span class="property">value</span> + lastName.<span class="property">value</span>)</span><br><span class="line"><span class="comment">//计算属性创建了一个Ref，并且这个Ref的getter会调用此函数。</span></span><br><span class="line"><span class="comment">//内部有一个dirty代表值是不是脏的，初始为true。用作缓存功能。</span></span><br><span class="line"><span class="comment">//本质上调用了</span></span><br><span class="line"><span class="title function_">effect</span>(<span class="function">()=&gt;</span>firstName.<span class="property">value</span> + lastName.<span class="property">value</span>)</span><br><span class="line"><span class="comment">//此时读取了firstName和lastName，触发了依赖收集。且此时activeEffect指向此箭头函数</span></span><br><span class="line"><span class="comment">//此函数作为依赖被收集进了set里，每当firstName或lastName改变，就会触发trigger重新调用此箭头函数，并把dirty=true</span></span><br><span class="line"><span class="comment">//如果下一次读取计算属性，且dirty==true，那么会重新调用此函数，如果false则使用缓存。但是对于在模板里使用的计算属性则会响应式的更新而不是等待下一次读取。</span></span><br></pre></td></tr></table></figure>
<h3 id="响应式系统设计"><a href="#响应式系统设计" class="headerlink" title="响应式系统设计"></a>响应式系统设计</h3><p><img src="/2023/10/20/vue%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/reactiveSys.jpg"></p>
<ul>
<li>依赖，就是需要重复调用的函数</li>
<li>用set保存依赖，防止重复调用</li>
<li>用map关联属性和依赖集合，key一个对象里的属性，value指向依赖集合</li>
<li>用weakmap管理多个对象。</li>
</ul>
<h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><blockquote>
<p>reactive 只能监听复杂数据类型，因为proxy只能监听负责数据类型的getter和setter</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">target, key, recv</span>)&#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">            <span class="comment">//收集依赖</span></span><br><span class="line">            <span class="title function_">track</span>(target, key)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">target, key, newValue, recv</span>)&#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">            <span class="comment">//触发依赖</span></span><br><span class="line">            <span class="title function_">trigger</span>(target, key)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>为什么用Reflect</strong><br>Reflect 就是反射，可以直接调用对象的基本方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">c</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">a</span>+<span class="variable language_">this</span>.<span class="property">b</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读：&#x27;</span>, target[key]);</span><br><span class="line">        <span class="keyword">return</span> target[key]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.<span class="property">c</span>; <span class="comment">//只输出， 读：&#x27;ab&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;读：&#x27;</span>, target[key]);</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.<span class="property">c</span>; </span><br><span class="line"><span class="comment">//读：&#x27;ab&#x27;</span></span><br><span class="line"><span class="comment">//读：&#x27;a&#x27;</span></span><br><span class="line"><span class="comment">//读：&#x27;b&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><blockquote>
<p>那么ref怎么监听原始值类型？</p>
</blockquote>
<p>利用了get 和 set 标记语法</p>
<ol>
<li>ref 接收任意数据</li>
<li>ref 返回RefImpl实例</li>
<li>利用get和set监听</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RefImpl</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_value</span> = value </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">dep</span> = <span class="literal">null</span> <span class="comment">//存放相关副作用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">value</span>() &#123;</span><br><span class="line">        <span class="comment">//收集依赖</span></span><br><span class="line">        <span class="keyword">if</span>(activeEffect)&#123;</span><br><span class="line">            <span class="comment">//在实例里以set集合形式存放依赖</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">dep</span> || (<span class="variable language_">this</span>.<span class="property">dep</span> = <span class="keyword">new</span> <span class="title class_">Set</span>())</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">dep</span>.<span class="title function_">add</span>(activeEffect)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_value</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">value</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_value</span> = newValue</span><br><span class="line">        <span class="comment">//触发依赖</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">dep</span>) &#123;</span><br><span class="line">            <span class="title function_">triggerEffects</span>(<span class="variable language_">this</span>.<span class="property">dep</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ref</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RefImpl</span>(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">triggerEffects</span>(<span class="params">dep</span>) &#123;</span><br><span class="line">    <span class="comment">//执行副作用, dep集合里装的是一个个ReactiveEffect 实例</span></span><br><span class="line">    dep.<span class="title function_">forEach</span>(<span class="function"><span class="params">_effect</span> =&gt;</span> &#123;</span><br><span class="line">        _effect.<span class="title function_">run</span>()</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> activeEffect = <span class="literal">null</span>;    <span class="comment">//当前执行的副作用实例</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试一下！</span></span><br><span class="line"><span class="keyword">let</span> myname = <span class="title function_">ref</span>(<span class="string">&#x27;blank&#x27;</span>)</span><br><span class="line"><span class="title function_">effect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应式：&#x27;</span>,myname.<span class="property">value</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    myname.<span class="property">value</span> = <span class="string">&#x27;lzy&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;修改完毕...&#x27;</span>)</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">响应式： blank</span></span><br><span class="line"><span class="comment">响应式： lzy</span></span><br><span class="line"><span class="comment">修改完毕...  </span></span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述effect函数和activeEffect都是简化后的，没有判断该副作用到底依赖了谁</p>
</blockquote>
<h1 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h1><h2 id="模板DSL"><a href="#模板DSL" class="headerlink" title="模板DSL"></a>模板DSL</h2><p>把template模板编译为render函数</p>
<p><img src="/2023/10/20/vue%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/compiler.png"></p>
<p>三大流程：</p>
<ol>
<li>通过 parse 方法进行解析，得到 AST（抽象语法树）</li>
<li>通过 transform 方法对 AST 进行转化，得到 JavaScript AST(大部分和AST相同)</li>
<li>通过 generate 方法根据 AST 生成 render 函数</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;m-title&quot;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>得到的AST如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> <span class="comment">// NodeTypes.ROOT</span></span><br><span class="line">  <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="comment">// NodeTypes.ELEMENT</span></span><br><span class="line">      <span class="attr">&quot;ns&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;div&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;tagType&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;props&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">,</span> <span class="comment">// NodeTypes.DIRECTIVE</span></span><br><span class="line">          <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;if&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;exp&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span> <span class="comment">// NodeTypes.SIMPLE_EXPRESSION</span></span><br><span class="line">            <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;isShow&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;isStatic&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;constType&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;loc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span> <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">12</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;end&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">18</span><span class="punctuation">,</span> <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">18</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;isShow&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;modifiers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;loc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span> <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">6</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;end&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">19</span><span class="punctuation">,</span> <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">19</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;v-if=&quot;</span>isShow<span class="string">&quot;&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;isSelfClosing&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="comment">// NodeTypes.ELEMENT</span></span><br><span class="line">          <span class="attr">&quot;ns&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;tag&quot;</span><span class="punctuation">:</span> <span class="string">&quot;p&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;tagType&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;props&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span> <span class="comment">// NodeTypes.ATTRIBUTE</span></span><br><span class="line">              <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;class&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="comment">// NodeTypes.TEXT</span></span><br><span class="line">                <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;title&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;loc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                  <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">12</span><span class="punctuation">,</span> <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">32</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                  <span class="attr">&quot;end&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">19</span><span class="punctuation">,</span> <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">39</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                  <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span>title<span class="string">&quot;&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">              <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;loc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span> <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">26</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;end&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">19</span><span class="punctuation">,</span> <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">39</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;class=&quot;</span>title<span class="string">&quot;&quot;</span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;isSelfClosing&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="comment">// NodeTypes.ELEMENT</span></span><br><span class="line">              <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hello world&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;loc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span> <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">40</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;end&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">31</span><span class="punctuation">,</span> <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">51</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hello world&quot;</span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;loc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">23</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;end&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">35</span><span class="punctuation">,</span> <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span> <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">55</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;p class=&quot;</span>title<span class="string">&quot;&gt;hello world&lt;/p&gt;&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;loc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span> <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">1</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;end&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">7</span><span class="punctuation">,</span> <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span> <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">64</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;div v-if=&quot;</span>isShow<span class="string">&quot;&gt;\n  &lt;p class=&quot;</span>title<span class="string">&quot;&gt;hello world&lt;/p&gt;  \n&lt;/div&gt;&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;helpers&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;components&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;directives&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hoists&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;imports&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cached&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;temps&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;loc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;end&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span> <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span> <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">69</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;\n&lt;div v-if=&quot;</span>isShow<span class="string">&quot;&gt;\n  &lt;p class=&quot;</span>title<span class="string">&quot;&gt;hello world&lt;/p&gt;  \n&lt;/div&gt;\n    &quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="v-model原理"><a href="#v-model原理" class="headerlink" title="v-model原理"></a>v-model原理</h1><p><strong>在原生元素上</strong></p>
<p>transform之后不会生成modelValue属性，但会生成onUpdate:modelValue回调函数和<code>vModelText</code>自定义指令</p>
<p><em>vModelText</em>指令在create钩子里监听input或change事件，来调用onUpdate:modelValue实现view流向vm; 在mount和beforeUpdate钩子里修改原生元素的value实现 model-&gt;view</p>
<p><strong>在组件上</strong></p>
<blockquote>
<p>const model &#x3D; defineModel() &#x2F;&#x2F; 返回一个ref</p>
</blockquote>
<p>首先在vue编译阶段</p>
<ol>
<li>解析出AST</li>
</ol>
<p>此时v-model当作一个属性名</p>
<ol start="2">
<li>调用transform函数处理AST</li>
</ol>
<p>transform函数内部调用不同的函数来解析各种指令。经过transform处理AST，表示该节点的对象的属性<code>codeGenNode</code> 从 undefined 变成一个对象</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b7798b241964ebbaf37025205950415~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=2036&h=962&s=258049&e=png&b=191919" alt="经过transform处理后AST"><br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dadead8a189549e3aa59fe4213f402df~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=2230&h=1424&s=384254&e=png&b=191919" alt="经过transform处理后AST"></p>
<p>两张图片看到经过处理后的codeGenNode对象内部。其中properties数组里每一个item都是有key和value。modelValue对应值，onUpdate:modelValue对应方法。</p>
<p>他们都用在后续步骤拼接成render函数。</p>
<blockquote>
<p>例如： transformModel、transformIf</p>
</blockquote>
<ol start="3">
<li>调用generate生成render函数</li>
</ol>
<p>把上面两个放入组件实例里</p>
<p>此时v-model最终被编译成了 <code>:modelValue</code>属性 和 <code>@update:modelValue</code>事件</p>
<p><a href="https://juejin.cn/post/7349936384512131107">参考🔗</a></p>
<h1 id="vue-工作流程"><a href="#vue-工作流程" class="headerlink" title="vue 工作流程"></a>vue 工作流程</h1><ol start="0">
<li>编译<ol>
<li>通过 parse 方法进行解析，得到 AST（抽象语法树）</li>
<li>通过 transform 方法对 AST 进行转化，得到 JavaScript AST(大部分和AST相同)</li>
<li>通过 generate 方法根据 JavaScript AST 生成 render 函数</li>
</ol>
</li>
<li>创建Vue实例</li>
<li>处理响应式数据</li>
<li>挂载阶段 <ol>
<li>调用render生成虚拟dom</li>
<li>生成真实dom并插入dom树指定位置</li>
<li>记录vnode为preVnode</li>
</ol>
</li>
</ol>
<p>至此初次渲染完成，如果改变了响应式数据导致需要更新视图则会进入更新阶段</p>
<ol start="4">
<li>更新阶段<ol>
<li>重新调用render生成新虚拟dom</li>
<li>调用patch方法<ol>
<li>利用diff算法比较新旧虚拟dom找到差异</li>
<li>根据差异更新真实dom</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h1><p>本质是一个对比算法，旧DOM更新为新DOM时怎么提高效率</p>
<p><strong>但是不是DOM更新了就会触发diff，而是DOM挂载、卸载或变换顺序才会触发diff</strong></p>
<p>原本两个树的完全的 diff 算法是一个时间复杂度为 O(n3) , Vue 进行了优化转换成 <strong>O(n)</strong> 复杂度的问题(只比较同级不考虑跨级问题)</p>
<p>节点比较：首先，Vue.js会比较新旧两个虚拟DOM树的根节点。如果根节点类型不同（例如，一个是div，另一个是p），那么Vue.js会直接替换旧的根节点及其所有子节点。如果根节点类型相同，那么Vue.js会保留该节点，并进一步比较其属性和子节点。<br>属性比较：Vue.js会比较同一节点的新旧属性，包括样式、类名、事件监听器等。如果新旧属性不同，那么Vue.js会更新这些属性。<br>子节点比较：如果节点类型相同并且属性也相同，那么Vue.js会进一步比较节点的子节点。这是一个递归过程，Vue.js会继续比较子节点的节点类型、属性和子节点，直到所有节点都被比较。<br>列表优化：在比较子节点时，Vue.js使用了一种称为keyed diffing的优化策略。通过给每个子节点分配一个唯一的key，Vue.js可以更快地找到新旧子节点列表中相同的节点，从而避免不必要的节点创建和删除操作。</p>
<h2 id="v-for-key-的意义"><a href="#v-for-key-的意义" class="headerlink" title="v-for key 的意义"></a>v-for key 的意义</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 原本 item = [&#123;id=1,title=&#x27;a&#x27;&#125;,&#123;id=2,title=&#x27;b&#x27;&#125;,&#123;id=3,title=&#x27;c&#x27;&#125;] --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&#x27;item in items&#x27;</span> <span class="attr">:key</span>=<span class="string">&#x27;item.id&#x27;</span>&gt;</span>&#123;&#123;item.title&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 修改后 item = [&#123;id=1, title=&#x27;a&#x27;&#125;,&#123;id=2, title=&#x27;b&#x27;&#125;,&#123;id=4, title=&#x27;d&#x27;&#125;] --&gt;</span></span><br></pre></td></tr></table></figure>

<p>此时diff算法开始工作，</p>
<p>首先，怎么比较？<code>isSameVNodeTyppe(n1: VNode, n2: VNode)</code> 方法通过比较n1和n2的<code>type</code>和<code>key</code>,如果都相等就说明没有变化，无需挂载卸载DOM元素</p>
<ul>
<li>type 是AST中的type，表示节点类型</li>
<li>key 则是 v-for 中的key</li>
</ul>
<p>上述情况可知，第三个li变了需要更新</p>
<h2 id="diff-算法五大步骤"><a href="#diff-算法五大步骤" class="headerlink" title="diff 算法五大步骤"></a>diff 算法五大步骤</h2><ol>
<li><p>sync from start：自前向后的对比</p>
<ul>
<li>把两组 dom 自前开始，相同的 dom 节点（vnode）完成对比处理</li>
</ul>
</li>
<li><p>sync from end：自后向前的对比</p>
<ul>
<li>把两组 dom 自后开始，相同的 dom 节点（vnode）完成对比处理</li>
</ul>
</li>
<li><p>common sequence + mount：新节点多于旧节点，需要挂载</p>
</li>
<li><p>common sequence + unmount：旧节点多于新节点，需要卸载</p>
</li>
<li><p>unknown sequence：乱序</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前者是一组旧DOM的key数组 后者是更新后新DOM的key数组</span></span><br><span class="line">oldChildren= [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">newChildren= [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1-经过阶段1： </span></span><br><span class="line"><span class="comment">(0,1,2,) 3,4</span></span><br><span class="line"><span class="comment">(0,1,2,)5,9,3,4</span></span><br><span class="line"><span class="comment">此时 i = 3 代表下标，oldChildrenEnd = 4, newChildrenEnd = 6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2- 经过阶段2：</span></span><br><span class="line"><span class="comment">(0,1,2,) (3,4)</span></span><br><span class="line"><span class="comment">(0,1,2,)5,6,(3,4)</span></span><br><span class="line"><span class="comment">此时 i = 3 , oldChildrenEnd = 2, newChildrenEnd = 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3- if (i &gt; oldChildrenEnd) 进入阶段3:</span></span><br><span class="line"><span class="comment">while(i&lt;=newChildrenEnd)&#123;</span></span><br><span class="line"><span class="comment">    patch(normalize(newChildren[i]))    //1. VNode挂载到DOM 2. 根据新旧VNode跟新DOM</span></span><br><span class="line"><span class="comment">    i++</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">此时 i = 5, newChildrenEnd = 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4- else if (i &gt; newChildrenEnd) </span></span><br><span class="line"><span class="comment">不进入阶段4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5- else </span></span><br><span class="line"><span class="comment">不进入阶段5</span></span><br></pre></td></tr></table></figure>

<p>阶段5是最复杂的，单独考虑一个进入阶段5的例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">oldChildren= [a, b, c, d, e, f, g]</span><br><span class="line">newChildren= [a, b, e, d, c, h, f, g]</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a b [c d e] f g</span></span><br><span class="line"><span class="comment">a b [e d c h] f g</span></span><br><span class="line"><span class="comment">5- 进入阶段5</span></span><br><span class="line"><span class="comment">根据newChildren 生成一个map （key, index） ,如下</span></span><br><span class="line"><span class="comment">map &#123;&lt;e, 2&gt;, &lt;d, 3&gt;, &lt;c, 4&gt;,&lt;h, 5&gt;&#125;</span></span><br><span class="line"><span class="comment">旧节点可能在newChildren里也可能不在，</span></span><br><span class="line"><span class="comment">    如果不在就卸载</span></span><br><span class="line"><span class="comment">    如果在 就根据map得到newIndex</span></span><br><span class="line"><span class="comment">        再对比newIndex和oldIndex 决定要不要移动</span></span><br><span class="line"><span class="comment">            如果要移动会生成一个最长递增子序列，便于移动</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>_update<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_update</span>(<span class="params">vnode</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> oldVnode = <span class="variable language_">this</span>.<span class="property">_vnode</span> <span class="comment">//保存旧虚拟dom树</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_vnode</span> = vnode<span class="comment">//赋值新虚拟dom树</span></span><br><span class="line">    <span class="comment">//对比新旧doom patch</span></span><br><span class="line">    <span class="title function_">patch</span>(oldVnode, <span class="variable language_">this</span>.<span class="property">_vnode</span>)</span><br><span class="line">    <span class="comment">//重新渲染render()  生成新真实dom树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>reactive</tag>
        <tag>ref</tag>
        <tag>AST</tag>
        <tag>diff</tag>
      </tags>
  </entry>
  <entry>
    <title>vue插槽的本质</title>
    <url>/2023/11/16/vue%E6%8F%92%E6%A7%BD%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
    <content><![CDATA[<blockquote>
<p>插槽本质就是函数</p>
</blockquote>
<p>父组件内通过<code>&lt;Child&gt;&lt;/Child&gt;</code> 方式是实例化子组件时如果使用了插槽，如下:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- App.vue内 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>默认插槽1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>默认插槽2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">namedSlot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>具名插槽<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">scopeSlot</span>=<span class="string">&quot;&#123; data &#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; data &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Child</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>则插槽内容是一个对象，对象里面包含了 <code>default</code> <code>namedSlot</code> <code>scopeSlot</code> 这三个函数</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Child.vue内 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;namedSlot&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;scopeSlot&quot;</span> <span class="attr">:data</span>=<span class="string">&quot;&#123;abc: 123&#125;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong><code>&lt;slot&gt;&lt;/slot&gt;</code>其实是调用那三个函数</strong></p>
<p><code>scopeSlot( &#123;data: &#123;...&#125;&#125; )</code> 作用域插槽就是传了参数的函数而已</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>父组件会把若干函数传递给子组件</li>
<li>子组件拿到函数并调用，返回VNode数组</li>
<li>子组件把VNode数组挂载到对应的<code>&lt;slot&gt;&lt;/slot&gt;</code>的位置</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;h&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params">props, &#123;slots&#125;</span>) &#123;</span><br><span class="line">        <span class="comment">//对象里有三个函数，函数名是插槽名，参数是作用域插槽的参数</span></span><br><span class="line">        <span class="keyword">const</span> defaultVNodeList = slots.<span class="property">default</span> &amp;&amp; slots.<span class="title function_">default</span>()</span><br><span class="line">        <span class="keyword">const</span> namedVNodeList = slots.<span class="property">namedSlot</span> &amp;&amp; slots.<span class="title function_">namedSlot</span>()</span><br><span class="line">        <span class="keyword">const</span> scopeVNodeList = slots.<span class="property">scopeSlot</span> &amp;&amp; slots.<span class="title function_">scopeSlot</span>(&#123;<span class="attr">data</span>: &#123;<span class="attr">name</span>:<span class="string">&#x27;scopeSlot&#x27;</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>,<span class="literal">null</span>,[...defaultVNodeList, ...namedVNodeList, ...scopeVNodeList])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>插槽</tag>
      </tags>
  </entry>
  <entry>
    <title>【小玩意】--3d卡片效果</title>
    <url>/2023/10/24/%E3%80%90%E5%B0%8F%E7%8E%A9%E6%84%8F%E3%80%91-3d%E5%8D%A1%E7%89%87%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>模仿steam卡牌效果，鼠标悬浮会把卡牌按压进去的效果</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        * &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">perspective</span>: <span class="number">2000px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">perspective-origin</span>: center;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">transform-style</span>: preserve-<span class="number">3</span>d;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding-left</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">2000px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/* width: 950px;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">            height: 600px; */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">box-sizing</span>: border-box;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">./asset/1.jpg</span>);</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">            <span class="comment">/* transform-origin: center; */</span></span></span><br><span class="line"><span class="language-css">            <span class="comment">/* margin: 100px; */</span></span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.blowUp</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">transition</span>: scale .<span class="number">4s</span> ease;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.blowUp</span><span class="selector-pseudo">:hover</span> &#123;</span></span><br><span class="line"><span class="language-css">            scale: <span class="number">1.1</span>;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>asdasdsad<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container blowUp shadowUp&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> div = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.container&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        div.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> rect = div.<span class="title function_">getBoundingClientRect</span>()</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> centerX = rect.<span class="property">left</span> <span class="comment">//相对于视口左边的坐标</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> centerY = rect.<span class="property">top</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//鼠标相对于中心的坐标 = 鼠标相对视口坐标-盒子相对视口坐标-盒子一半宽</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> cursorX = e.<span class="property">clientX</span> - centerX - rect.<span class="property">width</span> / <span class="number">2</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> cursorY = e.<span class="property">clientY</span> - centerY - rect.<span class="property">height</span> / <span class="number">2</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(cursorX, cursorY);</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//修改转换中心</span></span></span><br><span class="line"><span class="language-javascript">            div.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`rotate3d(<span class="subst">$&#123;cursorY&#125;</span>, <span class="subst">$&#123;-cursorX&#125;</span>, 0, -20deg)`</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> <span class="title class_">YreferToBox</span> = e.<span class="property">clientY</span> - centerY</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//亮度在0.8-1.2之间， 根据鼠标相对盒子Y坐标变化</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">let</span> light = -(<span class="number">1.2</span> - <span class="number">0.8</span>) / div.<span class="property">offsetHeight</span> * <span class="title class_">YreferToBox</span> + <span class="number">1.2</span></span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(light);</span></span><br><span class="line"><span class="language-javascript">            div.<span class="property">style</span>.<span class="property">filter</span> = <span class="string">`brightness(<span class="subst">$&#123;light&#125;</span>) drop-shadow(0 0 0.75rem )`</span></span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">        div.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseout&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            div.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`rotate3d(0,0,0,0)`</span></span></span><br><span class="line"><span class="language-javascript">            div.<span class="property">style</span>.<span class="property">filter</span> = <span class="string">`brightness(1)`</span></span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>小玩意</category>
      </categories>
      <tags>
        <tag>3d</tag>
      </tags>
  </entry>
  <entry>
    <title>【小玩意】--伪数组迭代器</title>
    <url>/2023/10/24/%E3%80%90%E5%B0%8F%E7%8E%A9%E6%84%8F%E3%80%91-%E4%BC%AA%E6%95%B0%E7%BB%84%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<p>对象是没有迭代器的，所以对于伪数组有迭代器需求的情况我可以手动在Object原型上定义一个迭代器，用于迭代伪数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fakeArr = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="number">99</span>: <span class="string">&#x27;zzz&#x27;</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>* () &#123;</span><br><span class="line">    <span class="comment">// for (i in range(0, this.length)) &#123;</span></span><br><span class="line">    <span class="comment">//     yield this[i]</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">let</span> regExpNum = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="regexp">/[0-9]+/</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> keys) &#123;</span><br><span class="line">        <span class="keyword">if</span> (regExpNum.<span class="title function_">test</span>(key))</span><br><span class="line">            <span class="keyword">yield</span> <span class="variable language_">this</span>[key]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> fakeArr) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item); <span class="comment">//TypeError: fakeArr is not iterable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>小玩意</category>
      </categories>
      <tags>
        <tag>迭代器</tag>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title>【小玩意】-省略文字显示-vue插件</title>
    <url>/2023/10/30/%E3%80%90%E5%B0%8F%E7%8E%A9%E6%84%8F%E3%80%91-%E7%9C%81%E7%95%A5%E6%96%87%E5%AD%97%E6%98%BE%E7%A4%BA-vue%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<hr>
<h2 id="title-vue插件-显示省略号内容date-2023-09-25-15-05-38tags"><a href="#title-vue插件-显示省略号内容date-2023-09-25-15-05-38tags" class="headerlink" title="title: vue插件-显示省略号内容date: 2023-09-25 15:05:38tags:"></a>title: vue插件-显示省略号内容<br>date: 2023-09-25 15:05:38<br>tags:</h2><ol>
<li>依赖<code>element-ui/elementUI-plus</code></li>
<li>自定义指令：<code>v-abbreviation</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ElementUI</span> <span class="keyword">from</span> <span class="string">&quot;element-ui&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">install</span>(<span class="params">Vue</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> mt = <span class="literal">null</span>; <span class="comment">//弹框实例</span></span><br><span class="line">        <span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;abbreviation&#x27;</span>, &#123;</span><br><span class="line">            <span class="title function_">inserted</span>(<span class="params">element, binding</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="title class_">Popover1</span> = <span class="title class_">Vue</span>.<span class="title function_">extend</span>(<span class="title class_">ElementUI</span>.<span class="property">Popover</span>)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!mt) &#123; <span class="comment">//没有实例就创建</span></span><br><span class="line">                    <span class="keyword">const</span> vmtest = <span class="keyword">new</span> <span class="title class_">Popover1</span>()</span><br><span class="line">                    mt = vmtest</span><br><span class="line">                    mt.<span class="property">trigger</span> = <span class="string">&quot;hover&quot;</span></span><br><span class="line">                    mt.<span class="property">placement</span> = <span class="string">&#x27;bottom&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">                element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mouseover&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;listen hover&#x27;</span>, element);</span><br><span class="line">                    <span class="keyword">if</span> (element &amp;&amp; element.<span class="property">scrollWidth</span> &gt; element.<span class="property">offsetWidth</span>) &#123;</span><br><span class="line">                        mt.<span class="property">reference</span> = element</span><br><span class="line">                        mt.<span class="property">referenceElm</span> = element</span><br><span class="line">                        mt.<span class="property">content</span> = element.<span class="property">innerText</span></span><br><span class="line">                        mt.$mount()</span><br><span class="line">                        <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(mt.<span class="property">$el</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现已发布到npm： <code>npm i Vabbreviation</code> 安装</p>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>【综合】html+css基础</title>
    <url>/2024/03/05/%E3%80%90%E7%BB%BC%E5%90%88%E3%80%91html-css%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="1-行级元素和块级元素"><a href="#1-行级元素和块级元素" class="headerlink" title="1. 行级元素和块级元素"></a>1. 行级元素和块级元素</h1><h2 id="行级元素"><a href="#行级元素" class="headerlink" title="行级元素"></a>行级元素</h2><ol>
<li>不会独占一行</li>
<li>不能包括块级元素</li>
<li><strong>宽高由内容决定，无法设置</strong></li>
<li><strong>上下margin和上下padding 不起作用</strong></li>
</ol>
<blockquote>
<p>特殊<code>&lt;a&gt;</code>， 它的祖先元素可以放块级元素，那么它也可以放块级元素</p>
</blockquote>
<h2 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h2><ol>
<li>独占一行</li>
<li>可以包含块级和行级元素<ul>
<li>p标签除外，不可以包括块级元素</li>
</ul>
</li>
</ol>
<h2 id="行内块"><a href="#行内块" class="headerlink" title="行内块"></a>行内块</h2><ol>
<li>不独占一行</li>
<li>可以设置width、height、padding、margin</li>
<li>宽高默认由内容决定</li>
</ol>
<blockquote>
<p>常见包括: <code>&lt;input&gt;``&lt;img&gt;``&lt;td&gt;``&lt;hr&gt;</code></p>
</blockquote>
<blockquote>
<p>行内块元素之间有空隙，怎么解决？</p>
<ol>
<li>移除代码标签之间的空格</li>
<li>负margin</li>
<li><code>font-size: 0</code></li>
<li><code>letter-spacing: - px </code></li>
<li><code>word-spacing: - px</code></li>
</ol>
</blockquote>
<h1 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h1><ul>
<li>行内+行内块<ul>
<li><code>vertical-align: middle</code> 可以对其图片和表格单元内容</li>
<li><code>line-height</code>  单行文本</li>
</ul>
</li>
<li>flex<ul>
<li><code>align-items: center</code></li>
<li><code>align-self: center</code></li>
</ul>
</li>
<li>grid<ul>
<li><code>align-items: center</code></li>
<li><code>align-self: center</code></li>
</ul>
</li>
<li>定位+translate</li>
</ul>
<h1 id="HTML5-新特性"><a href="#HTML5-新特性" class="headerlink" title="HTML5 新特性"></a>HTML5 新特性</h1><p>一、html5新特性之用于绘画的canvas元素<br>二、html5新特性之更加丰富强大的表单<br>三、html5新特性之用于媒介的video和audio元素<br>四、html5新特性之html5地理定位<br>五、html5新特性之html5拖放<br>六：html5新特性之html5 Web存储<br>七、html5新特性之html5应用程序缓存<br>八、html5新特性之html5 Web Workers<br>九、html5新特性之html5服务器发送事件<br>十、html5新特性之html5 WebSocket</p>
<h1 id="HTML-语义化标签"><a href="#HTML-语义化标签" class="headerlink" title="HTML 语义化标签"></a>HTML 语义化标签</h1><ol>
<li>article</li>
<li>section</li>
<li>aside</li>
<li>hgroup</li>
<li>header - main - footer</li>
<li>nav</li>
<li>time</li>
<li>mark</li>
<li>figure - figcation</li>
</ol>
<ul>
<li>figure代表一段独立的内容</li>
<li>figcation 定义说明内容</li>
</ul>
<ol start="10">
<li>menu</li>
</ol>
<ul>
<li>与ul没有区别</li>
<li><code>&lt;menu-item&gt;</code> 已经被完全弃用</li>
</ul>
<ol start="11">
<li>details - summary</li>
</ol>
<ul>
<li>展开和折叠</li>
</ul>
<ol start="12">
<li>fieldset - legend</li>
</ol>
<ul>
<li><code>&lt;fieldset&gt;</code> 元素将一个 HTML 表单的一部分组成一组，内置了一个 <code>&lt;legend&gt;</code> 元素作为 fieldset 的标题</li>
</ul>
<p>dl - dt - dd</p>
<ul>
<li>包含术语定义以及描述的列表<br>track</li>
<li>可以当作媒体元素的子元素来使用。它允许指定时序文本字幕（或者基于时间的数据），例如自动处理字幕</li>
</ul>
]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>【综合】js基础</title>
    <url>/2024/03/04/%E3%80%90%E7%BB%BC%E5%90%88%E3%80%91js%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="1-隐式类型转换"><a href="#1-隐式类型转换" class="headerlink" title="1. 隐式类型转换"></a>1. 隐式类型转换</h1><p><img src="/2024/03/04/%E3%80%90%E7%BB%BC%E5%90%88%E3%80%91js%E5%9F%BA%E7%A1%80/jsautotranslate.png" alt="img"></p>
<ul>
<li>P 表示toPrimitive<ul>
<li>先调用 <code>valueOf</code> 若返回不是原始类型<ul>
<li>原始类型的包装类型调用<code>valueOf</code>会返回原始类型(例如String，BigInt)</li>
</ul>
</li>
<li>再调用 <code>toString</code> 若返回不是原始类型</li>
<li>则报错</li>
</ul>
</li>
</ul>
<blockquote>
<p>所有比较都有转化为数字类型的趋势</p>
</blockquote>
<h1 id="2-实现函数缓存"><a href="#2-实现函数缓存" class="headerlink" title="2. 实现函数缓存"></a>2. 实现函数缓存</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> memoize = <span class="keyword">function</span> (<span class="params">fun, content</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> cache = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>)</span><br><span class="line">	content = content || <span class="variable language_">this</span> </span><br><span class="line">	<span class="keyword">return</span> <span class="function">(<span class="params">...key</span>)=&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(!cache[key]) </span><br><span class="line">			cache[key] = fun.<span class="title function_">apply</span>(content, key)</span><br><span class="line">		<span class="keyword">return</span> cache[key]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-requestAnimationFrame"><a href="#3-requestAnimationFrame" class="headerlink" title="3. requestAnimationFrame"></a>3. requestAnimationFrame</h1><p>window.requestAnimationFrame(callback)</p>
<ul>
<li>作用： 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画</li>
<li>参数： callback回调函数，第一个参数是回调函数被触发时的时间戳。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;some-element-you-want-to-animate&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> start, previousTimeStamp;</span><br><span class="line"><span class="keyword">let</span> done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">step</span>(<span class="params">timestamp</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (start === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    start = timestamp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> elapsed = timestamp - start;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (previousTimeStamp !== timestamp) &#123;</span><br><span class="line">    <span class="comment">// 这里使用 Math.min() 确保元素在恰好位于 200px 时停止运动</span></span><br><span class="line">    <span class="keyword">const</span> count = <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="number">0.1</span> * elapsed, <span class="number">200</span>);</span><br><span class="line">    element.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`translateX(<span class="subst">$&#123;count&#125;</span>px)`</span>;</span><br><span class="line">    <span class="keyword">if</span> (count === <span class="number">200</span>) done = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (elapsed &lt; <span class="number">2000</span>) &#123;</span><br><span class="line">    <span class="comment">// 2 秒之后停止动画</span></span><br><span class="line">    previousTimeStamp = timestamp;</span><br><span class="line">    <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">      <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(step);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(step);</span><br></pre></td></tr></table></figure>


<h1 id="4-严格模式"><a href="#4-严格模式" class="headerlink" title="4. 严格模式"></a>4. 严格模式</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>禁止使用关键字声明变量</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(x)&#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">g</span>(<span class="params"></span>) &#123;&#125; <span class="comment">// 相当于没有用关键字声明变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g) <span class="comment">//</span></span><br></pre></td></tr></table></figure>

<h1 id="5-this指向"><a href="#5-this指向" class="headerlink" title="5. this指向"></a>5. this指向</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(obj.<span class="property">fn2</span>)(); <span class="comment">// 函数内this指向obj</span></span><br><span class="line">(obj.<span class="property">fn2</span> = obj.<span class="property">fn2</span>)(); <span class="comment">//函数内this指向全局作用域</span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取url参数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> searchUrl = link.<span class="property">search</span>.<span class="title function_">substr</span>(<span class="number">1</span>); <span class="comment">// 获取问号后面字符串</span></span><br><span class="line"><span class="keyword">let</span> hashUrl = link.<span class="property">hash</span>.<span class="title function_">substr</span>(<span class="number">1</span>); <span class="comment">// 获取#后面的值</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable constant_">URL</span> = <span class="string">&quot;http://www.baidu.com?name=elephant&amp;age=25&amp;sex=male&amp;num=100&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">queryURLParams</span>(<span class="params">URL</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="variable constant_">URL</span>.<span class="title function_">split</span>(<span class="string">&quot;?&quot;</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">const</span> urlSearchParams = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(url);</span><br><span class="line">  <span class="keyword">const</span> params = <span class="title class_">Object</span>.<span class="title function_">fromEntries</span>(urlSearchParams.<span class="title function_">entries</span>());</span><br><span class="line">  <span class="keyword">return</span> params</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="6-闭包"><a href="#6-闭包" class="headerlink" title="6. 闭包"></a>6. 闭包</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol>
<li>模拟私有变量</li>
<li>阻止变量被回收</li>
</ol>
<h2 id="闭包导致的内存泄露"><a href="#闭包导致的内存泄露" class="headerlink" title="闭包导致的内存泄露"></a>闭包导致的内存泄露</h2><ol>
<li><p>持有不需要的函数引用，导致函数关联词法环境无法销毁</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useArr</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = [<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">return</span> <span class="function">()=&gt;</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arr = <span class="title function_">useArr</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>当多个函数共享词法环境，导致出现无法触及也无法回收的内存</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useArr</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = [<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    arr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">()=&gt;</span> [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arr = <span class="title function_">useArr</span>();</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><a href="/2023/10/15/%E5%87%A0%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F">🔗几种继承方式</a></p>
<h1 id="7-class"><a href="#7-class" class="headerlink" title="7. class"></a>7. class</h1><p>class 是ES6的新的实现继承的方式，他的本质还是寄生式组合继承</p>
<p>特点：</p>
<ol>
<li>class 必须用new调用</li>
<li>class 没有变量提升</li>
</ol>
]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>【综合】工程化</title>
    <url>/2024/05/10/%E3%80%90%E7%BB%BC%E5%90%88%E3%80%91%E5%B7%A5%E7%A8%8B%E5%8C%96/</url>
    <content><![CDATA[<h1 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h1><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p><a href="https://juejin.cn/post/7286362110211489855?searchId=2024050820041652E4E88131751129A528">pnpm、npm、yarn 包管理工具『优劣对比』及『环境迁移』 - 掘金 (juejin.cn)</a></p>
<p>v2 早期<strong>递归依赖</strong>，导致重复安装问题</p>
<p>v3 <strong>扁平化</strong>解决递归依赖， <strong>扁平化依赖算法耗时长</strong>，下载需要更长时间</p>
<ul>
<li>因为如果两个模块依赖同一个模块但版本不同，npm v3会尝试将其中一个版本的模块安装在顶层，另一个版本的模块安装在依赖它的模块下面</li>
</ul>
<p>v5 <strong>package-lock.json</strong>解决扁平化耗时长问题：</p>
<ol>
<li>锁定包精确版本</li>
<li>锁定下载地址</li>
<li>锁定包直接依赖关系</li>
</ol>
<blockquote>
<p>package-lock.json 的作用</p>
<ol>
<li>记录项目所有依赖的精确版本号</li>
<li>提供生成确切的依赖树，可视化</li>
<li>优化依赖安装过程，跳过重复依赖</li>
<li>防止依赖意外更新</li>
</ol>
</blockquote>
<h2 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h2><ol>
<li>采用了<strong>硬链接</strong>来直接指向依赖磁盘地址，避免重复安装依赖</li>
<li>默认支持monorepo 多项目管理</li>
<li>替代nvm <code>pnpm env use --global [version]</code></li>
</ol>
]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>工程化</tag>
      </tags>
  </entry>
  <entry>
    <title>【综合】服务端基础</title>
    <url>/2024/03/05/%E3%80%90%E7%BB%BC%E5%90%88%E3%80%91%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="1-http-状态码"><a href="#1-http-状态码" class="headerlink" title="1. http 状态码"></a>1. http 状态码</h1><ul>
<li>1XX   提示信息<ul>
<li>101：允许切换协议</li>
</ul>
</li>
<li>2XX<ul>
<li><strong>200</strong>： OK</li>
<li>204： Not Content， 服务器无返回内容</li>
<li>206： Partial Content, 无响应体</li>
</ul>
</li>
<li>3XX<ul>
<li>301： Moved Permanently，永久重定向</li>
<li>302： Found，临时重定向</li>
<li><strong>304</strong>： Not Modified， 浏览器可以使用本地缓存</li>
</ul>
</li>
<li>4XX<ul>
<li><strong>400</strong>： Bad Request，请求报文错误</li>
<li><strong>401</strong>： Unauthorized， 未授权</li>
<li><strong>403</strong>： Forbidden， 禁止访问</li>
<li><strong>404</strong>： Not Found， 找不到资源</li>
<li>405： Method Not Allowed， 请求方法不允许，可以用OPTIONS预检请求查看服务器允许的请求</li>
</ul>
</li>
<li>5XX<ul>
<li><strong>500</strong>： Internal Server Error，</li>
<li>501：Not Implement, 客户端请求不支持</li>
<li><strong>502</strong>： Bad Gateway， 服务器作为网关或代理返回的错误</li>
<li>503： Service Unavilable, 服务器在忙</li>
</ul>
</li>
</ul>
<h1 id="2-CDN"><a href="#2-CDN" class="headerlink" title="2. CDN"></a>2. CDN</h1><p><img src="/2024/03/05/%E3%80%90%E7%BB%BC%E5%90%88%E3%80%91%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%9F%BA%E7%A1%80/CDN.jpg" alt="CDN"></p>
<p>CDN的作用：</p>
<ol>
<li>加速资源</li>
<li>负载均衡</li>
</ol>
<h1 id="3-Content-type"><a href="#3-Content-type" class="headerlink" title="3. Content-type"></a>3. Content-type</h1><p><a href="/2023/12/01/content-type%E4%B8%80%E4%BA%9B%E7%96%91%E6%83%91">详见🔗content-type</a></p>
<h1 id="4-http"><a href="#4-http" class="headerlink" title="4. http"></a>4. http</h1><p><a href="/2023/10/16/http%E8%AF%A6%E8%A7%A3">详见🔗http详解</a></p>
<h1 id="5-cookie"><a href="#5-cookie" class="headerlink" title="5. cookie"></a>5. cookie</h1><ol>
<li>默认跨域不会发送cookie<br>但是可以通过 <code>withCredentials=true</code> 设置</li>
<li>expire设置为0，代表仅一次会话有效</li>
<li>一个cookie大小4KB</li>
<li><code>secure=true</code>表示只有https才附带cookie</li>
<li><code>same-site</code><ol>
<li><code>strict</code> : refer未其他域不发cookie</li>
<li><code>Lax</code>: get请求可以发，其他不发</li>
<li><code>None</code>：无限制</li>
</ol>
</li>
<li><code>http-only</code> 表示此cookie对js不可见<ol>
<li>document.cookie无法获取，可防止xss攻击。</li>
</ol>
</li>
</ol>
<h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><p>jwt常用于身份认证和信息交换。jwt生成的token由header+payload+signature组成。可以加密信息并防止篡改。</p>
<p>为什么要使用token？</p>
<p>以前用cookie+session模式，cookie存放sessionID，服务器拿到sessionID在数据库里查找对应用户的登录信息。这样做的缺点是：</p>
<ol>
<li>用户信息存在服务端，增加服务器负担。</li>
<li>cookie历史包袱重，空间大小只有4KB，携带cookie的规则复杂，跨站不携带cookie。不灵活。容易遭受csrf、xss攻击</li>
<li>在分布式服务架构上，一个服务器上的session不方便与其他服务器共享</li>
</ol>
<p>而token</p>
<ol>
<li>存储在localstorage里相对安全。</li>
<li>使用更加灵活</li>
<li>便于在微前端中传输用户信息。</li>
</ol>
<h1 id="history路由模式【pushed】"><a href="#history路由模式【pushed】" class="headerlink" title="history路由模式【pushed】"></a>history路由模式【pushed】</h1><p>vue利用history.pushState来管理路由状态。当刷新页面时，浏览器把地址栏当作请求地址向服务器发起请求，服务器没有对应路由则出现404错误</p>
<p><strong>解决：</strong></p>
<ol>
<li>修改为hash模式，hash值是指以＃开头的一串，是不会发送给服务器的</li>
<li>设置nginx和express所有未匹配到的路由都返回index.html。这样，当刷新页面时，服务器将始终返回<code>index.html</code>，然后由Vue Router接管路由处理</li>
</ol>
]]></content>
      <categories>
        <category>综合</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>服务器</tag>
        <tag>服务端</tag>
      </tags>
  </entry>
  <entry>
    <title>一些枚举对象的方法</title>
    <url>/2023/10/13/%E4%B8%80%E4%BA%9B%E6%9E%9A%E4%B8%BE%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>方法名</th>
<th>包含原型链上的</th>
<th>可枚举的</th>
</tr>
</thead>
<tbody><tr>
<td>Object.keys()</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>for-in</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>Object.getOwnPropertyName()</td>
<td>否</td>
<td>可或不可</td>
</tr>
</tbody></table>
<span id="more"></span>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">d</span> = <span class="string">&#x27;ddd&#x27;</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>(&#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="string">&#x27;a1&#x27;</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="string">&#x27;b2&#x27;</span>,</span><br><span class="line">    <span class="attr">c</span>: <span class="string">&#x27;c3&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj,<span class="string">&#x27;e&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;eeee&#x27;</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span> <span class="comment">//不可被枚举</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)) <span class="comment">//[ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj))<span class="comment">//[ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;e&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    arr.<span class="title function_">push</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr)<span class="comment">//[ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不包含原型上的，可枚举的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">values</span>(obj)) <span class="comment">//[ &#x27;a1&#x27;, &#x27;b2&#x27;, &#x27;c3&#x27; ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">entries</span>(obj))<span class="comment">//[ [ &#x27;a&#x27;, &#x27;a1&#x27; ], [ &#x27;b&#x27;, &#x27;b2&#x27; ], [ &#x27;c&#x27;, &#x27;c3&#x27; ] ]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js红宝书</category>
      </categories>
      <tags>
        <tag>枚举</tag>
        <tag>Object.keys()</tag>
        <tag>for-in</tag>
        <tag>Object.getOwnPropertyNames()</tag>
        <tag>Object.values()</tag>
        <tag>Object.entries()</tag>
      </tags>
  </entry>
  <entry>
    <title>事件循环</title>
    <url>/2023/10/15/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<h1 id="浏览器进程模型"><a href="#浏览器进程模型" class="headerlink" title="浏览器进程模型"></a>浏览器进程模型</h1><p>一个进程有很多线程，线程是干活的人，所以一个进程至少一个线程</p>
<p>浏览器极其复杂，拥有多个进程</p>
<ol>
<li><p>浏览器进程</p>
<p>负责：界面显示、交互、子进程管理</p>
</li>
<li><p>网络进程</p>
</li>
<li><p><strong>渲染进程</strong></p>
<p>会开启一个<strong>渲染主线程</strong>，负责执行<code>html\css\js</code>代码</p>
<p>默认每个标签开启一个新渲染进程</p>
</li>
</ol>
<span id="more"></span>

<h2 id="渲染主线程"><a href="#渲染主线程" class="headerlink" title="渲染主线程"></a>渲染主线程</h2><p>事件循环就发生在其中</p>
<ul>
<li>解析html</li>
<li>解析css</li>
<li>计算样式</li>
<li>布局</li>
<li>图层处理</li>
<li>60帧</li>
<li><strong>执行全局js代码</strong></li>
<li>执行事件处理函数</li>
<li>执行计时器回调</li>
</ul>
<p><img src="/2023/10/15/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/image-20231009142935167.png" alt="image-20231009142935167"></p>
<p>渲染主线程任务如此繁重，要怎么调度任务呢？</p>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><blockquote>
<p>单线程是异步产生的原因，事件循环是异步的实现方式</p>
</blockquote>
<ol>
<li>一开始，渲染主线程进入一个死循环</li>
<li>每次循环检查消息队列中有没有任务，有任务渲染主线程就取走执行</li>
<li>其他所有线程可以随时向消息队列添加任务在末尾</li>
</ol>
<p>但是遇到异步任务怎么办？</p>
<blockquote>
<p>如何理解js异步？</p>
<p>答： js是单线程语言，因为他运行在渲染主线程中，而渲染主线程只有一个，且承载着诸多任务，如果采用同步，则其他任务被阻塞。</p>
<p>所以js采用异步来避免这种问题。遇到异步任务时，自己结束任务转而执行后续任务，交给其他线程去处理。其他线程完成异步任务时，把回调函数包装成任务加入到消息队列末尾。</p>
</blockquote>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>任务没有优先级，但是消息队列有优先级</p>
<p>任务有类型之分，同种一任务必须在同一消息队列</p>
<p>浏览器必须准备一个<strong>微队列</strong>，微队列优先级最高</p>
<p>​    						     交互队列， 优先级高 ——（事件处理）</p>
<p>​								  延时队列， 优先级中 —— （计时器）</p>
<p><img src="/2023/10/15/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/image-20231009175116866.png" alt="image-20231009175116866"></p>
<p>##js计时器精准吗？</p>
<p>不精准，因为：1. js实际调用操作系统的时间。 2. 受到事件循环影响，计时器只能在渲染主线程空闲时运行</p>
<h1 id="在浏览器上的事件循环"><a href="#在浏览器上的事件循环" class="headerlink" title="在浏览器上的事件循环"></a>在浏览器上的事件循环</h1><p><img src="https://pic2.zhimg.com/80/v2-7a44f0983315f8dbb9861e6f017dd6cd_720w.webp" alt="线程"></p>
<p>微任务一般比宏任务先执行，并且微任务队列只有一个，宏任务队列可能有多个。另外我们常见的点击和键盘等事件也属于宏任务</p>
<ul>
<li><p>常见宏任务</p>
<ul>
<li>js主进程</li>
<li>setTimeout()</li>
<li>setInterval()</li>
<li>setImmediate()</li>
<li>requestAnimationFrame()</li>
<li>postMessage()</li>
</ul>
</li>
<li><p>常见微任务</p>
<ul>
<li>promise.then .catch .finally</li>
<li>async&#x2F;await</li>
<li>Generator函数</li>
<li>new MutationObserver()</li>
<li>process.nextTick()</li>
</ul>
</li>
</ul>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="1-await"><a href="#1-await" class="headerlink" title="1. await"></a>1. await</h2><ul>
<li><code>await 123</code>： 转化为 <code>await Promise.resolve(123)</code></li>
<li>await express ： express一旦状态转为fulfilled，然后执行完当前代码，再把等待的代码代码推到微队列</li>
<li>await syncExpress： &#x3D;&#x3D;&#x3D; 没有await的情况</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asy1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">asy2</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">asy2 = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">asy3 = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line"><span class="title function_">asy1</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>);</span><br><span class="line"><span class="title function_">asy3</span>();</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">output： 1，6， </span><br><span class="line">微任务： say2完成，5</span><br><span class="line">宏任务：定时器，</span><br><span class="line">===至此全局js执行完成===</span><br><span class="line">...</span><br><span class="line">===定时器函数到时===</span><br><span class="line">output：1，6，</span><br><span class="line">微任务：5，2，</span><br><span class="line">宏任务：定时器</span><br><span class="line">===asy1完成===</span><br><span class="line">output：1，6，5，2，4, 3</span><br></pre></td></tr></table></figure>

<h2 id="2-return-Promise-resolve"><a href="#2-return-Promise-resolve" class="headerlink" title="2. return Promise.resolve()"></a>2. return Promise.resolve()</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">4</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;&#125;)</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 开始</span><br><span class="line">微队列:   </span><br><span class="line">()=&gt; &#123;                           ;     1</span><br><span class="line">    console.log(0)</span><br><span class="line">    return Promise.resolve(4)//</span><br><span class="line">&#125;                       </span><br><span class="line">// ===以上同步代码执行完成===</span><br><span class="line">// ===开始执行第一个微队列任务===</span><br><span class="line">output:</span><br><span class="line">0</span><br><span class="line">微队列:</span><br><span class="line">1      .then(()=&gt; 函数完成)</span><br><span class="line">// ======</span><br><span class="line">output:</span><br><span class="line">0 1 </span><br><span class="line">微队列:</span><br><span class="line">.then(()=&gt; 函数完成) 2</span><br><span class="line">// ======</span><br><span class="line">output:</span><br><span class="line">0 1 </span><br><span class="line">微队列:</span><br><span class="line">2 函数完成return出去</span><br><span class="line">// ======</span><br><span class="line">output:</span><br><span class="line">0 1 2</span><br><span class="line">微队列:</span><br><span class="line">函数完成return出去 3</span><br><span class="line">// ======</span><br><span class="line">output:</span><br><span class="line">0 1 2</span><br><span class="line">微队列:</span><br><span class="line">3 4</span><br><span class="line">// ===最后输出===</span><br><span class="line">0 1 2 3 4</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">()=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">4</span>)<span class="comment">//断点，执行到这一行时，相当于</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    把 .then(()=&gt;此函数完成) 加入微队列</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;.<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br></pre></td></tr></table></figure>
<p>另外：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果</span><br><span class="line">return Promise.resolve(4).then(res=&gt;console.log(res))</span><br><span class="line">则把 then(()=&gt;此函数完成) 4 依次加入微队列</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>事件循环</tag>
      </tags>
  </entry>
  <entry>
    <title>几种postMessage</title>
    <url>/2023/12/24/%E5%87%A0%E7%A7%8DpostMessage/</url>
    <content><![CDATA[<p>在初见postMessage的时候被其强大的功能震撼到了，可是自己用起来却总是莫名报错</p>
<p>原来是我把几种postMessage搞混了，现在来和我一起捋清楚吧</p>
<span id="more"></span>

<p>首先三种都是<strong>宏任务</strong></p>
<h1 id="BroadcastChannel-postMessage"><a href="#BroadcastChannel-postMessage" class="headerlink" title="BroadcastChannel.postMessage"></a>BroadcastChannel.postMessage</h1><blockquote>
<p>适用于在<strong>同一域名</strong>下所有页面之间的广播通信</p>
<ol>
<li>标签页间共享</li>
</ol>
</blockquote>
<p>通过BroadcastChannel构造函数生成的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bc = <span class="keyword">new</span> <span class="title class_">BroadcastChannel</span>(<span class="string">&#x27;channel_name&#x27;</span>)</span><br><span class="line">bc.<span class="property">name</span> <span class="comment">// bcName</span></span><br></pre></td></tr></table></figure>
<p>有两个实例方法：</p>
<ol>
<li><code>close()</code></li>
<li><code>postMessage(message)</code> 向同名频道广播(很像websocket)</li>
</ol>
<p>事件：<br><code>onmessage</code> 和 <code>addEventListener(&#39;message&#39;,()=&gt;&#123;&#125;)</code> 之间没有区别</p>
<h1 id="MessagPort-postMessage"><a href="#MessagPort-postMessage" class="headerlink" title="MessagPort.postMessage"></a>MessagPort.postMessage</h1><blockquote>
<p>常用在仅仅需要<strong>两个端口</strong>互相发送数据的场合<br>深拷贝</p>
</blockquote>
<p>通过MessageChannel构造函数生成的实例channel，有两个实例属性他们都是 MessagePort的实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;port1, port2&#125; = <span class="keyword">new</span> <span class="title class_">MessageChannel</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(port1 <span class="keyword">instanceof</span> <span class="title class_">MessagePort</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>MessagePort有<br>实例方法：</p>
<ol>
<li><code>close()</code> 关闭端口，会阻止端口接收和发送</li>
<li><code>postMessage(message, [transfer])</code> 发送消息，transfer往下看</li>
<li><code>start()</code> 开始接收消息，往往配合如下方式使用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">port1.<span class="title function_">postMessage</span>(<span class="string">&#x27;message from port1&#x27;</span>)</span><br><span class="line"><span class="comment">//方法一：只有用addEventListener来监听message事件需要调用start</span></span><br><span class="line">port2.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>);</span><br><span class="line">&#125;) </span><br><span class="line">port2.<span class="title function_">start</span>() </span><br><span class="line"><span class="comment">//方法二：用onmessage，隐含调用了start</span></span><br><span class="line">port2.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="transfer-Transferable对象"><a href="#transfer-Transferable对象" class="headerlink" title="transfer Transferable对象"></a>transfer Transferable对象</h2><blockquote>
<p>transfer 是一个可选的Transferable对象的数组<br>transfer将被转移而不是克隆到新的上下文中，这意味着它们在<strong>发送消息的上下文</strong>中不再可用<br><strong>(可以打印，但是打印出来相当于是new contructor(), 它只剩一副空壳！)</strong></p>
</blockquote>
<p><b style="color:red">注意:</b><br>我认为在MessagePort.postMessage中转移另一个port没有意义(浅浅的认知)</p>
<p>但是你可以转移一个buffer</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; port1, port2 &#125; = <span class="keyword">new</span> <span class="title class_">MessageChannel</span>();</span><br><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line">port1.<span class="title function_">postMessage</span>(buffer, [buffer]);</span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//另一个上下文</span></span><br><span class="line">    port2.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> receivedBuffer = e.<span class="property">data</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(receivedBuffer)</span><br><span class="line">&#125;;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h2 id="js-上下文"><a href="#js-上下文" class="headerlink" title="js 上下文"></a>js 上下文</h2><p>关于js中上下文的含义(点我)</p>
<h1 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage"></a>window.postMessage</h1><blockquote>
<p>在不同window对象进行安全的<strong>跨源通信</strong>，例如当前winow和iframe.contentWindow之间</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">postMessage</span>(message, targetOrigin, [transfer]);</span><br></pre></td></tr></table></figure>
<p>targetOrigin: 通过window.origin与targetOrigin是否匹配，从而判断window能否接收到消息事件，其值可以是字符串”*”（表示无限制）或者一个 URL</p>
<p>message事件：与上面两个不同，window的message事件是<strong>谁发送，谁注册</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;./iframe.html&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> ifr = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;iframe&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        ifr.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            ifr.<span class="property">contentWindow</span>.<span class="title function_">postMessage</span>(<span class="string">&#x27;hello&#x27;</span>, <span class="string">&quot;*&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 同目录下的iframe --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;iframe: &#x27;</span>, e.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>iframe 最好用src相对地址引入一个文件<br><code>&lt;iframe&gt;</code> 标签中指定 src 属性，那么这个内容会异步加载。用js动态设置 src 属性，那么这个内容可能会同步加载</p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>postMessage</tag>
      </tags>
  </entry>
  <entry>
    <title>几种继承方式</title>
    <url>/2023/10/15/%E5%87%A0%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<ul>
<li>原型链</li>
<li>盗用构造函数</li>
<li>组合继承</li>
<li>原型式继承</li>
<li>寄生继承</li>
<li>寄生式组合继承</li>
</ul>
<span id="more"></span>
<h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p><strong>原理</strong>：子类的__proto__指向父类的一个实例当作原型对象<br><strong>缺陷</strong>：<br>    1. 原型对象上的引用值会在所有子实例间共享<br>    2. 子类实例化时无法给父构造函数传参</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Father</span>(); <span class="comment">//继承</span></span><br><span class="line"><span class="keyword">const</span> son = <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br></pre></td></tr></table></figure>

<h1 id="盗用构造函数"><a href="#盗用构造函数" class="headerlink" title="盗用构造函数"></a>盗用构造函数</h1><p><strong>原理</strong>： 在子类中调用父类构造函数<br><strong>缺陷</strong>：无法继承到父类的方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;son&#x27;</span>);</span><br></pre></td></tr></table></figure>


<h1 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h1><p><strong>原理</strong>： 原型链 + 盗用构造函数<br>要继承的属性用构造函数<br>要继承的方法写在原型上<br><strong>缺陷</strong>：调用两次父类构造函数，导致原型对象和子实例上都有父类属性<br><strong>优势</strong>：同时解决了继承引用值属性和方法的继承问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父类方法</span></span><br><span class="line"><span class="comment">// Father.prototype.sayName = function() &#123;</span></span><br><span class="line"><span class="comment">//     console.log(this.name);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">    <span class="title class_">Father</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)     <span class="comment">//第二次调用父类构造函数 --继承属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Father</span>()    <span class="comment">//第一次调用父类构造函数 --继承方法</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Son</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;blank&#x27;</span>,<span class="number">14</span>)</span><br><span class="line"><span class="comment">//可以发现实例和它的原型都有 name 和 colors， 这是调用俩次父类构造函数的结果</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(son));   <span class="comment">//[&#x27;name&#x27;, &#x27;colors&#x27;, &#x27;age&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>)); <span class="comment">//[&#x27;name&#x27;, &#x27;colors&#x27;, &#x27;constructor&#x27;]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这是最大缺陷：调用两次父类构造函数，导致子类实例和子类原型都有同名属性—— <strong>寄生式组合继承解决了该问题</strong></p>
</blockquote>
<h1 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h1><p><strong>原理</strong>：利用<code>Object.create</code> 实现继承，无需定义构造函数<br><strong>缺陷</strong>：同原型链继承，原型对象上的引用值会在所有子实例间共享</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>(); <span class="comment">//返回对象的原型是o</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h2><p>ES5实现的一个方法</p>
<p><code>Object.create(param1 [, param2])</code></p>
<ul>
<li>param1: 和object方法一样，返回一个对象，该对象原型是param1</li>
<li>param2: 和defineProperties一样， 可选</li>
</ul>
<h1 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h1><p><strong>原理</strong>：和工厂函数类似，创建一个继承的函数，以某种方式增强对象再返回这个对象<br><strong>缺陷</strong>：同原型式继承，原型对象上的引用值会在所有子实例间共享</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createAnother</span>(<span class="params">original</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> clone = <span class="title class_">Object</span>.<span class="title function_">create</span>(original) <span class="comment">//原型式继承的做法</span></span><br><span class="line">    clone.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;  <span class="comment">//增强该对象</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;blank&#x27;</span>,</span><br><span class="line">    <span class="attr">friends</span>: [<span class="string">&#x27;a&#x27;</span>]  <span class="comment">//和子对象共享地址！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> anotherPerson = <span class="title function_">createAnother</span>(person)</span><br><span class="line"><span class="keyword">let</span> yetAnotherPerson = <span class="title function_">createAnother</span>(person)</span><br><span class="line"></span><br><span class="line">anotherPerson.<span class="property">name</span> = <span class="string">&#x27;another&#x27;</span></span><br><span class="line">anotherPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&#x27;another&#x27;</span>)</span><br><span class="line"></span><br><span class="line">yetAnotherPerson.<span class="property">name</span> = <span class="string">&#x27;yet&#x27;</span></span><br><span class="line">yetAnotherPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&#x27;yet&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">//&#123; name: &#x27;blank&#x27;, friends: [ &#x27;a&#x27;, &#x27;another&#x27;, &#x27;yet&#x27; ] &#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="寄生式组合继承（最优）"><a href="#寄生式组合继承（最优）" class="headerlink" title="寄生式组合继承（最优）"></a>寄生式组合继承（最优）</h1><p>最大特点是： 用一个函数实现两个类的继承关系</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">Son, Father</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> prototype = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">//避免调用父构造函数</span></span><br><span class="line">    <span class="comment">//下面两行是建立起构造函数和原型对象之间的双向箭头</span></span><br><span class="line">    prototype.<span class="property">constructor</span> = <span class="title class_">Son</span></span><br><span class="line">    <span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = prototype;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="comment">//定义实例属性</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span>  =name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="title class_">Father</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name) <span class="comment">//调用一次父类构造函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 建立继承关系</span></span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">Son</span>, <span class="title class_">Father</span>) </span><br><span class="line"><span class="comment">// 定义父类方法</span></span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义子类方法 -- 必须在inheritPrototype后面</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>只调用一次父类构造函数，属性不重复</li>
<li>引用值不共享<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化</span></span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;blank&#x27;</span>,<span class="number">22</span>)</span><br><span class="line"><span class="comment">//1. 只调用了一次父类构造函数, 所以子类原型上没有实例属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(son)); <span class="comment">//[ &#x27;name&#x27;, &#x27;colors&#x27;, &#x27;age&#x27; ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(son.<span class="property">__proto__</span>)); <span class="comment">//[ &#x27;constructor&#x27;, &#x27;sayAge&#x27; ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(<span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>));  <span class="comment">//[ &#x27;constructor&#x27;, &#x27;sayName&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 引用值不共享</span></span><br><span class="line"><span class="keyword">let</span> son2 = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;lzy2&#x27;</span>, <span class="number">23</span>)</span><br><span class="line">son.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">son2.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(son.<span class="property">colors</span>);    <span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27; ]</span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p><strong>如何理解寄生？</strong><br>就是把继承这一操作用函数封装起来</p>
</blockquote>
<h1 id="ES6-类继承——extends"><a href="#ES6-类继承——extends" class="headerlink" title="ES6 类继承——extends"></a>ES6 类继承——extends</h1><h2 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h2><p>可以继承任何拥有<code>[[Constructor]]</code>和原型的对象</p>
<ul>
<li>实例拥有constructor指向构造函数</li>
</ul>
<h2 id="super"><a href="#super" class="headerlink" title="super"></a>super</h2><ol>
<li><p>super只能在派生类的构造函数和静态方法中使用<br><code>super()</code> 或 <code>super.superStaticFun()</code></p>
</li>
<li><p>调用super() 会调用父类构造函数，并把返回的实例赋值给this</p>
<p>所以必须使用this前调用super()</p>
</li>
<li><p>默认构造函数实例化时，会调用super()并传入所有参数</p>
</li>
<li><p>显式定义构造函数时，要么必须调用super()，要么手动返回一个对象</p>
</li>
</ol>
<h2 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h2><p>得到new 了一个什么东西</p>
]]></content>
      <categories>
        <category>js红宝书</category>
      </categories>
      <tags>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title>函数柯里化 Currying</title>
    <url>/2023/11/05/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96-Currying/</url>
    <content><![CDATA[<h1 id="什么是函数柯里化"><a href="#什么是函数柯里化" class="headerlink" title="什么是函数柯里化"></a>什么是函数柯里化</h1><p>是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术</p>
<h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数封装后</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">check</span>(<span class="params">reg, txt</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> reg.<span class="title function_">test</span>(txt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即使是相同的正则表达式，也需要重新传递一次</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">check</span>(<span class="regexp">/\d+/g</span>, <span class="string">&#x27;test1&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">check</span>(<span class="regexp">/\d+/g</span>, <span class="string">&#x27;testtest&#x27;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">check</span>(<span class="regexp">/[a-z]+/g</span>, <span class="string">&#x27;test&#x27;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>Currying后</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">curryingCheck</span>(<span class="params">reg</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">txt</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> reg.<span class="title function_">test</span>(txt)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正则表达式通过闭包保存了起来</span></span><br><span class="line"><span class="keyword">var</span> hasNumber = <span class="title function_">curryingCheck</span>(<span class="regexp">/\d+/g</span>)</span><br><span class="line"><span class="keyword">var</span> hasLetter = <span class="title function_">curryingCheck</span>(<span class="regexp">/[a-z]+/g</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hasNumber</span>(<span class="string">&#x27;test1&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hasNumber</span>(<span class="string">&#x27;testtest&#x27;</span>));  <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">hasLetter</span>(<span class="string">&#x27;21212&#x27;</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h1 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">写一个add函数 要求: </span><br><span class="line">add(1)(2) == 3</span><br><span class="line">add(1)(2)(3) == 6;</span><br><span class="line">add(1, 2)(3) == 6; </span><br><span class="line">tip: </span><br><span class="line">    由add(1)(2)(3)可知 add(1)(2) 应该是返回函数的</span><br><span class="line">    但是又add(1)(2) == 3 ，可知 里面有隐式转换，重写toString()</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//空参数默认为0</span></span><br><span class="line">    <span class="comment">//这个数组利用了闭包的特性，所有加数都会push进这个数组</span></span><br><span class="line">    <span class="keyword">const</span> _args = <span class="variable language_">arguments</span>.<span class="property">length</span> ? [...<span class="variable language_">arguments</span>] : [<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">_adder</span>(<span class="params"></span>) &#123;</span><br><span class="line">        _args.<span class="title function_">push</span>(...<span class="variable language_">arguments</span> || <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> _adder</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//隐式转换时调用toString()</span></span><br><span class="line">    _adder.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> _args.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回一个函数是一定的</span></span><br><span class="line">    <span class="keyword">return</span> _adder</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>, <span class="number">4</span>).<span class="title function_">toString</span>());</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>柯里化</tag>
      </tags>
  </entry>
  <entry>
    <title>前端性能优化</title>
    <url>/2024/03/06/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="首屏速度"><a href="#首屏速度" class="headerlink" title="首屏速度"></a>首屏速度</h1><p><strong>源码上</strong></p>
<ol>
<li><p>路由懒加载（动态导入） <code>()=&gt;import(&#39;/path&#39;)</code></p>
<ul>
<li>不要再导入异步组件了，因为路由组件本身就是动态导入，不需要组件写出异步组件了</li>
<li>当前跳到了某路由，其对应组件才会下载。</li>
</ul>
</li>
<li><p>异步组件（按需导入） <code>defineAsyncComponent</code></p>
<ul>
<li><pre><code class="js">const Some = defineAsyncComponent(()=&gt;import(&#39;/pat&#39;))
...
&lt;Some v-if=&quot;isShow&quot;&gt;&lt;/Some&gt;
</code></pre>
<p>首屏没有加载，<strong>用到时再向服务器发送请求</strong>。</p>
</li>
</ul>
</li>
<li><p>老版的库更新以支持tree-shaking，少用第三方库</p>
</li>
<li><p>服务器渲染SSR</p>
</li>
<li><p>服务器gZip压缩</p>
</li>
<li><p>webpack打包压缩代码，禁止大图片转base64</p>
</li>
</ol>
<p><strong>网络上</strong></p>
<p>静态资源放在cdn上<br>注意本地webpack要配置external 排除cdn引入的包</p>
<p><strong>用户感知上</strong></p>
<p>骨架屏&#x2F;loading</p>
<h1 id="prefetch-和-script"><a href="#prefetch-和-script" class="headerlink" title="prefetch 和 script"></a>prefetch 和 script</h1><ul>
<li>script加载</li>
</ul>
<p>按需引入</p>
<p>切换需要等待</p>
<ul>
<li><code>&lt;link rel=&#39;prefetch&#39; as=&#39;script&#39; href=&#39;&#39; /&gt;</code></li>
</ul>
<p>预加载，切换无感</p>
<p>浪费带宽</p>
<blockquote>
<p>prefetch 和 preload 不同:<br>preload是一种<strong>立即</strong>获取资源的策略，用来声明一个高优先级资源强制浏览器提前请求。<br>prefetch是一种在后台缓存资源的策略，（缓存的资源并不是当前页面需要的）以便在需要时立即使用。</p>
</blockquote>
<h1 id="渲染性能"><a href="#渲染性能" class="headerlink" title="渲染性能"></a>渲染性能</h1><ul>
<li>vue</li>
</ul>
<ol>
<li>keep-alive 缓存</li>
<li>v-show</li>
</ol>
]]></content>
      <tags>
        <tag>性能</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>原始值和引用值 &amp; typeof和instanceof</title>
    <url>/2023/10/11/%E5%8E%9F%E5%A7%8B%E5%80%BC%E5%92%8C%E5%BC%95%E7%94%A8%E5%80%BC/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="八大基本类型"><a href="#八大基本类型" class="headerlink" title="八大基本类型"></a>八大基本类型</h1><p>Number String Boolean BigInt Symbol Object null undefined</p>
<blockquote>
<p>JSON 数据类型：Object Array Number String Boolean Null</p>
<p>对于undefined，JSON.stringify 会直接忽略</p>
</blockquote>
<h1 id="原始值和引用值"><a href="#原始值和引用值" class="headerlink" title="原始值和引用值"></a>原始值和引用值</h1><ul>
<li>js数据类型分为 原始值和引用值。<ul>
<li>八大基本类型减去 <code>Object</code>就属于七大原始类型</li>
<li>而引用值其实是一个对象</li>
</ul>
</li>
</ul>
<h2 id="原始值"><a href="#原始值" class="headerlink" title="原始值"></a>原始值</h2><h3 id="原始值包装类型"><a href="#原始值包装类型" class="headerlink" title="原始值包装类型"></a>原始值包装类型</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> n =<span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//原始值包装类型转成boolean值都为true</span></span><br></pre></td></tr></table></figure>

<p>对原始值类型上调用方法，是先生成一个包装类对象，再在包装类对象上改造。</p>
<h2 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h2><p>都是按值传递，只不过引用值存的是指针</p>
<ol>
<li>原始值传递：复制该值</li>
<li>引用值传递：复制指针</li>
</ol>
<p>p86、p101</p>
<h2 id="typeof和instanceof"><a href="#typeof和instanceof" class="headerlink" title="typeof和instanceof"></a>typeof和instanceof</h2><ul>
<li><strong>typeof</strong></li>
</ul>
<p>typeof 有哪些返回值：number，string, boolean, bigint, symbol, undefined, object(null,array,set,map,weakmap), function(class)</p>
<ol>
<li><p>原始值可以用 : typeof ‘qweqe’ &#x3D;&#x3D;&#x3D; ‘string’</p>
<p>注意： typeof null &#x3D;&#x3D; ‘object’; typeof [] &#x3D;&#x3D; ‘object’</p>
</li>
<li><p>原始值包装对象 : new String(“hello”) 会 返回 ‘object’</p>
</li>
</ol>
<ul>
<li><strong>instanceof</strong></li>
</ul>
<p>A instanceof B : 查找A的原型链，如果查找到B的原型，则返回ture</p>
<ol>
<li>原始值用都是返回false</li>
<li>实例 instanceof Function &#x3D;&#x3D;&#x3D; false, 但是 实例 instanceof 类名 &#x3D;&#x3D;&#x3D; true</li>
</ol>
]]></content>
      <categories>
        <category>js红宝书</category>
      </categories>
      <tags>
        <tag>原始值</tag>
        <tag>引用值</tag>
        <tag>typeof</tag>
        <tag>instanceof</tag>
      </tags>
  </entry>
  <entry>
    <title>回流重绘</title>
    <url>/2024/04/27/%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98/</url>
    <content><![CDATA[<h1 id="什么是回流重绘"><a href="#什么是回流重绘" class="headerlink" title="什么是回流重绘"></a>什么是回流重绘</h1><p>HTML中每个元素都可视为一个盒子，在浏览器解析时</p>
<ul>
<li><strong>回流</strong>：当元素的尺寸、位置或某些属性发生变化时，浏览器需要重新计算元素的几何属性，然后再将计算的结果绘制出来。这个过程就叫做回流。例如，修改元素的宽度、高度、或者添加或删除可见的DOM元素，都会触发回流。</li>
<li><strong>重绘</strong>：当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</li>
</ul>
<p><strong>回流必将引起重绘，而重绘不一定会引起回流</strong></p>
<h2 id="回流触发时机"><a href="#回流触发时机" class="headerlink" title="回流触发时机"></a>回流触发时机</h2><p>回流一般在于元素的几何信息（大小、位置）发生变化时触发。</p>
<ol>
<li>添加或删除节点</li>
<li>元素大小或位置改变</li>
<li>页面初次渲染</li>
<li>浏览器窗口尺寸变化（因为回流根据视口来计算的）</li>
</ol>
<p>除此之外一些获取几何信息的属性也会触发回流</p>
<blockquote>
<p>offsetTop offsetLeft  offsetWidth offsetHeight<br>scroll-<br>client-<br>getBoundingClientRect() getComputedStyle()</p>
</blockquote>
<h2 id="重绘触发时机"><a href="#重绘触发时机" class="headerlink" title="重绘触发时机"></a>重绘触发时机</h2><ol>
<li>颜色、阴影的修改</li>
<li>通过visibility、opacity 显示和隐藏</li>
<li>文本对齐方向</li>
</ol>
<blockquote>
<p>修改文本排列方向是会回流的，修改对齐方向不回流</p>
</blockquote>
<h1 id="浏览器优化"><a href="#浏览器优化" class="headerlink" title="浏览器优化"></a>浏览器优化</h1><p>由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列</p>
<p>当你获取布局信息的操作的时候，会强制队列刷新，包括前面讲到的offsetTop等方法都会返回最新的数据</p>
<p>因此浏览器不得不清空队列，触发回流重绘来返回正确的值</p>
<h1 id="如何减少回流重绘"><a href="#如何减少回流重绘" class="headerlink" title="如何减少回流重绘"></a>如何减少回流重绘</h1><ol>
<li>通过改变元素的 class 类名设定元素的样式：这样做可以一次性地应用多个样式，而不需要逐个修改样式属性。这样可以减少浏览器重新计算样式和布局的次数，从而减少回流和重绘。</li>
<li>避免设置多项内联样式：内联样式会直接修改元素的样式，每修改一次都可能触发回流和重绘。使用class类名可以一次性地应用多个样式，减少回流和重绘的次数。</li>
<li>应用元素的动画，使用 position 属性的 fixed 值或 absolute 值：这样可以使元素脱离文档流，其位置的改变不会影响到其他元素的布局，从而减少回流。但是，这可能会增加重绘的次数，因为元素的位置改变可能会改变其可见性。</li>
<li>避免使用 table 布局：table 中每个元素的大小以及内容的改动，都会导致整个 table 的重新计算，从而触发回流。使用其他布局方式，如 flex 或 grid，可以减少回流的次数。</li>
<li>对于那些复杂的动画，对其设置 position: fixed&#x2F;absolute：这样可以使元素脱离文档流，其位置的改变不会影响到其他元素的布局，从而减少回流。但是，这可能会增加重绘的次数，因为元素的位置改变可能会改变其可见性。</li>
<li>使用css3硬件加速：硬件加速可以让一些复杂的动画（如 transform、opacity、filters）在 GPU 而不是 CPU 上运行，这可以避免触发回流和重绘，从而提高性能。</li>
<li>避免使用 CSS 的 JavaScript 表达式：CSS 的 JavaScript 表达式会在每次页面渲染时都被重新计算，这可能会触发大量的回流和重绘。避免使用它们可以减少回流和重绘的次数。</li>
</ol>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>回流重绘</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Hexo的博客</title>
    <url>/2020/12/30/%E5%9F%BA%E4%BA%8EHexo%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="安装hexo框架"><a href="#安装hexo框架" class="headerlink" title="安装hexo框架"></a>安装hexo框架</h1><ol>
<li><p>下载 node.js  （如果有可以跳过）</p>
</li>
<li><p>安装 cnpm （全局安装，淘宝镜像源）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 hexo </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>

<h1 id="搭建blog"><a href="#搭建blog" class="headerlink" title="搭建blog"></a>搭建blog</h1><ol>
<li><p>新建blog目录，进入该目录，<u>之后操作全在该目录下！</u></p>
</li>
<li><p>初始化hexo</p>
</li>
</ol>
   <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>关于hexo的一些操作 (四个步骤按顺序执行后即可在4000端口看到本地的效果)</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>/预览 hexo s</span><br><span class="line"><span class="number">2</span>/新建 hexo n <span class="string">&quot;标题&quot;</span></span><br><span class="line"><span class="number">3</span>/清理 hexo clean</span><br><span class="line"><span class="number">4</span>/生成 hexo g </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>坑：</strong>“标题”中有些特别的符号不能用，例如英文下的[]</li>
</ul>
</li>
</ol>
<h1 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h1><ol>
<li>先去github新建仓库</li>
</ol>
<ul>
<li><strong>坑：</strong>仓库名必须是  自己的用户名.github.io</li>
</ul>
<ol start="2">
<li><p>blog目录下安装一个插件</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">cnpm install <span class="literal">--save</span> hexo<span class="literal">-deployer-git</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置blog目录下的 _config.yml 文件</p>
<blockquote>
<p>在 #Deployment 下的 deploy: </p>
<p>​	type: ‘git’</p>
<p>​	repo: ‘自己的仓库地址不是网址’</p>
<p>​	branch: ‘master’</p>
</blockquote>
<ul>
<li><strong>坑：</strong>注意冒号后的英文空格</li>
</ul>
</li>
<li><p>部署到远端</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>/部署 hexo d</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h1><ol>
<li>先把主题下载到本地</li>
</ol>
   <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">git clone 主题的仓库地址 目录</span><br><span class="line"><span class="comment">#例如 git clone https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置 _config.yml 文件</li>
</ol>
<blockquote>
<p>在 #Extensions 下</p>
<p>​	theme: butterfly</p>
</blockquote>
<p>   这里的butterfly及1.中的butterfly目录</p>
<ol start="3">
<li>在本地预览</li>
</ol>
   <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s	</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>部署到远端 （反应不一定很快）</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>坑：</strong>如果更换主题遇到任何问题，请在blog目录下安装以下插件</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install <span class="literal">--save</span> hexo<span class="literal">-renderer-jade</span> hexo<span class="literal">-generator-feed</span> hexo<span class="literal">-generator-sitemap</span> hexo<span class="literal">-browsersync</span> hexo<span class="literal">-generator-archive</span></span><br><span class="line">npm install <span class="literal">--save</span> hexo<span class="literal">-deployer-git</span></span><br></pre></td></tr></table></figure>



<h1 id="设置-SSH-使用-hexo-deploy-时免输用户名密码"><a href="#设置-SSH-使用-hexo-deploy-时免输用户名密码" class="headerlink" title="设置 SSH 使用 hexo deploy 时免输用户名密码"></a>设置 SSH 使用 hexo deploy 时免输用户名密码</h1><p>原文：<a href="https://www.jianshu.com/p/a7167e26b086">https://www.jianshu.com/p/a7167e26b086</a></p>
<p>SSH 验证就是我们键入命令 <code>hexo deploy</code> 以后，当那些需要提交的内容显示完成过后会弹出的一个小窗口提示我们输入用户名、密码。此处我们设置ssh公钥，实现<code>hexo deploy</code>时免密登陆。</p>
<h2 id="1-生成-SSH-密钥"><a href="#1-生成-SSH-密钥" class="headerlink" title="1. 生成 SSH 密钥"></a>1. 生成 SSH 密钥</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br></pre></td></tr></table></figure>

<p>使用 <code>ssh-keygen</code> 生成密钥</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<p>后面的三次输入均可使用默认值，<code>Enter回车</code>跳过</p>
<p>密钥生成成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Your identification has been saved <span class="keyword">in</span> /home/you/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /home/you/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">…………………此处是密钥内容…………………… your_email@example.com</span><br></pre></td></tr></table></figure>

<h2 id="2-设置-Github-项目的-SSH-keys"><a href="#2-设置-Github-项目的-SSH-keys" class="headerlink" title="2. 设置 Github 项目的 SSH keys"></a>2. 设置 Github 项目的 SSH keys</h2><p>！如何设置自行搜索，很简单</p>
<p>接下来测试配置是否成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@Gitee.com</span><br></pre></td></tr></table></figure>

<p>如果出现以下内容即表示配置完成并且成功！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">The authenticity of host <span class="string">&#x27;gitee.com (xx.xx.xx.xx)&#x27;</span> can<span class="string">&#x27;t be established.</span></span><br><span class="line"><span class="string">ECDSA key fingerprint is SHA256:FQGC9Kn/eye1W8icdBgrQp+KkGYoFgbVr17bmjey0Wc.</span></span><br><span class="line"><span class="string">ECDSA key fingerprint is MD5:27:e5:d3:f7:2a:9e:eb:6c:93:cd:1f:c1:47:a3:54:b1.</span></span><br><span class="line"><span class="string">Are you sure you want to continue connecting (yes/no)? yes</span></span><br><span class="line"><span class="string">Warning: Permanently added &#x27;</span>gitee.com,xx.xx.xx.xx<span class="string">&#x27; (ECDSA) to the list of known hosts.</span></span><br><span class="line"><span class="string">Hi xxx! You&#x27;</span>ve successfully authenticated, but GITEE.COM does not provide shell access.</span><br></pre></td></tr></table></figure>

<h2 id="3-修改博客Git远程提交地址"><a href="#3-修改博客Git远程提交地址" class="headerlink" title="3.修改博客Git远程提交地址"></a>3.修改博客Git远程提交地址</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改 https 协议为 ssh 协议(仓库的ssh地址)</span></span><br><span class="line">git remote set-url origin git@gitee.com:xxx/xxx.git</span><br></pre></td></tr></table></figure>

<h2 id="4-修改hexo根目录下-config-yml中的远程仓库设置"><a href="#4-修改hexo根目录下-config-yml中的远程仓库设置" class="headerlink" title="4.修改hexo根目录下_config.yml中的远程仓库设置"></a>4.修改hexo根目录下<code>_config.yml</code>中的远程仓库设置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: git@gitee.com:xxx/xxx.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>最后部署到远程就可以了</p>
<p>注：如果使用的是码云作为远程仓库部署，还需要在对应仓库的服务中手动部署一下</p>
<h1 id="Md格式文档写作"><a href="#Md格式文档写作" class="headerlink" title="Md格式文档写作"></a>Md格式文档写作</h1><h2 id="创建categories-、tags-选项"><a href="#创建categories-、tags-选项" class="headerlink" title="创建categories 、tags 选项"></a>创建categories 、tags 选项</h2><blockquote>
<p>categories、tags 配置是通用的</p>
</blockquote>
<ol>
<li><p>生成categories page</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
</li>
<li><p>找到生成的 <code>/categories/index.md</code>。添加 <code>type: &quot;categories&quot;</code> </p>
</li>
<li><p>categories 赋予文章</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: </span><br><span class="line">data: </span><br><span class="line">categories: </span><br><span class="line"><span class="bullet">   -</span> 分类1</span><br><span class="line"><span class="bullet">   -</span> 分类2</span><br><span class="line">tags: </span><br><span class="line"><span class="bullet">   -</span> 标签1</span><br><span class="line"><span class="bullet">   -</span> 标签2</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="hexo-特殊样式：note"><a href="#hexo-特殊样式：note" class="headerlink" title="hexo 特殊样式：note"></a>hexo 特殊样式：note</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note default %&#125;default&#123;% endnote %&#125;</span><br><span class="line">&#123;% note primary %&#125;primary&#123;% endnote %&#125;</span><br><span class="line">&#123;% note success %&#125;success&#123;% endnote %&#125;</span><br><span class="line">&#123;% note info %&#125;info&#123;% endnote %&#125;</span><br><span class="line">&#123;% note warning %&#125;warning&#123;% endnote %&#125;</span><br><span class="line">&#123;% note danger %&#125;danger&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>

<h2 id="hexo-特殊样式：tabs"><a href="#hexo-特殊样式：tabs" class="headerlink" title="hexo 特殊样式：tabs"></a>hexo 特殊样式：tabs</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs name %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>遇到任何问题，要善于运用搜索引擎，网上相关解决方法很多。当然也欢迎留言、讨论，一起进步吧！</p>
<h1 id="更新–日常使用遇到的BUG"><a href="#更新–日常使用遇到的BUG" class="headerlink" title="更新–日常使用遇到的BUG"></a>更新–日常使用遇到的BUG</h1><p>这里我放一下常见的问题</p>
<ol>
<li><p><strong>md图片相对路径</strong> </p>
<p>一、不要用md的语法插入图片。而是用 </p>
<p>其中，asset_img 不动，imgurl就是图片名别漏了后缀，descript图片描述可省略。</p>
<p>二、在&#x2F;source&#x2F;_posts&#x2F;下建一个同名路径，图片放里面</p>
</li>
<li><p><strong>添加评论功能</strong></p>
<p>文档错了那一大段代码不是markdown而是yml，也就是说YAML不需要写那些，而是在主题配置文件中搜索comments 找到如下部分。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">comments:</span></span><br><span class="line">  <span class="comment"># Up to two comments system, the first will be shown as default</span></span><br><span class="line">  <span class="comment"># Choose: Disqus/Disqusjs/Livere/Gitalk/Valine/Waline/Utterances/Facebook Comments/Twikoo</span></span><br><span class="line">  <span class="attr">use:</span></span><br><span class="line">  <span class="comment"># - Valine</span></span><br><span class="line">  <span class="comment"># - Disqus</span></span><br><span class="line">  <span class="attr">text:</span> <span class="literal">true</span> <span class="comment"># Display the comment name next to the button</span></span><br><span class="line">  <span class="comment"># lazyload: The comment system will be load when comment element enters the browser&#x27;s viewport.</span></span><br><span class="line">  <span class="comment"># If you set it to true, the comment count will be invalid</span></span><br><span class="line">  <span class="attr">lazyload:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">count:</span> <span class="literal">false</span> <span class="comment"># Display comment count in top_img</span></span><br></pre></td></tr></table></figure>

<p>在use后面加入你选择的评论系统</p>
</li>
<li><p><strong>添加搜索系统</strong></p>
<p>文档没有细说，需要自行百度，这些都很简单。记住一点，要改hexo框架的_config.yml文件，把url: 后面的网址改成你自己的网址。不然搜索到内容后点击会进错误的网址。</p>
</li>
<li><p>分享功能 sharejs</p>
<p>其实这里没有bug，但是。举个例子，用qq方式分享。扫描二维码进入的是你当前页面的地址，是<u>自动</u>的。所以你在本地端口4000预览的时候测试分享功能手机是扫不出来的，因为手机进不了localhost:4000。<u>你要去github部署的网站上测试该功能</u>。注意一下。</p>
</li>
<li><p>首页文章只显示摘要（next主题）</p>
<p>在正文md文档中，想要作为摘要的地方后用<code>&lt;!-- more --&gt;</code>分割</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>枚举和迭代——借由for-in和for-of说明</title>
    <url>/2023/10/11/%E6%9E%9A%E4%B8%BE%E5%92%8C%E8%BF%AD%E4%BB%A3/</url>
    <content><![CDATA[<h1 id="枚举和迭代有什么区别？"><a href="#枚举和迭代有什么区别？" class="headerlink" title="枚举和迭代有什么区别？"></a>枚举和迭代有什么区别？</h1><ul>
<li>for-in 是遍历所有可枚举属性(包括原型链上的)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="string">&#x27;aaa&#x27;</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="string">&#x27;bbb&#x27;</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">c</span> = <span class="string">&#x27;ccc&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj,<span class="string">&#x27;d&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;ddd&#x27;</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span></span><br><span class="line">&#125;) <span class="comment">//d属性枚举不到</span></span><br></pre></td></tr></table></figure>

<p><a href="/2023/10/13/%E4%B8%80%E4%BA%9B%E6%9E%9A%E4%B8%BE%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95">🔗更多关于枚举</a></p>
<p>所以enumberable决定了属性能不能被枚举到<br>而可迭代性是由各种类型里内置的迭代器工厂函数决定的</p>
<p>详见：🔗<a href="/2023/10/10/%E8%BF%AD%E4%BB%A3%E5%99%A8-%E7%94%9F%E6%88%90%E5%99%A8">迭代器-生成器</a></p>
<ul>
<li>for-of 是迭代，要有迭代器才能用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比如迭代一个Object类型会报错，因为Object没有实现Iterable接口不可迭代</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);   <span class="comment">//&#123;a: &#x27;aaa&#x27;, b: &#x27;bbb&#x27;, d: &#x27;ddd&#x27;&#125;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> obj)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125; <span class="comment">//Uncaught TypeError: obj is not iterable</span></span><br></pre></td></tr></table></figure>

<h1 id="手写一个伪数组迭代器"><a href="#手写一个伪数组迭代器" class="headerlink" title="手写一个伪数组迭代器"></a>手写一个伪数组迭代器</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; range &#125; = <span class="built_in">require</span>(<span class="string">&quot;lodash&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fakeArr = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值号右边是一个生成器函数</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">iterator</span>] = <span class="keyword">function</span>* () &#123;</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="title function_">range</span>(<span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">length</span>)) &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="variable language_">this</span>[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> fakeArr) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>枚举</tag>
        <tag>for-in</tag>
        <tag>迭代</tag>
        <tag>for-of</tag>
        <tag>Object.defineProperty</tag>
        <tag>Object.hasOwnProperty</tag>
      </tags>
  </entry>
  <entry>
    <title>浅尝Web Worker</title>
    <url>/2024/03/21/%E6%B5%85%E5%B0%9DWeb-Worker/</url>
    <content><![CDATA[<h1 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h1><p>创建一个worker对象，可以在浏览器中创建一个新线程不阻塞UI线程渲染。</p>
<ul>
<li>必须遵守<strong>同源策略</strong></li>
<li>深拷贝</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>send msg<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;terminate&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color: red;&quot;</span>&gt;</span>terminate<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#btn&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> terminate = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#terminate&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#msg&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&#x27;./worker.js&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">        worker.<span class="property">onmessage</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我接收到了&#x27;</span>,e.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我发送了&#x27;</span>,input.<span class="property">value</span>)</span></span><br><span class="line"><span class="language-javascript">            worker.<span class="title function_">postMessage</span>(input.<span class="property">value</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        terminate.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            worker.<span class="title function_">terminate</span>()</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>worker.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">onmessage = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;另一个线程监听到了:&#x27;</span>, e.<span class="property">data</span>)</span><br><span class="line">    <span class="title function_">postMessage</span>(<span class="string">&#x27;另一个线程加工了&#x27;</span>+e.<span class="property">data</span>)</span><br><span class="line">&#125;</span><br><span class="line">onerror = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onerror监听到:&#x27;</span>, e)</span><br><span class="line">&#125;</span><br><span class="line">onmessageerror = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onmessageerror监听到:&#x27;</span>,e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// console.log(self);</span></span><br></pre></td></tr></table></figure>

<p>通过new Worker(‘.&#x2F;worker.js’) 的worker.js 文件处于 <code>DedicatedWorkerGlobalSpace</code>作用域下，可以用 <code>self</code> 访问到这个全局对象。</p>
<p><strong>所以以上三个方法就是对全局对象的事件处理函数的重写</strong>。</p>
<h1 id="Shared-Worker"><a href="#Shared-Worker" class="headerlink" title="Shared Worker"></a>Shared Worker</h1><ul>
<li>必须遵守同源策略</li>
<li>实现标签页共享</li>
<li>深拷贝</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#btn&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> terminate = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#terminate&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> msg = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#msg&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ul = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.recv&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">SharedWorker</span>(<span class="string">&#x27;./sharedWorker.js&#x27;</span>)</span><br><span class="line"><span class="comment">// worker.port.start();</span></span><br><span class="line">btn.<span class="property">onclick</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我发送了&#x27;</span>, msg.<span class="property">value</span>);</span><br><span class="line">    worker.<span class="property">port</span>.<span class="title function_">postMessage</span>(msg.<span class="property">value</span>);</span><br><span class="line">&#125;</span><br><span class="line">worker.<span class="property">port</span>.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我接收到了&#x27;</span>, e.<span class="property">data</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> counter = <span class="number">0</span>; <span class="comment">// 计时器</span></span><br><span class="line"><span class="keyword">const</span> clients = [] <span class="comment">//连接上的用户，注意 无论有几个标签页，e.ports 的长度始终都是1</span></span><br><span class="line">self.<span class="property">onconnect</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> port = e.<span class="property">ports</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//console.log(e.ports); //⭐这里的内容必须在 edge://inspect/#workers 的inspect 里的控制台查看</span></span><br><span class="line">    <span class="comment">//port.postMessage(&#x27;sharedworker已连接&#x27;); //不能发送e或者  ports 里的任何对象。因为他们is not transferred</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sharedworker已连接&#x27;</span>)</span><br><span class="line">    clients.<span class="title function_">push</span>(port);</span><br><span class="line">    port.<span class="property">onmessage</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sharedworker接收到&#x27;</span>, e.<span class="property">data</span>)</span><br><span class="line">        counter++;</span><br><span class="line">        clients.<span class="title function_">forEach</span>(<span class="function"><span class="params">client</span> =&gt;</span> &#123;</span><br><span class="line">            client.<span class="title function_">postMessage</span>(counter)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>注意</p>
<ol>
<li>同一个name下，且同一个域名下才可以共享</li>
<li>想实现广播功能要自己保存每个连接（类似websocket）</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>webWorker</tag>
      </tags>
  </entry>
  <entry>
    <title>浅聊WeakMap与Map</title>
    <url>/2023/10/22/%E6%B5%85%E8%81%8AWeakMap/</url>
    <content><![CDATA[<p>说到WeakMap不得不说Map了，他们的相同之处在于都是用一个key 对应一个 value</p>
<span id="more"></span>

<p>不同之处则在于：<br>WeakMap对象持有的所有键都是<strong>弱引用</strong>，正因为它</p>
<ul>
<li>WeakMap的key只能是引用值类型，Map的key可以是任何</li>
<li>WeakMap类型<i style="color:red">没有内置迭代器</i>, 而Map有</li>
<li>WeapMap在没有其他引用时垃圾回收机制能正确进行</li>
</ul>
<p>应用：</p>
<ul>
<li><a href="/2023/10/22/%E6%B7%B1%E6%8B%B7%E8%B4%9D#%E6%9C%80%E5%90%8E%E8%87%AA%E5%B7%B1%E9%87%8D%E6%96%B0%E6%89%8B%E6%90%93%E4%B8%80%E4%B8%AA%E7%BB%88%E6%9E%81%E7%89%88%E7%9A%84deepClone">深拷贝-解决循环应用</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>WeakMap</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Service Worker</title>
    <url>/2023/11/05/%E6%B5%85%E8%B0%88Service-Worker/</url>
    <content><![CDATA[<p>很好的一篇博客<a href="https://www.cnblogs.com/jaycethanks/p/16502676.html#1-service-worker-%E7%AE%80%E4%BB%8B">Service Worker</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Service Worker</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈node模块引入与加载机制</title>
    <url>/2023/11/07/%E6%B5%85%E8%B0%88node%E6%A8%A1%E5%9D%97%E5%BC%95%E5%85%A5%E4%B8%8E%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="模块种类"><a href="#模块种类" class="headerlink" title="模块种类"></a>模块种类</h1><ol>
<li>核心模块: <code>path url file http</code> 等<ul>
<li>优先级高，重名时优先加载</li>
<li>直接导入模块名，不需要写路径 <code>require(&#39;moduleName&#39;)</code></li>
</ul>
</li>
<li>文件模块: <ul>
<li>引入可分为三种<ul>
<li>绝对路径 <code>require(&#39;/moduleName&#39;)</code></li>
<li>相对路径 <code>require(&#39;./dir/moduleName&#39;)</code></li>
<li><strong>第三方加载方式</strong> <code>require(&#39;moduleName&#39;)</code></li>
</ul>
</li>
<li>如果不加拓展名，则按照 <code>.js .json .node</code> 顺序为其加上拓展名</li>
</ul>
</li>
</ol>
<h1 id="加载机制"><a href="#加载机制" class="headerlink" title="加载机制"></a>加载机制</h1><ol>
<li>优先从缓存中加载</li>
<li>对于 <code>require(&#39;moduleName&#39;)</code> 方式导入先当作核心模块加载，如果没有则<strong>再当作第三方模块加载</strong></li>
</ol>
<blockquote>
<p>第三方模块加载会一层一层的向外查找。</p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>import</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器渲染原理</title>
    <url>/2023/10/12/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h1><p>当浏览器获得html文档，会产生一个渲染任务，把渲染任务分配给渲染主线程的消息队列。<br>在时间循环机制下，渲染主线程去除消息队列中的任务，开始渲染流程</p>
<span id="more"></span>

<h2 id="渲染阶段"><a href="#渲染阶段" class="headerlink" title="渲染阶段"></a>渲染阶段</h2><ol>
<li>解析html</li>
<li>样式计算</li>
<li>布局</li>
<li>分层</li>
<li>绘制</li>
</ol>
<h3 id="1-解析html"><a href="#1-解析html" class="headerlink" title="1. 解析html"></a>1. 解析html</h3><p><img src="/2023/10/12/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/css.png" alt="css"></p>
<p>每个内部样式表、外部样式表、行内样式表都是一个CSStyleSheet</p>
<p><code>document.StyleSheetList</code>是一个数组统揽所有CSStyleSheet</p>
<p><strong>解析时遇到css怎么办</strong></p>
<p><img src="/2023/10/12/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/%E8%A7%A3%E6%9E%90html-%E9%81%87%E5%88%B0css.png" alt="遇到CSS"></p>
<ul>
<li>css不会阻塞html解析，因为渲染主线程直接忽略css，主线程知道与解析器正在下载和预处理css</li>
<li>js 会阻塞html解析，因为js可能改变DOM树</li>
</ul>
<blockquote>
<p>解析html完成后生成DOM树和CSSOM树</p>
</blockquote>
<h3 id="2-样式计算"><a href="#2-样式计算" class="headerlink" title="2. 样式计算"></a>2. 样式计算</h3><p>包括css属性值计算，DOM树每个节点获得最终样式</p>
<h3 id="3-布局"><a href="#3-布局" class="headerlink" title="3. 布局"></a>3. 布局</h3><p>遍历DOM树每个节点，计算每个节点的几何属性（尺寸和位置），得到Layout树</p>
<h3 id="4-分层"><a href="#4-分层" class="headerlink" title="4. 分层"></a>4. 分层</h3><p>分层后，某一层改变只需要重新计算该层</p>
<h3 id="5-绘制"><a href="#5-绘制" class="headerlink" title="5. 绘制"></a>5. 绘制</h3><h1 id="输入url到渲染页面的过程"><a href="#输入url到渲染页面的过程" class="headerlink" title="输入url到渲染页面的过程"></a>输入url到渲染页面的过程</h1><ol>
<li>dns解析</li>
<li>tcp三次握手</li>
<li>发送http请求</li>
<li>服务端处理请求发送响应</li>
<li>浏览器收到响应，<ol>
<li>根据html文件，构建dom树</li>
<li>根据css 构建渲染树</li>
</ol>
</li>
<li>浏览器开始页面渲染，同时下载js文件</li>
</ol>
<h1 id="script-defer-和-script-async"><a href="#script-defer-和-script-async" class="headerlink" title="script defer 和 script async"></a>script defer 和 script async</h1><ul>
<li><strong>defer和async只适用于外部脚本</strong></li>
<li>浏览器在解析html时，遇到script会立即停止解析html，而去执行js。如果script有外部文件，则会等待文件下载。</li>
<li>async表示：下载js时html会继续解析，下载完js立即停止转而执行js，再回头解析html</li>
<li>defer表示：不打断html解析的同时下载js，html解析完毕才执行js</li>
</ul>
<p><img src="/2023/10/12/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/async&defer.png" alt="img"></p>
<h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><ul>
<li>最大缺陷： 循环引用下，计数永远不能归零，无法清除造成内存泄漏</li>
</ul>
<h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><ol>
<li>将所有对象标记</li>
<li>从根作用域开始遍历，处于上下文的对象去除标记</li>
<li><strong>清除带标记</strong>的对象</li>
</ol>
<p>这样之后存活对象分布比较零散，有三种方式：</p>
<ol>
<li>First-fit 放在能放下新对象的第一个块</li>
<li>Best-fit 放在能放下新对象的最小块<ul>
<li>容易有内存碎片</li>
</ul>
</li>
<li>Worst-fit 放在最大块</li>
</ol>
<p>垃圾回收时必须阻塞js执行，所以诞生了</p>
<ol>
<li>多线程并行回收</li>
<li>增量标记：执行一段js，执行一段垃圾回收</li>
<li>并发回收：js执行在主线程，垃圾回收执行在辅助线程</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>浏览器渲染原理</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解BFC</title>
    <url>/2024/03/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3BFC/</url>
    <content><![CDATA[<h1 id="普通流"><a href="#普通流" class="headerlink" title="普通流"></a>普通流</h1><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><blockquote>
<p> 可以看作是一个独立的布局区域</p>
</blockquote>
<h3 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h3><ol>
<li><code>&lt;html&gt;</code></li>
<li><code>float: !none</code></li>
<li><code>position: absolute | fixed</code></li>
<li><code>display: inline-block | table ...</code></li>
<li><code>overflow: !(visible | clip) &amp;&amp; 是块级元素</code></li>
<li><code>containe: layout | content | paint</code></li>
<li>多列容器 <code>column-count | column-width</code></li>
</ol>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol>
<li>避免margin塌陷 （包括水平和垂直）</li>
<li>清除浮动</li>
<li>避免被浮动元素覆盖</li>
</ol>
<h1 id="浮动流"><a href="#浮动流" class="headerlink" title="浮动流"></a>浮动流</h1><h1 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h1>]]></content>
      <tags>
        <tag>BFC</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>深拷贝</title>
    <url>/2023/10/22/%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<span id="more"></span>



<h1 id="一个自己写的不成熟deepClone函数"><a href="#一个自己写的不成熟deepClone函数" class="headerlink" title="一个自己写的不成熟deepClone函数"></a>一个自己写的不成熟deepClone函数</h1><ul>
<li>不能复制 不可枚举属性 （去掉第9行左边的判断可以实现）</li>
<li>不能复制原型的方法</li>
<li>不能复制Set Map Symbol</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> obj</span><br><span class="line">    <span class="keyword">let</span> clone;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span> obj</span><br><span class="line">    <span class="comment">//是数组</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj)) clone = []</span><br><span class="line">    <span class="keyword">else</span> clone = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key) &amp;&amp; (<span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span>)) &#123;</span><br><span class="line">            clone[key] = <span class="title function_">deepClone</span>(obj[key])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clone[key] = obj[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="看到利用MessageChannel实现深拷贝的神操作"><a href="#看到利用MessageChannel实现深拷贝的神操作" class="headerlink" title="看到利用MessageChannel实现深拷贝的神操作"></a>看到利用MessageChannel实现深拷贝的神操作</h1><ul>
<li>可以完美解决循环引用的问题</li>
<li>不可以复制函数</li>
<li>不可以复制Symbol</li>
<li>不支持拷贝原型上的方法和变量</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; port1, port2 &#125; = <span class="keyword">new</span> <span class="title class_">MessageChannel</span>()</span><br><span class="line">        port1.<span class="title function_">postMessage</span>(obj)</span><br><span class="line">        port2.<span class="property">onmessage</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(e.<span class="property">data</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="string">&quot;&quot;</span>, <span class="attr">c</span>: <span class="literal">undefined</span>, <span class="attr">e</span>: <span class="number">0</span>, <span class="attr">f</span>: [], <span class="attr">g</span>: <span class="title class_">NaN</span>, <span class="attr">h</span>: <span class="literal">null</span>,<span class="attr">I</span>:<span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>,<span class="number">2</span>]), </span><br><span class="line"><span class="attr">J</span>: <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>]]) &#125;</span><br><span class="line">obj.<span class="property">b</span>  = obj<span class="comment">//循环引用</span></span><br><span class="line"><span class="title function_">deepClone</span>(obj).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="structuredClone"><a href="#structuredClone" class="headerlink" title="structuredClone"></a>structuredClone</h1><blockquote>
<p>适用范围同 MessageChannel 方法的</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">structuredClone</span>(obj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="loadsh的cloneDeep函数"><a href="#loadsh的cloneDeep函数" class="headerlink" title="loadsh的cloneDeep函数"></a>loadsh的cloneDeep函数</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; cloneDeep &#125; <span class="keyword">from</span> <span class="string">&#x27;loadsh&#x27;</span> </span><br></pre></td></tr></table></figure>

<h1 id="JSON实现深拷贝"><a href="#JSON实现深拷贝" class="headerlink" title="JSON实现深拷贝"></a>JSON实现深拷贝</h1><ul>
<li>不能解决<strong>循环引用</strong></li>
<li>NaN被拷贝成null</li>
<li>Symbol和undefined没被拷贝</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newObj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br></pre></td></tr></table></figure>

<h1 id="最后自己重新手搓一个终极版的deepClone"><a href="#最后自己重新手搓一个终极版的deepClone" class="headerlink" title="最后自己重新手搓一个终极版的deepClone"></a>最后自己重新手搓一个终极版的deepClone</h1><ul>
<li>解决了循环引用 – 利用WeakMap</li>
<li>支持深拷贝Symbol，Set，Map，fn</li>
<li>不支持深拷贝Date，RegExp，</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> obj</span><br><span class="line">    <span class="keyword">let</span> clone;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(hash.<span class="title function_">has</span>(obj))&#123;</span><br><span class="line">        <span class="comment">// 如果在的话</span></span><br><span class="line">        <span class="keyword">return</span> hash.<span class="title function_">get</span>(obj)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Set</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Set</span>([...obj]) <span class="comment">//缺陷--解构是浅拷贝</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Map</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Map</span>([...obj])</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">WeakMap</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&#x27;weakmap类型未作处理&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> obj === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">//方法不用克隆，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">Array</span>) &#123; <span class="comment">//obj 是数组</span></span><br><span class="line">        clone = [];</span><br><span class="line">        hash.<span class="title function_">set</span>(obj, clone)</span><br><span class="line">        obj.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            clone.<span class="title function_">push</span>(<span class="title function_">deepClone</span>(item, hash))</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) &#123; <span class="comment">//原始值类型</span></span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//obj 是Object对象</span></span><br><span class="line">        clone = &#123;&#125;;</span><br><span class="line">        hash.<span class="title function_">set</span>(obj, clone)</span><br><span class="line">        <span class="comment">//键是字符</span></span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">propNames</span> =&gt;</span> &#123;</span><br><span class="line">            clone[propNames] = <span class="title function_">deepClone</span>(obj[propNames],hash)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">//键是Symbol</span></span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">syb</span> =&gt;</span> &#123;</span><br><span class="line">            clone[<span class="title class_">Symbol</span>(syb.<span class="property">description</span>)] = <span class="title function_">deepClone</span>(obj[syb],hash)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="优化手写深度克隆"><a href="#优化手写深度克隆" class="headerlink" title="优化手写深度克隆"></a>优化手写深度克隆</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>生成器实现异步</title>
    <url>/2024/03/26/%E7%94%9F%E6%88%90%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<p>js中实现异步有三大方式: <code>回调</code> <code>Promise</code> <code>generator</code></p>
<ul>
<li><p>回调</p>
<ul>
<li>优势：简单、语义清晰</li>
<li>劣势：回调地狱</li>
</ul>
</li>
<li><p>Promise</p>
<ul>
<li>优势： 链式调用解决回调地狱、Promise.all 可以处理多个异步</li>
<li>劣势：需要适用Promise语法</li>
</ul>
</li>
<li><p>Generator</p>
<ul>
<li>优势：利用yield编写可读性更强、可以恢复和暂停、是async&#x2F;await的底层原理、</li>
<li>劣势：不是专门解决异步的，需要搭配Promise、要手动编写生成器和迭代器使得编码更复杂</li>
</ul>
</li>
</ul>
<p>现在我们来详细聊聊<strong>generator实现异步</strong></p>
<p><strong>场景</strong></p>
<p>我要读一个文件dir.txt 这是一部目录，里面记录了 Lzy.json , XXX.json …. 等等 用户文件。</p>
<p>然后我们要读取Lzy.json 的信息。</p>
<p><strong>用 <code>async/await</code> 方式解决</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">read</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> dir = <span class="keyword">await</span> <span class="title function_">readFile</span>(<span class="string">&#x27;./txt/dir.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> userInfo = <span class="keyword">await</span> <span class="title function_">readFile</span>(path.<span class="title function_">resolve</span>(<span class="string">&#x27;./txt&#x27;</span>, dir), <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> userInfo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">read</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br></pre></td></tr></table></figure>

<p><strong>用 <code>generator</code>方式解决</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">read</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> dir = <span class="keyword">yield</span> <span class="title function_">readFile</span>(<span class="string">&#x27;./txt/dir.txt&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(dir)</span><br><span class="line">    <span class="keyword">const</span> userInfo = <span class="keyword">yield</span> <span class="title function_">readFile</span>(path.<span class="title function_">resolve</span>(<span class="string">&#x27;./txt&#x27;</span>, dir), <span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(userInfo)</span><br><span class="line">    <span class="keyword">return</span> userInfo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> it = <span class="title function_">read</span>() <span class="comment">// 获取生成器对象</span></span><br><span class="line"><span class="keyword">const</span> res1 = it.<span class="title function_">next</span>();</span><br><span class="line">res1.<span class="property">value</span>.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 相当于dir.txt完成后把值传给read函数的dir变量, 并执行一步生成器</span></span><br><span class="line">    it.<span class="title function_">next</span>(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样只执行了第一步，而我们得到第一步的PromiseResult之后要继续递归的运行next(PromiseResult) 这样才能得到第二步。</p>
<p>所以我们需要一个执行器 <code>co</code> ， </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> finalRes= <span class="title function_">co</span>(<span class="title function_">read</span>())</span><br><span class="line">finalRes.<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res)) <span class="comment">// 一步到位,输出task3完成时的PromiseResult</span></span><br></pre></td></tr></table></figure>

<p><strong>实现 <code>co</code></strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">co</span>(<span class="params">gen</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">next</span>();</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">next</span>(<span class="params">context</span>) &#123; <span class="comment">// context 就是上一步异步任务完成的PromiseResult </span></span><br><span class="line">            <span class="keyword">const</span> &#123; value, done &#125; = gen.<span class="title function_">next</span>(context);</span><br><span class="line">            <span class="keyword">if</span> (done)</span><br><span class="line">                <span class="title function_">resolve</span>(value)</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// Promsie.resolve(value) 为了防止value是普通值。</span></span><br><span class="line">                <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(value).<span class="title function_">then</span>(<span class="function"><span class="params">val</span> =&gt;</span> <span class="title function_">next</span>(val))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>context 就是上一步yield后面的表达式完成时的PromiseResult </p>
<p>例如： <code>const dir = yield readFile(&#39;./txt/dir.txt&#39;, &#39;utf8&#39;);</code> 就是把context 赋值给了dir</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>generator</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端web</title>
    <url>/2023/10/11/%E7%A7%BB%E5%8A%A8%E7%AB%AFweb/</url>
    <content><![CDATA[<p>移动端web</p>
<span id="more"></span>

<h3 id="CSS代码规范"><a href="#CSS代码规范" class="headerlink" title="CSS代码规范"></a>CSS代码规范</h3><ul>
<li>类名语义化，全部小写，用下划线分割 “_”</li>
<li>类名嵌套层次尽量不超过三层</li>
<li>尽量避免直接使用 元素选择器</li>
<li>避免使用 id选择器</li>
<li>避免使用 *选择器 和 !important</li>
<li>属性书写顺序<ul>
<li>布局定位属性：display &#x2F; position &#x2F; float &#x2F; clear &#x2F; visibility &#x2F; overflow</li>
<li>尺寸属性：width &#x2F; height &#x2F; margin &#x2F; padding &#x2F; border &#x2F; background</li>
<li>文本属性：color &#x2F; font &#x2F; text-decoration &#x2F; text-align &#x2F; vertical-align</li>
<li>其他属性：content &#x2F; cursor &#x2F; border-radius &#x2F; box-shadow &#x2F; text-shadow</li>
</ul>
</li>
</ul>
<h3 id="meta视口标签"><a href="#meta视口标签" class="headerlink" title="meta视口标签"></a>meta视口标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meate</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">meate</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">mete标签<u>content</u>属性的属性</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">width</td>
<td>viewport宽度，可设置为device-width</td>
</tr>
<tr>
<td align="left">initial-scale</td>
<td>初始缩放比例，大于0的数字</td>
</tr>
<tr>
<td align="left">minimum-scale</td>
<td>最小缩放比例，大于0的数字</td>
</tr>
<tr>
<td align="left">maximum-scale</td>
<td>最大缩放比例，大于0的数字</td>
</tr>
<tr>
<td align="left">user-scalable</td>
<td>用户是否可以缩放，yes或no（1或0）</td>
</tr>
</tbody></table>
<h3 id="CSS初始化"><a href="#CSS初始化" class="headerlink" title="CSS初始化"></a>CSS初始化</h3><p>移动端CSS初始化推荐使用 <a href="https://necolas.github.io/normalize.css/">normalize.css</a></p>
<h3 id="特殊样式"><a href="#特殊样式" class="headerlink" title="特殊样式"></a>特殊样式</h3><p>移动端需要添加的特殊样式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 1. 清除 点击高亮效果  transparent为透明*/</span></span><br><span class="line">-webkit-tap-highlight-<span class="attribute">color</span>: transparent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2. 禁用 长按页面时弹出菜单*/</span></span><br><span class="line"><span class="selector-tag">img</span>,<span class="selector-tag">a</span> &#123;-webkit-touch-callout: none;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3. ios系统 需要该属性才能自定义样式*/</span></span><br><span class="line">-webkit-appearance: none;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4. 盒子模型 boder-size: border-box;*/</span></span><br><span class="line"><span class="attribute">box-sizing</span>: border-box;</span><br></pre></td></tr></table></figure>

<h3 id="背景缩放-background-size"><a href="#背景缩放-background-size" class="headerlink" title="背景缩放 background-size"></a>背景缩放 background-size</h3><p><strong>二倍图</strong></p>
<blockquote>
<p>一般为了避免移动端图片自动放大2倍造成图片模糊，都是放2倍像素的图，再指定缩小50% ，同理也有三倍图、四倍图</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-size</span>: 宽度 高度;</span><br></pre></td></tr></table></figure>

<ul>
<li>单位：长度|百分比|cover|contain<ul>
<li>百分比  是以父级盒子为参考</li>
<li>cover 扩展至背景图完全覆盖区域</li>
<li>contain 扩展至背景图比例最大且不超过区域</li>
</ul>
</li>
</ul>
<h3 id="背景颜色线性渐变-webkit-linear-gradient"><a href="#背景颜色线性渐变-webkit-linear-gradient" class="headerlink" title="背景颜色线性渐变 -webkit-linear-gradient"></a>背景颜色线性渐变 -webkit-linear-gradient</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="built_in">-webkit-linear-gradient</span>(起始方向, 颜色<span class="number">1</span>, 颜色<span class="number">2</span>, ...);</span><br></pre></td></tr></table></figure>

<ul>
<li>开始方向：可以是 方位名词、度数（默认top）</li>
</ul>
<h2 id="移动端技术选型"><a href="#移动端技术选型" class="headerlink" title="移动端技术选型"></a>移动端技术选型</h2><table>
<thead>
<tr>
<th>1.单独制作移动端页面（主流）</th>
<th>2.响应式页面兼容移动端</th>
</tr>
</thead>
<tbody><tr>
<td>流式布局（百分比布局）</td>
<td>媒体查询</td>
</tr>
<tr>
<td>flex弹性布局（强烈推荐）</td>
<td>bootstarp</td>
</tr>
<tr>
<td>less+rem+媒体查询布局</td>
<td></td>
</tr>
<tr>
<td>混合布局</td>
<td></td>
</tr>
</tbody></table>
<h3 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h3><p>通过盒子宽度设置为百分比来根据屏幕的宽度进行伸缩，不受固定像素影响</p>
<ul>
<li>max-width: 200px 最大宽度</li>
<li>min-width:  100px 最小宽度</li>
</ul>
<h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><ul>
<li><p>特点：</p>
<table>
<thead>
<tr>
<th>传统布局</th>
<th>flex布局</th>
</tr>
</thead>
<tbody><tr>
<td>兼容性好</td>
<td>PC端兼容差</td>
</tr>
<tr>
<td>布局繁琐</td>
<td>布局极其简单</td>
</tr>
<tr>
<td>在移动端的局限性</td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p><strong>原理</strong>：通过给<u>父盒子</u>添加felx属性，来控制子盒子的位置和排列方式</p>
<ul>
<li>任何容器都可以指定为flex布局，display: flex;</li>
<li>设置为flex布局之后，不再有块级、行内元素之分</li>
<li>当父盒子设为flex布局后，<u>子元素的float、clear、vertical-align 失效</u></li>
<li>flex布局 &#x3D; 伸缩布局 &#x3D; 弹性布局 &#x3D; 伸缩盒布局 &#x3D; 弹性盒布局</li>
</ul>
</li>
<li><p><strong>常见<u>父项</u>属性</strong>：</p>
<ul>
<li><p><strong>flex-direction</strong>：设置<em>主轴方向</em>，另一个就是<em>侧轴方向</em></p>
<ul>
<li><p>默认主轴方向：水平向右 <strong>→</strong> ；默认侧轴方向：竖直向下 <strong>↓</strong></p>
</li>
<li><table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>row</td>
<td>从左到右 → （默认）</td>
</tr>
<tr>
<td>row-reverse</td>
<td>从右到左 ←</td>
</tr>
<tr>
<td>column</td>
<td>从上到下 ↓</td>
</tr>
<tr>
<td>column-reverse</td>
<td>从下到上 ↑</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>flex-wrap</strong>：设置子元素是否换行</p>
<ul>
<li><table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>nowrap</td>
<td>不换行（默认，<u>如果装不开会缩小子元素宽度</u>）</td>
</tr>
<tr>
<td>wrap</td>
<td>换行</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>flex-flow</strong>：复合属性，相当于同时设置了 flex-direction 和 flex-wrap</p>
</li>
<li><p><strong>justify-content</strong>：设置主轴上的子元素排列方式</p>
<ul>
<li><table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>flex-start</td>
<td>从头部开始（默认）</td>
</tr>
<tr>
<td>flex-end</td>
<td>从尾部开始</td>
</tr>
<tr>
<td>center</td>
<td>在主轴居中对齐</td>
</tr>
<tr>
<td>space-around</td>
<td>平分剩余空间</td>
</tr>
<tr>
<td>space-between</td>
<td>先两边贴边再平分剩余空间</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>align-items</strong>：设置侧轴上的子元素排列方式（单行时用)</p>
<ul>
<li><table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>flex-start</td>
<td>从上到下 ↓</td>
</tr>
<tr>
<td>flex-end</td>
<td>从下到上 ↑</td>
</tr>
<tr>
<td>center</td>
<td>挤在一起居中（垂直居中）</td>
</tr>
<tr>
<td>stretch</td>
<td>拉伸（默认值）（要先去掉子元素height，否则不起作用）</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>align-content</strong>：设置侧轴上的子元素的排列方式（换行时用，单行时无效）</p>
<ul>
<li>属性值比 justify-content 多了一个 stretch</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>常见<u>子项</u>属性</strong> </p>
<ul>
<li><p><strong>flex</strong>：定义子项目分配<u>剩余</u>空间，用来表示占多少份数</p>
<ul>
<li>属性值：浮点数</li>
</ul>
</li>
<li><p><strong>align-self</strong>：控制单个项目在侧轴上的排列方式</p>
<ul>
<li><p>可覆盖 align-items 属性</p>
</li>
<li><p>属性值除了align-items的还有</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>auto</td>
<td>继承父盒子的 align-items 属性（默认）</td>
</tr>
<tr>
<td>baseline</td>
<td>项目位于父盒子基线上</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p><strong>order</strong>：定义项目的排列顺序</p>
<ul>
<li>数值越小越靠前，默认0</li>
<li>属性值：数字</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="less-rem-媒体查询-布局"><a href="#less-rem-媒体查询-布局" class="headerlink" title="less+rem+媒体查询 布局"></a>less+rem+媒体查询 布局</h3><ul>
<li><p><strong>rem单位</strong>（root em）是一个相对单位，相对于html元素的 font-size 大小</p>
</li>
<li><p><strong>媒体查询</strong>（Media Query）是CSS3新语法</p>
<ul>
<li><p>@media 可以针对不同的屏幕尺寸设置不同的样式</p>
</li>
<li><p>语法规范 </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> mediatype <span class="keyword">and</span>|<span class="keyword">not</span>|<span class="keyword">only</span> (media-feature) &#123;&#125;</span><br><span class="line"><span class="comment">/*例：@media screen and (min-width: 10px) and (max-width: 20px) &#123;&#125; */</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>mediatype</strong> 查询类型 </p>
<table>
<thead>
<tr>
<th>值</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>all</td>
<td>用于所有设备</td>
</tr>
<tr>
<td>print</td>
<td>用于打印机、打印预览</td>
</tr>
<tr>
<td>screen</td>
<td>用于 电脑、平板、手机</td>
</tr>
</tbody></table>
</li>
<li><p><strong>and|not|only</strong> 关键字</p>
<p>关键字将媒体类型或多个媒体特性连接到一起作为媒体查询的条件</p>
<ul>
<li>and：可以将多个媒体特性连接到一起，相当于“且”</li>
<li>not： 排除某个媒体类型，相当于“非”，可省略</li>
<li>only：指定某个特定的媒体类型，可省略</li>
</ul>
</li>
<li><p><strong>media-feature</strong> 媒体特性\媒体功能</p>
<ul>
<li>width：定义输出设备中页面课件区域宽度</li>
<li>min-width：定义输出设备最小可见区域宽度</li>
<li>max-width：定义射出设备最大可见区域宽度</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>引入资源</strong> </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;&quot; media=&quot;mediatype and|not|only (media-feature)&quot;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Less</strong> </p>
<p>文件后缀 .less ，css预处理器，Less中文网址：<a href="http://lesscss.cn/">http://lesscss.cn</a> </p>
<ul>
<li><p>Less 变量</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">@变量名: 值;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Less 编译</p>
<p>通过Easy LESS插件，保存后自动生成同名css后缀的文件，用link引入</p>
</li>
<li><p>Less 嵌套</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="selector-tag">a</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">&amp;</span><span class="selector-pseudo">:hover</span> &#123; <span class="comment">// 此时 &amp; 符号代表div，即div:hover</span></span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Less 运算</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span> + <span class="number">5</span>;</span><br><span class="line">    <span class="attribute">height</span>: (<span class="number">100px</span> / <span class="number">10px</span> ); <span class="comment">//除法需要括号或者 ./ 代替 / </span></span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1em</span>+<span class="number">0.5px</span>+<span class="number">1rem</span> solid black; <span class="comment">//一次运算多个单位只取第一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Less 导入</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;路径&quot;</span>; 		 <span class="comment">// 与css导入法相同</span></span><br><span class="line"><span class="keyword">@import</span> url(<span class="string">路径</span>)；	<span class="comment">// 两种方法均可</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>​</p>
<h3 id="flexible-js-rem-布局"><a href="#flexible-js-rem-布局" class="headerlink" title="flexible.js+rem 布局"></a>flexible.js+rem 布局</h3><p>淘宝推出的移动端适配库</p>
<ul>
<li>不需要写不同屏幕的媒体查询</li>
<li>原理是把当前设备划分为10等分</li>
<li>要引入js文件，去github下载</li>
</ul>
</li>
</ul>
<h3 id="响应式开发"><a href="#响应式开发" class="headerlink" title="响应式开发"></a>响应式开发</h3><p>原理：需要一个父级作为<strong>布局容器</strong>，使用媒体查询针对不同宽度的设备进行布局</p>
<table>
<thead>
<tr>
<th align="left">设备划分</th>
<th align="left">尺寸区间</th>
<th>布局容器的width尺寸划分</th>
<th>bootstrap类前缀</th>
</tr>
</thead>
<tbody><tr>
<td align="left">超小屏幕（手机）</td>
<td align="left">&lt; 768px</td>
<td>100%</td>
<td>.col-xs-</td>
</tr>
<tr>
<td align="left">小屏设备（平板）</td>
<td align="left">&gt;&#x3D; 768px &lt;992px</td>
<td>750px</td>
<td>.col-sm-</td>
</tr>
<tr>
<td align="left">中等屏幕 (桌面显示器)</td>
<td align="left">&gt;&#x3D; 992px &lt; 1200 px</td>
<td>970px</td>
<td>.col-md-</td>
</tr>
<tr>
<td align="left">宽屏设备（大桌面显示器）</td>
<td align="left">&gt;&#x3D; 1200 px</td>
<td>1170px</td>
<td>.col-lg-</td>
</tr>
</tbody></table>
<h3 id="Bootstrap-使用"><a href="#Bootstrap-使用" class="headerlink" title="Bootstrap 使用"></a>Bootstrap 使用</h3><ul>
<li><strong>步骤</strong></li>
</ul>
<ol>
<li><p>创建文件夹</p>
</li>
<li><p>创建html骨架结构</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 要求当前网页使用IE浏览器最高版本的内核来渲染 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Bootstrap 101 Template<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- Bootstrap --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- HTML5 shiv 和 Respond.js 是为了让 IE8 支持 HTML5 元素和媒体查询（media queries）功能 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 警告：通过 file:// 协议（就是直接将 html 页面拖拽到浏览器中）访问页面时 Respond.js 不起作用 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">    &lt;script src=&quot;https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">  &lt;![endif]--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>引入相关样式文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;bootstrap/css/bootstrap.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure>
</li>
<li><p>书写内容</p>
</li>
</ol>
<ul>
<li><strong>布局容器</strong></li>
</ul>
<p>bootstrap预定义了.container类（响应式）和 .container-fluid类（流式）</p>
<ul>
<li><strong>栅格系统</strong><ul>
<li><p>随着屏幕或视口（viewport）尺寸的增加，系统会自动分为最多12列，通过一系列的 .row 与 .col-xs- 等 的组合来创建页面。</p>
</li>
<li><p>row必须放到container布局容器里</p>
</li>
<li><p>需要给列添加类前缀，例如   .col-xs- 1 , 1 代表占用12份中的1份，xs代表设备大小在xs以及xs以上的都生效</p>
</li>
<li><p>每一行中列大于12 ，<u>多余的 列会换行</u></p>
</li>
<li><p><u>每一列默认15px的左右padding，而 .row 有 -15px的左右margin</u></p>
<ul>
<li>列嵌套时，最好加一个 .row 这样可以抵消父级的 padding</li>
</ul>
</li>
</ul>
</li>
<li><strong>列偏移</strong> col-<code>md</code>-offset-<code>1</code><ul>
<li>原理：给这一列添加 <u>margin-left</u> ，值为1份</li>
</ul>
</li>
<li><strong>列排序</strong> col-<code>md</code>-pull-<code>1</code>  、col-<code>md</code>-push-<code>1</code> <ul>
<li>原理：相对定位的 left 和 right </li>
<li>不能同时具有 pull和 push ， 以前面的为准</li>
<li>pull向左移动，push向右移动</li>
</ul>
</li>
<li><strong>隐藏 \ 显示</strong> <ul>
<li>.hidden-xs、.hidden-sm、.hidden-md、.hidden-lg 实现对应设备下隐藏</li>
<li>.visible-xs、.visible-sm、.visible-md、.visible-lg 实现对应设备下隐藏</li>
<li>原理：display: none!important; 和 display: block!important;</li>
</ul>
</li>
<li><strong>字体图标</strong><ul>
<li>原理：before伪元素</li>
<li>使用方法：1.文档中的组件中找到字体图标的名称; 2.直接添加到class中</li>
</ul>
</li>
<li><strong>清除浮动</strong><ul>
<li>原理：双伪元素清除浮动</li>
<li>使用方法：直接在class中加 clearfix</li>
</ul>
</li>
</ul>
<h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h2><ul>
<li>开发平台<ul>
<li>摹客</li>
<li>蓝湖（收费）</li>
</ul>
</li>
<li>swiper轮播图插件<ul>
<li><a href="https://www.bilibili.com/video/BV14J4114768?p=484&spm_id_from=pageDriver">学习网址</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title>编码</title>
    <url>/2023/10/21/%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<p>聊聊一些编码</p>
<span id="more"></span>

<h1 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h1><p>使用1B表示一个字符</p>
<p>前128位包含了：</p>
<ul>
<li>大小写英文字母</li>
<li>阿拉伯数字</li>
<li>运算符，逻辑字符</li>
<li>控制字符：LF（换行）、CR（回车）、FF（换页）、DEL（删除）、BS（退格）、BEL（响铃）</li>
<li>通信字符：SOH（文头）、EOT（文尾）、ACK（确认）</li>
</ul>
<p>后128位是扩展ASCII字符</p>
<h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><p>国际标准化组织ISO定义的一套国际通用的编码</p>
<p>全世界所有民族地区的文字基本都在里面</p>
<p>最初Unicode一个字符占用2B，后来增长到3B</p>
<h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><p>UTF-8不是一套编码，<strong>而是Unicode的一套压缩和解压缩的机制</strong></p>
<p>一个字符占用1-4B</p>
<ul>
<li>对于ASCII中的字符，沿用其编码，占用1B</li>
<li>对于Unicode中的字符，沿用， 占用2-3B</li>
<li>其他，占用4B</li>
</ul>
<h1 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h1><p>GB&#x3D;&#x3D;国标</p>
<ol>
<li>GB2312：  1980 年，收录了6763 个常用的汉字和字符</li>
<li>GBK： 1995年，在GB2312上添加了一些简体字，繁体字，日朝中的汉字，共约2W字，完全兼容GB2312</li>
<li>GB18030：分为2000版本和2005版本，在GBK上添加了少数民族字体，共约7W子</li>
</ol>
]]></content>
      <tags>
        <tag>GBK</tag>
        <tag>UTF</tag>
        <tag>Unicode</tag>
        <tag>ASCII</tag>
      </tags>
  </entry>
  <entry>
    <title>跨标签通信</title>
    <url>/2023/12/22/%E8%B7%A8%E6%A0%87%E7%AD%BE%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<ol>
<li><p>本地存储监听</p>
<blockquote>
<p>监听 <strong>同源</strong> localStorage 的修改 （如果setItem 的值没变，则不会触发storage事件</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onStorage</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>BroadcastChannel.postMessage</p>
<blockquote>
<p><strong>同源</strong></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标签1</span></span><br><span class="line"><span class="keyword">const</span> bc = <span class="keyword">new</span> <span class="title class_">BroadcastChannel</span>(<span class="string">&#x27;common channel&#x27;</span>) </span><br><span class="line">bc.<span class="title function_">postMessage</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="comment">//标签2</span></span><br><span class="line"><span class="keyword">const</span> bc = <span class="keyword">new</span> <span class="title class_">BroadcastChannel</span>(<span class="string">&#x27;common channel&#x27;</span>)  </span><br><span class="line">bc.<span class="property">onmessage</span> = <span class="function">(<span class="params">e</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>详见 <a href="/2023/12/24/%E5%87%A0%E7%A7%8DpostMessage/#BroadcastChannel-postMessage">🔗几种postMessage</a></p>
</li>
<li><p>WebSocket</p>
</li>
<li><p>shared worker<br><a href="/4000/2024/03/21/%E6%B5%85%E5%B0%9DWeb-Worker/#Shared-Worker">🔗详见</a></p>
</li>
<li><p>IndexDB 轮询 &#x2F; cookie 轮询</p>
</li>
<li><p>window.open 返回一个打开的页面对象，通过window.opener 得到</p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>标签</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器&amp;生成器</title>
    <url>/2023/10/10/%E8%BF%AD%E4%BB%A3%E5%99%A8-%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<h1 id="Iterable"><a href="#Iterable" class="headerlink" title="Iterable"></a>Iterable</h1><ul>
<li>实现了Iterable接口的数据结构就可以通过Iterator消费</li>
<li>Iterator暴露可迭代对象的api，无需了解他的数据结构</li>
</ul>
<span id="more"></span>

<h2 id="怎么实现Iterable接口"><a href="#怎么实现Iterable接口" class="headerlink" title="怎么实现Iterable接口"></a><em>怎么实现Iterable接口</em></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">limit</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">limit</span> = limit</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1. 工厂函数</span></span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> limit = <span class="variable language_">this</span>.<span class="property">limit</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="comment">// 2.1 next方法</span></span><br><span class="line">            <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count &lt;= limit)</span><br><span class="line">                    <span class="comment">// 返回IterableResult</span></span><br><span class="line">                    <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: count++ &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.2 可选 提前终止迭代器</span></span><br><span class="line">            <span class="keyword">return</span>() &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;提前终止...&#x27;</span>)</span><br><span class="line">                <span class="comment">//必须返回IterableResult</span></span><br><span class="line">                <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> counter = <span class="keyword">new</span> <span class="title class_">Counter</span>(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提前中断</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> counter) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">提前终止...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>迭代器如果没有关闭可以接着之前的位置继续。中断迭代器会调用return，但是调用了return不一定会关闭迭代器。例如Array类型</p>
</blockquote>
<h2 id="next"><a href="#next" class="headerlink" title="next()"></a>next()</h2><blockquote>
<p>next() 是迭代器的api</p>
</blockquote>
<ul>
<li>返回Iteratorresult对象， 包括 done和value<ul>
<li>done: true | false   迭代完了吗</li>
<li>value: 当前取得</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ita.<span class="title function_">next</span>()); <span class="comment">//&#123; value: &#x27;a&#x27;, done: false &#125; </span></span><br></pre></td></tr></table></figure>

<h2 id="内部实现了Iterable接口的类型"><a href="#内部实现了Iterable接口的类型" class="headerlink" title="内部实现了Iterable接口的类型"></a><em>内部实现了Iterable接口的类型</em></h2><ol>
<li>String</li>
<li>Array</li>
<li>Set</li>
<li>Map</li>
<li>arguments 对象</li>
<li>NodeList 等DOM集合类型</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> it = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it);    <span class="comment">//[Function: values] 迭代器的工厂函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ita = arr[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ita);   <span class="comment">//Object [Array Iterator] &#123;&#125;  迭代器</span></span><br></pre></td></tr></table></figure>

<h2 id="自动兼容可迭代对象的"><a href="#自动兼容可迭代对象的" class="headerlink" title="自动兼容可迭代对象的"></a><em>自动兼容可迭代对象的</em></h2><blockquote>
<p>它们会自动调用工厂函数创建迭代器</p>
</blockquote>
<ol>
<li>for-of</li>
<li>数组解构 <code>let [a, b] = [1,2]</code></li>
<li>扩展操作符 <code>[1,2,3, ...arr2]</code></li>
<li>创建Set、Map</li>
<li>Promise.all()</li>
<li>Array.from()</li>
<li>yield*</li>
</ol>
<p><strong>伪数组没有迭代器，需要Array.from()转成数组</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fakerArr = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">let</span> i <span class="keyword">in</span> fakerArr)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(fakerArr[i]) <span class="comment">//正常</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">let</span> item <span class="keyword">of</span> fakerArr)&#123; <span class="comment">//TypeError: fakerArr is not iterable</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>迭代器会占用一个引用计数，组织垃圾回收可迭代对象</li>
</ol>
<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>拥有在一个函数块内<strong>暂停</strong>和<strong>恢复</strong>代码执行的能力</p>
<h2 id="生成器函数"><a href="#生成器函数" class="headerlink" title="生成器函数"></a>生成器函数</h2><ul>
<li>声明生成器函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> * <span class="title function_">generatorFn</span>(<span class="params"></span>)&#123;&#125; <span class="comment">//调用后返回生成器对象</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>箭头函数不能声明为生成器函数</p>
</blockquote>
<h2 id="生成器对象"><a href="#生成器对象" class="headerlink" title="生成器对象"></a>生成器对象</h2><ul>
<li>一开始处于suspended状态</li>
<li><strong>实现了Iterator接口</strong><ul>
<li>next()<ul>
<li>让生成器开始或恢复执行</li>
</ul>
</li>
<li>return() 必有<ul>
<li>即value的值</li>
</ul>
</li>
<li>throw() 特有<ul>
<li>注入一个错误，如果不用try-catch处理错误就会关闭生成器，处理了则跳过这次yield继续下去</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;log...&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">//到这步才会打印log，因为之前处于暂停状态</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    generatorFn &#123;&lt;suspended&gt;&#125;</span></span><br><span class="line"><span class="comment">    log...</span></span><br><span class="line"><span class="comment">    &#123; value: &#x27;foo&#x27;, done: true &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>默认的迭代器是自引用的</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g === g[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><ol>
<li>yield 可以让生成器停止和开始执行<ol>
<li>使用next()继续执行</li>
</ol>
</li>
<li>yield 退出的生成器函数处于done: false状态<ol>
<li>return() 出去的done: true</li>
</ol>
</li>
<li>yield 只能在生成器函数内使用</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用next()继续</span></span><br><span class="line"><span class="keyword">function</span> * <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//yield 来输出</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;b&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>(); <span class="comment">//生成器对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">//&#123;value: &#x27;a&#x27;, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">//&#123;value: &#x27;b&#x27;, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>()) <span class="comment">//&#123;value: &#x27;0&#x27;, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成器对象作为可迭代对象</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> x <span class="keyword">of</span> <span class="title function_">generatorFn</span>())&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">b</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>yield 实现输入输出</strong></li>
</ol>
<p>yield接收next里的参数，除了第一个next, 其作用是 启动生成器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> * <span class="title function_">generatorFn</span>(<span class="params">initial</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(initial);</span><br><span class="line">    <span class="comment">//yield输入</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">yield</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">yield</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">yield</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>(<span class="string">&#x27;initial&#x27;</span>)</span><br><span class="line">g.<span class="title function_">next</span>(<span class="string">&#x27;a&#x27;</span>)     <span class="comment">//initial ,不会输出a</span></span><br><span class="line">g.<span class="title function_">next</span>(<span class="string">&#x27;b&#x27;</span>)     <span class="comment">//b</span></span><br><span class="line">g.<span class="title function_">next</span>(<span class="string">&#x27;c&#x27;</span>)     <span class="comment">//c</span></span><br><span class="line">g.<span class="title function_">next</span>(<span class="string">&#x27;d&#x27;</span>)	<span class="comment">//d</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>yield同时输入输出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> * <span class="title function_">generatorFn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">yield</span> <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = <span class="title function_">generatorFn</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>());      <span class="comment">//&#123;value: &#x27;foo&#x27;, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">next</span>(<span class="string">&#x27;x00&#x27;</span>)); <span class="comment">//&#123;value: &#x27;x00&#x27;, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="yield-1"><a href="#yield-1" class="headerlink" title="yield*"></a><strong>yield</strong>*</h2><p>增强yield行为，让他可以迭代一个可迭代对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> * <span class="title function_">generatorFn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">yield</span>* [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>适合作默认迭代器</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">value</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    * [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()&#123;</span><br><span class="line">        <span class="keyword">yield</span>* <span class="variable language_">this</span>.<span class="property">value</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> f <span class="keyword">of</span> <span class="keyword">new</span> <span class="title class_">Foo</span>())&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="配合-Promise-实现异步"><a href="#配合-Promise-实现异步" class="headerlink" title="配合 Promise 实现异步"></a>配合 <code>Promise</code> 实现异步</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">readFileWithGen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;  </span><br><span class="line">    <span class="keyword">const</span> content1 = <span class="keyword">yield</span> <span class="title function_">readFileWithPromise</span>(<span class="string">&#x27;/etc/passwd&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(content1)</span><br><span class="line">    <span class="keyword">const</span> content2 = <span class="keyword">yield</span> <span class="title function_">readFileWithPromise</span>(<span class="string">&#x27;/etc/profile&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(content2)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;fail&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">run</span> = generator =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> g = <span class="title function_">generator</span>()</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">next</span> = res =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> result = g.<span class="title function_">next</span>(res)</span><br><span class="line">      <span class="keyword">if</span> (result.<span class="property">done</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">resolve</span>(result.<span class="property">value</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      result.<span class="property">value</span></span><br><span class="line">        .<span class="title function_">then</span>(</span><br><span class="line">          next,</span><br><span class="line">          <span class="function"><span class="params">err</span> =&gt;</span> <span class="title function_">reject</span>(gen.<span class="keyword">throw</span>(err).<span class="property">value</span>)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">next</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">run</span>(readFileWithGen)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="/2024/03/26/%E7%94%9F%E6%88%90%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5">🔗async&#x2F;await原理和co函数实现</a></p>
<h2 id="实现async-await"><a href="#实现async-await" class="headerlink" title="实现async&#x2F;await"></a>实现async&#x2F;await</h2><ul>
<li>async 会把函数变成Promise对象</li>
<li>async函数就是generator 函数，把  <code>function*</code> 替换成 <code>async function</code> ，把 <code>yield</code> 替换成 <code>await</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getFetch</span> = (<span class="params">nums</span>) =&gt;</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(nums + <span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一个异步操作依赖于上一步异步操作的返回值。</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">gen</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res1 = <span class="keyword">yield</span> <span class="title function_">getFetch</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> res2 = <span class="keyword">yield</span> <span class="title function_">getFetch</span>(res1);</span><br><span class="line">  <span class="keyword">let</span> res3 = <span class="keyword">yield</span> <span class="title function_">getFetch</span>(res2);</span><br><span class="line">  <span class="keyword">return</span> res3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 让next函数递归执行</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myAsync</span>(<span class="params">gen</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">()=&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> g = <span class="title function_">gen</span>();</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">next</span> = (<span class="params">context</span>)=&gt;&#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;done, value&#125; = g.<span class="title function_">next</span>(context);</span><br><span class="line">      <span class="keyword">if</span>(done)</span><br><span class="line">        <span class="title function_">resolve</span>(value)</span><br><span class="line">      <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(value).<span class="title function_">then</span>(<span class="function"><span class="params">val</span>=&gt;</span><span class="title function_">next</span>(val))</span><br><span class="line">&#125;</span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>js红宝书</category>
      </categories>
      <tags>
        <tag>迭代器</tag>
        <tag>生成器</tag>
        <tag>async&amp;await</tag>
      </tags>
  </entry>
  <entry>
    <title>React学习笔记</title>
    <url>/2024/05/29/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="jsx-本质"><a href="#jsx-本质" class="headerlink" title="jsx 本质"></a>jsx 本质</h2><p>再js里写html &#x3D;&gt;  编译为 ReactDom对象，</p>
<blockquote>
<p>使用React.creatElement() 同样可以创建ReactDom对象</p>
</blockquote>
<p><strong>jsx里的模板解析</strong></p>
<ul>
<li>String, Number: 直接渲染</li>
<li>Boolean: 不渲染</li>
<li>null， undefined， function： 不渲染</li>
<li>Object：只能渲染<strong>ReactDom</strong> 对象</li>
<li><strong>Array</strong>: <strong>每一项</strong>都单独渲染</li>
<li>表达式： 会运行</li>
</ul>
<span id="more"></span>


<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;p onClick=&#123; handleClick.<span class="title function_">bind</span>(<span class="variable language_">this</span>) &#125;&gt;<span class="title class_">App</span>&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>this 最好用<code>bind</code>指向组件实例， 否则指向<code>undefined</code></li>
</ul>
<p><strong>传参</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"> &lt;p onClick=&#123; handleClick.<span class="title function_">bind</span>(<span class="variable language_">this</span>,a,b) &#125;&gt;<span class="title class_">App</span>&lt;/p&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params">a,b, event</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>事件对象默认在<strong>最后一个参数</strong></li>
<li>事件对象是React<strong>包装</strong>的<code>SyntheticBaseEvent</code><ul>
<li>原生事件对象 &#x3D; <code>SyntheticBaseEvent.nativeEvent</code></li>
</ul>
</li>
</ul>
<h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><p><strong>setState</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;&#125;, callback)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>传入一个对象，来和state <strong>浅合并</strong> </p>
<ul>
<li>通过 <code>Object.assign</code> 合并</li>
</ul>
</li>
<li><p>调用更新方法，更新视图</p>
<ul>
<li><strong>不管数据是否更新</strong></li>
<li>解决方法，组件基础<code>PureComponent</code></li>
</ul>
</li>
</ol>
<blockquote>
<ul>
<li><p>是一个<strong>异步方法</strong>, callback 是promise完成的回调</p>
</li>
<li><p>不要在render里调用setState</p>
</li>
</ul>
</blockquote>
<p><b style="color:red"><code>PureComponent</code> 有一个问题</b></p>
<p>如果更新<strong>引用类型</strong>，但是<strong>地址没变</strong>，也<strong>不</strong>会触发更新</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">arr</span>.<span class="title function_">push</span>(<span class="number">123</span>);</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>([...<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">arr</span>]) <span class="comment">//赋予一个新地址</span></span><br></pre></td></tr></table></figure>



<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>在react中，所有写在组件上的属性和子节点都被当作props</p>
<h3 id="props-验证"><a href="#props-验证" class="headerlink" title="props 验证"></a>props 验证</h3><p><strong>propTypes</strong></p>
<ol>
<li><strong>手写</strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// props验证</span></span><br><span class="line"><span class="title class_">Input</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">    <span class="title function_">val</span>(<span class="params">props</span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;validate&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> props.<span class="property">val</span> !== <span class="string">&quot;string&quot;</span>) <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&quot;val must be string!&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>利用库<code>proptypes</code></strong></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> proptypes <span class="keyword">from</span> <span class="string">&quot;proptypes&quot;</span>;</span><br><span class="line"><span class="title class_">Input</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">    <span class="attr">val</span>: proptypes.<span class="property">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="props-默认值"><a href="#props-默认值" class="headerlink" title="props 默认值"></a>props 默认值</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// props默认值</span></span><br><span class="line"><span class="title class_">Input</span>.<span class="property">defaultProps</span> = &#123;</span><br><span class="line">    <span class="attr">val</span>: <span class="string">&#x27;i am default&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><ul>
<li>通过<code>props.children</code>得到一个数组，里面包括所有插槽</li>
<li>通过传一个函数给子组件，实现作用域插槽</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">scopeSlot=&#123;(</span><br><span class="line">   <span class="function"><span class="params">scope</span> =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;scope.map(item =&gt; <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item&#125;</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>)&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure>



<h2 id="context"><a href="#context" class="headerlink" title="context"></a>context</h2><p>类似于vue的provider 和injected , 祖孙传值。</p>
<p>子组件必须用父组件传来的context，不能自己创建。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//GrandFather.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Context</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(); <span class="comment">// 1. 返回一个组件</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;&gt;</span> </span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">Context.Provider</span> <span class="attr">value</span>=<span class="string">&#123;xxx&#125;</span>&gt;</span> // 2. 只能传递value一个props</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Son</span>&gt;</span><span class="tag">&lt;/<span class="name">Son</span>&gt;</span>    </span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Context.Provider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/&gt;</span></span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Son.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Context</span> <span class="keyword">from</span> <span class="string">&#x27;GrandFather.js&#x27;</span> <span class="comment">// 3. 导入Context组件</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Context.Consumer</span>&gt;</span> // 4. 使用 作用域插槽，传递一个函数过去</span></span><br><span class="line"><span class="language-xml">        &#123;</span></span><br><span class="line"><span class="language-xml">               (value)=&gt;&#123;&#125;</span></span><br><span class="line"><span class="language-xml">          &#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Context.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>





<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>只有在<code>componentDidMount</code> 之后才能获取到</p>
<p>可以获取<strong>dom</strong> 或者 <strong>类组件实例</strong></p>
<p>函数组件无法获取到</p>
<ul>
<li><code>this.refs</code></li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;div ref=<span class="string">&quot;container&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">...</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">refs</span>.<span class="property">container</span> </span><br></pre></td></tr></table></figure>

<ul>
<li><code>createRef</code> &#x2F; <code>useRef</code></li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> container = <span class="title class_">React</span>.<span class="title function_">createRef</span>()</span><br><span class="line">&lt;div ref=&#123; container &#125;&gt;&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><p><strong>class类名设置</strong></p>
<ol>
<li>必须写成<code>className</code></li>
<li>类名和样式写在css文件里</li>
<li><u>必须接受一个字符串</u></li>
</ol>
<p><strong>style行内样式</strong></p>
<ol>
<li>必须写成<u>对象</u></li>
</ol>
<p>js引入css是全局生效的, 所以要css模块化</p>
<ol>
<li><p><strong>手写</strong></p>
</li>
<li><p>命名css <code>comName.module.css</code></p>
</li>
<li><p>导入<code>import comStyle from &#39;./css/comName.module.css&#39;</code></p>
</li>
<li><p>使用 <code>className=&#123; comStyle.xxx &#125;</code></p>
</li>
</ol>
<blockquote>
<p>css文件里只有类选择器才会被导出</p>
</blockquote>
<ol start="2">
<li><strong>库<code>classnames</code></strong></li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> classnames <span class="keyword">from</span> <span class="string">&#x27;classnames&#x27;</span></span><br><span class="line">...</span><br><span class="line">&lt;div className=&#123;<span class="title function_">classnames</span>(&#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">box</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;)&#125;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>用法同vue</p>
<p>如何配合css模块化？</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> classnames <span class="keyword">from</span> <span class="string">&#x27;classnames/bind&#x27;</span></span><br><span class="line"><span class="keyword">const</span> bindClassnames = classnames.<span class="title function_">bind</span>(comStyle)</span><br></pre></td></tr></table></figure>



<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p><img src="/2024/05/29/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240322162712453.png" alt="image-20240322162712453"></p>
<p><strong>static getDerivedStateFromProps(props, state)</strong></p>
<p>它应该返回一个对象来更新 state，或者返回 <code>null</code> 就不更新任何内容。</p>
<p><strong>componentDidMount</strong></p>
<p>如果您定义了 componentDidMount 方法，当您的组件被添加（安装）到屏幕上时，React 将调用该方法。这是开始获取数据、设置订阅或操作 DOM 节点的常用位置。</p>
<p>如果您实现了 componentDidMount，通常还需要实现其他生命周期方法，以避免出现错误。例如，如果 componentDidMount 读取了一些状态或道具，你还必须实现 componentDidUpdate 来处理它们的变化，以及 componentWillUnmount 来清理 componentDidMount 正在做的事情。</p>
<blockquote>
<p>在 componentDidMount 中立即调用 setState，但最好还是尽量避免。它会触发一次额外的渲染</p>
</blockquote>
<p><strong>componentDidUpdate(prevProps, prevState, snapshot?)</strong></p>
<ul>
<li><code>@return undefined </code></li>
</ul>
<p>在更新props和重新渲染组件后调用</p>
<blockquote>
<p>componentDidUpdate 内部的逻辑通常应封装在比较 this.props 和 prevProps 以及 this.state 和 prevState 的条件中。否则，就有可能产生无限循环。</p>
</blockquote>
<h4 id="react里的更新问题"><a href="#react里的更新问题" class="headerlink" title="react里的更新问题"></a>react里的更新问题</h4><p><strong>vue</strong></p>
<p>会收集依赖， 做到最小范围更新</p>
<p><strong>React</strong></p>
<p>没有依赖收集，会更新<strong>整个组件树</strong>，即会把子组件一起跟新</p>
<blockquote>
<p>子组件若用PureComponent则可以避免</p>
</blockquote>
<p>##严格模式 </p>
<p><strong>&lt;React.StrictMode&gt;</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line">root.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>只在开发时生效，生产时会去除。作用：</p>
<ol>
<li>检测一些危险操作（废弃或不推荐的api）</li>
<li>每个生命周期执行两次，以查找由于缺少 Effect 清理而引起的错误</li>
</ol>
<h2 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h2><ol>
<li><p>没有生命周期</p>
</li>
<li><p>没有this</p>
</li>
<li><p>通过hook完成各种操作（组合式api）</p>
<ul>
<li><p><code>useState(value)</code> </p>
</li>
<li><p><code>useEffect(fn, [])</code></p>
<ul>
<li>不传第数组相当于 <code>componentDidMount</code> 和 <code>componentDidUpdate</code></li>
<li>传一个空数组 相当于 <code>componentDidMount</code></li>
<li>传依赖数据 相当于 <code>watch</code> 且开启<code>immediate: true</code></li>
</ul>
</li>
<li><p><code>useMemo(fn, [])</code></p>
<ul>
<li>相当于 <code>computed</code>，也拥有缓存功能</li>
<li>有时也会缓存一个固定的对象，防止重新生成从而优化性能。</li>
</ul>
</li>
<li><p><code>useCallback(fn, [])</code></p>
<ul>
<li>缓存一个方法</li>
</ul>
</li>
<li><p><code>useRef</code> </p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="title function_">useRef</span>();</span><br><span class="line">...</span><br><span class="line">&lt;div ref=&#123;div&#125;&gt;<span class="title class_">Hello</span> <span class="title class_">World</span>&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>useContext</code></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Context1</span> <span class="keyword">from</span> <span class="string">&#x27;./Father.jsx&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 更简便的消费context</span></span><br><span class="line"><span class="keyword">const</span> ctx1 = <span class="title function_">useContext</span>(<span class="title class_">Context1</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>函数本身相当于render函数</p>
</li>
<li><p>props在函数第一个参数接收</p>
</li>
</ol>
<div style="color:red"><b>注意：</b></div>

<blockquote>
<ol>
<li>函数式组件相当于render函数，不能直接在render函数里修改state</li>
<li>函数式组件更新规则相当于PureComponent，必须地址改变才能检测到更新</li>
</ol>
<p>​      </p>
</blockquote>
<h1 id="React-性能"><a href="#React-性能" class="headerlink" title="React 性能"></a>React 性能</h1><p>React没有像vue一样的依赖收集可以精准定位需要更新视图的地方。所以React的更新时diff要比较的范围更大更耗时。包括整个子树，尽管部分子树没有数据改变。</p>
<p>那么解决性能问题的方案就是<code>Fiber —— 一种时间切片策略</code> :</p>
<p>​	先计算一部分，再更新这部分视图。下一帧的时间继续这个过程。</p>
<p><img src="/2024/05/29/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240513234636932.png" alt="image-20240513234636932"></p>
<h2 id="Fiber"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber</h2><p>每个<strong>组件被转化为Fiber结构</strong>的对象，从而获得从中断位置继续计算的能力。</p>
<p>每个Fiber结构拥有几个指针指向父组件、子组件、兄弟组件</p>
<p><img src="/2024/05/29/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240513235443321.png" alt="image-20240513235443321"></p>
<h2 id="React-memo"><a href="#React-memo" class="headerlink" title="React.memo"></a>React.memo</h2><p>高阶组件，用于缓存一个组件。防止父组件跟新导致子组件一起跟新。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Son</span> <span class="keyword">from</span> <span class="string">&#x27;./Son.jsx&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MemoSon</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="title class_">Son</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">MemoSon</span>&gt;</span><span class="tag">&lt;/<span class="name">MemoSon</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h1><ul>
<li>React-router 服务端渲染</li>
<li>React-router-dom 浏览器端</li>
<li>React-router-native RN开发</li>
</ul>
<h2 id="使用步骤-—-第一种"><a href="#使用步骤-—-第一种" class="headerlink" title="使用步骤 — 第一种"></a>使用步骤 — 第一种</h2><ol>
<li><p>用 <code>BroserRouter</code> 或 <code>HashRouter</code> 包裹根组件</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">BrowserRouter</span>&gt;</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">BrowserRouter</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用 <code>Routes </code>组件定义路由显示区域 — 类似与 <code>&lt;router-view&gt;</code></p>
<ul>
<li>V5版本是 switch</li>
</ul>
</li>
<li><p>用 <code>Route</code> 组件定义路由规则</p>
<ul>
<li>接受两个props： </li>
<li>path  指定路由匹配的地址</li>
<li>Component 指定此路由匹配的组件</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/path1&quot;</span> <span class="title class_">Component</span>=&#123;<span class="title class_">Page1</span>&#125;&gt;&lt;<span class="regexp">/Route&gt; /</span>*v5版本写法，v6也兼容*/</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/path2&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Page2</span>&gt;</span><span class="tag">&lt;/<span class="name">Page2</span>&gt;</span>&#125;&gt;<span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span> </span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>NavLink</code> 或 <code>Link </code>组件定义跳转链接</p>
<ul>
<li><p>都被渲染为a标签</p>
</li>
<li><p>NavLink：在当前匹配的a标签增加 active 类名</p>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Link</span> to=<span class="string">&quot;/path1&quot;</span>&#125;&gt;&#123;user.<span class="property">name</span>&#125;&lt;/<span class="title class_">Link</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>Routes里只能放Route，Route也只能放Routes里</p>
</blockquote>
<h2 id="使用步骤-—-第二种"><a href="#使用步骤-—-第二种" class="headerlink" title="使用步骤 — 第二种"></a>使用步骤 — 第二种</h2><p>这种类似vue-router</p>
<ol>
<li><p><code>createBrowserRouter</code></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">createBrowserRouter</span>([&#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">App</span>&gt;</span><span class="tag">&lt;/<span class="name">App</span>&gt;</span></span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;page1/:id&#x27;</span>, <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Page1</span> /&gt;</span></span> &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;page2&#x27;</span>, <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Page2</span> /&gt;</span></span> &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;page3&#x27;</span>, <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Page3</span> /&gt;</span></span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&lt;RouterProvider&gt;</code></p>
</li>
</ol>
   <figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)).<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">RouterProvider</span> <span class="attr">router</span>=<span class="string">&#123;router&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">RouterProvider</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>&lt;Outlet&gt;</code> 等同于<code>&lt;router-view&gt;</code></li>
</ol>
<h2 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h2><ol>
<li>声明</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/path1/:id&quot;</span> element&#123;<span class="language-xml"><span class="tag">&lt;<span class="name">Page1</span>&gt;</span><span class="tag">&lt;/<span class="name">Page1</span>&gt;</span></span>&#125;&gt;&lt;/<span class="title class_">Route</span>&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>获取</li>
</ol>
<table>
<thead>
<tr>
<th>Router版本</th>
<th>params参数</th>
<th>query参数</th>
<th>location信息</th>
</tr>
</thead>
<tbody><tr>
<td><strong>V6</strong></td>
<td>useParams</td>
<td>useSearchParams</td>
<td>useLocation</td>
</tr>
<tr>
<td>V5</td>
<td>this.props.match.params</td>
<td>this.props.location.search</td>
<td>this.props.location.state</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>useParams</strong>:  <code>const &#123; id &#125; = useParams()</code></p>
</li>
<li><p><strong>useSearchParams</strong>: <code>const [searchParams, setSearchParams] = useSearchParams()</code></p>
<ul>
<li><code>searchParams</code> 是一个对象拥有 <code>size</code>属性， <code>get</code> <code>getAll</code> <code>has</code> 方法</li>
<li><code>setSearchParams(URLSearchParamsInit, NavigateOptions )</code> 是一个方法,用于修改query参数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setSearchParams</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: [<span class="string">&#x27;aa&#x27;</span>,<span class="string">&#x27;11&#x27;</span>],</span><br><span class="line">    <span class="attr">sex</span>: <span class="string">&#x27;famale&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>useLocation</strong>: <code>const location = useLocation()</code></p>
<ul>
<li><code>location</code>是一个对象拥有<code>hash</code> <code>key</code> <code>pathname</code> <code>search</code> <code>state</code> 属性</li>
</ul>
</li>
</ul>
<h2 id="编程式路由导航控制"><a href="#编程式路由导航控制" class="headerlink" title="编程式路由导航控制"></a>编程式路由导航控制</h2><table>
<thead>
<tr>
<th>Router版本</th>
<th>跳转方法</th>
</tr>
</thead>
<tbody><tr>
<td>V6</td>
<td>useNavigate()  或 <code>&lt;Navigate&gt;</code></td>
</tr>
<tr>
<td>V5</td>
<td>this.props.history.push()</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>useNavigate</strong>: </p>
<ul>
<li><p><code>navigator(To, NavigateOptions?)</code> </p>
</li>
<li><p><code>navigator(delta: Number)</code> 表示前进或后退detal步</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> navigator = <span class="title function_">useNavigate</span>();</span><br><span class="line"><span class="title function_">navigator</span>(&#123;</span><br><span class="line">    <span class="attr">pathname</span>: <span class="string">&#x27;/page3&#x27;</span>,</span><br><span class="line">    <span class="attr">search</span>: <span class="string">&#x27;?a=1&amp;b=2&amp;c=3&#x27;</span>,</span><br><span class="line">    <span class="attr">hash</span>: <span class="string">&#x27;#hash_value&#x27;</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="attr">replace</span>: <span class="literal">true</span>,  <span class="comment">//替换历史记录</span></span><br><span class="line">    <span class="attr">state</span>: &#123;    <span class="comment">//meta数据, 在 useLocation().state 里可以获取</span></span><br><span class="line">        <span class="attr">needAuth</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">relative</span>: <span class="string">&#x27;route&#x27;</span>, <span class="comment">//设置导航的相对类型 &#x27;route&#x27;默认 | &#x27;path&#x27;</span></span><br><span class="line">    <span class="attr">preventScrollReset</span>: <span class="literal">true</span>, <span class="comment">//不重置滚动位置</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>相对于route还是path：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;contacts/:id/edit&quot;</span> element=&#123;<span class="language-xml"><span class="tag">&lt;<span class="name">EditContact</span> /&gt;</span></span>&#125; /&gt;</span><br><span class="line"><span class="comment">/* 在EidtContact组件中调用 */</span></span><br><span class="line"><span class="comment">//被导航到 /contacts  </span></span><br><span class="line"><span class="title function_">navigator</span>(<span class="string">&#x27;..&#x27;</span>, &#123;<span class="attr">relative</span>: <span class="string">&#x27;route&#x27;</span>&#125;)</span><br><span class="line"><span class="comment">//被导航到 /contacts/:id</span></span><br><span class="line"><span class="title function_">navigator</span>(<span class="string">&#x27;..&#x27;</span>,&#123;<span class="attr">relative</span>: <span class="string">&#x27;path&#x27;</span>&#125;) </span><br></pre></td></tr></table></figure>

</blockquote>
<h2 id="组件包装器"><a href="#组件包装器" class="headerlink" title="组件包装器"></a>组件包装器</h2><p><code>&lt;Navigate&gt;</code> 组件是 useNavigate的组件包装器, 接受与props相同的参数</p>
<p>用于：</p>
<ul>
<li>当你在类组件中不能使用钩子</li>
<li>在某些情况下你需要在渲染时而不是响应事件时进行导航</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Routes</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">HomePage</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">LoginPage</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/redirect&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Navigate</span> <span class="attr">to</span>=<span class="string">&quot;/login&quot;</span> <span class="attr">replace</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line">&lt;/<span class="title class_">Routes</span>&gt;</span><br></pre></td></tr></table></figure>



<h2 id="异步路由"><a href="#异步路由" class="headerlink" title="异步路由"></a>异步路由</h2><ol>
<li>lazy包装动态导入</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; lazy &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">const</span> asyncPage = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./pages/asyncPage&#x27;</span>)) </span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: Page3要默认导出</p>
</blockquote>
<ol start="2">
<li>Suspense组件包装Routes</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Suspense</span> fallback=&#123;<span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>loading...<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>&#125;&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/asyncPage&#x27;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">asyncPage</span>&gt;</span><span class="tag">&lt;/<span class="name">asyncPage</span>&gt;</span>&#125;&gt;<span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Suspense</span>&gt;</span><br></pre></td></tr></table></figure>

<h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><p>react没有专门状态管理库，都是js通用的，所以对于数据的修改不能触发更新，需要使用其他工具。</p>
<p><img src="/2024/05/29/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240519003125332.png" alt="image-20240519003125332"></p>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol>
<li>利用react-redux引入store</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"># index.<span class="property">js</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Provider</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store/&#x27;</span></span><br><span class="line"><span class="title class_">ReactDom</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)).<span class="title function_">render</span>(</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">App</span>&gt;</span><span class="tag">&lt;/<span class="name">App</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>利用redux创建store</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># store/index.<span class="property">js</span></span><br><span class="line"><span class="keyword">import</span> &#123;legacy_createStore <span class="keyword">as</span> createStore&#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="comment">// 1. 创建仓库</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">msgStore</span>(<span class="params">state=&#123;&#125;, action</span>)&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;changeMsg&#x27;</span>:</span><br><span class="line">        	<span class="keyword">return</span> &#123; ...state, <span class="attr">msg</span>: action.<span class="property">payload</span> &#125;;</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 创建store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">createStore</span>(msgStore);</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>state通过默认参数初始化</li>
<li>action就是每次dispatch传递的对象</li>
<li>case 必须返回一个新对象</li>
<li>default必须要有</li>
</ol>
</blockquote>
<ol start="3">
<li><p>通过react-redux使用store</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Test</span>(<span class="params">props</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;&gt;</span><span class="tag">&lt;/&gt;</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">connect</span>()(<span class="title class_">Test</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>connect 的<strong>作用</strong>是把redux创建的store与组件关联起来，使得对于store里数据的修改可以更新相关组件。</p>
<p><strong>原理</strong>是调用connect返回一个高阶组件，此高阶组件把store里的数据以props形式传递给组件，而对props的修改组件是会触发更新的。</p>
<p>connect 接收<strong>两个参数</strong>，都是函数且返回一个对象。</p>
</blockquote>
<ol>
<li><pre><code class="js">//必须返回一个对象。
connect(state=&gt;state)
//可用于筛选出可用对象
connect(state=&gt;&#123;
    return &#123;msg: state.msg&#125;
&#125;)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```js</span><br><span class="line">   //缺省第二个参数, 则会把dispatch传递给props</span><br><span class="line">   connect(state=&gt;state)</span><br><span class="line">   //.......调用........//</span><br><span class="line">   props.dispatch(&#123;</span><br><span class="line">       type: &#x27;changeMsg&#x27;,</span><br><span class="line">       payload: msg</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//封装方法，不再传递dispatch给props，而是传递定义了的方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">connect</span>(<span class="function"><span class="params">state</span> =&gt;</span> state, <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="title function_">changeMsg</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">            <span class="title function_">dispatch</span>(&#123;</span><br><span class="line">                <span class="attr">type</span>: <span class="string">&#x27;changeMsg&#x27;</span>,</span><br><span class="line">                <span class="attr">payload</span>: msg</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(<span class="title class_">Test</span>);</span><br><span class="line"><span class="comment">//.......调用........//</span></span><br><span class="line">props.<span class="title function_">changeMsg</span>(msg);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><ol>
<li><p>创建</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 导入不同模块仓库</span></span><br><span class="line"><span class="keyword">import</span> countStore <span class="keyword">from</span> <span class="string">&quot;./modules/module1&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> hiStore <span class="keyword">from</span> <span class="string">&quot;./modules/module2&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;legacy_createStore, combineReducers &#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"><span class="comment">// 2. combineReducers 合并多个模块仓库</span></span><br><span class="line"><span class="keyword">const</span> mainReducer =  <span class="title function_">combineReducers</span>(&#123;</span><br><span class="line">    countStore,</span><br><span class="line">    hiStore</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 3. 导出store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">legacy_createStore</span>(mainReducer)</span><br></pre></td></tr></table></figure>
</li>
<li><p>引入</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> mainStore <span class="keyword">from</span> <span class="string">&#x27;./store/mainReducer&#x27;</span></span><br><span class="line">&lt;<span class="title class_">Provider</span> store=&#123;mainStore&#125;&gt;&lt;/<span class="title class_">Provider</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ReduxTest</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(props)</span><br><span class="line">    <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>展示数据: count: &#123;props.count&#125; say: &#123;props.say&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-xml">            props.dispatch(&#123;</span></span><br><span class="line"><span class="language-xml">                type: &#x27;add&#x27;</span></span><br><span class="line"><span class="language-xml">            &#125;)</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;&gt;修改count<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-xml">            props.dispatch(&#123;</span></span><br><span class="line"><span class="language-xml">                type: &#x27;greeting&#x27;,</span></span><br><span class="line"><span class="language-xml">                payload: props.say+&#x27;!&#x27;</span></span><br><span class="line"><span class="language-xml">            &#125;)</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;&gt;修改say<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">connect</span>(<span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(state);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state.<span class="property">countStore</span>,</span><br><span class="line">        ...state.<span class="property">hiStore</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(<span class="title class_">ReduxTest</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>state 下有不同模块对象，每个模块对象下有自己的所有状态。</p>
<p>dispatch 是通用的，如果<u>不同模块都有同一个type</u>， 那么他们都会触发</p>
</blockquote>
</li>
</ol>
<h2 id="toolkit"><a href="#toolkit" class="headerlink" title="toolkit"></a>toolkit</h2><p> <code>@reduxjs/toolkit</code>是基于redux的</p>
<p>不同点：</p>
<blockquote>
<ol>
<li><p>默认模块化，需要创建切片再配置仓库</p>
</li>
<li><p>无需考虑type，用action生成器，接收一个参数payload，生成一个action</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Action</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">payload</span>: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">changeMsg</span>(<span class="params">payload: <span class="built_in">any</span></span>): <span class="title class_">Action</span></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="title function_">dispatch</span>(<span class="title function_">changeMsg</span>(<span class="string">&#x27;newMsg&#x27;</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>支持函数式组件里使用hooks取代connect</p>
</li>
</ol>
</blockquote>
<h3 id="1-建立仓库"><a href="#1-建立仓库" class="headerlink" title="1. 建立仓库"></a>1. 建立仓库</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createSlice, configStore&#125; <span class="keyword">from</span> <span class="string">&#x27;@reduxjs/toolkit&#x27;</span></span><br><span class="line"><span class="comment">//1. 建立切片</span></span><br><span class="line"><span class="keyword">const</span> msgSlice = <span class="title function_">createSlice</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;msgSlice&#x27;</span>,</span><br><span class="line">    <span class="attr">initialState</span>: &#123;</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">reducers</span>: &#123;</span><br><span class="line">        <span class="title function_">changeMsg</span>(<span class="params">state, action</span>)&#123;</span><br><span class="line">            state.<span class="property">msg</span> = action.<span class="property">payload</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//2. 配置仓库</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">configStore</span>(&#123;</span><br><span class="line">    <span class="attr">reducer</span>: &#123;</span><br><span class="line">        <span class="attr">msgStore</span>: msgSlice.<span class="property">reducer</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//3. 暴露action生成器方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> &#123; changeMsg &#125; = msgSlice.<span class="property">actions</span></span><br></pre></td></tr></table></figure>

<h3 id="2-引入仓库"><a href="#2-引入仓库" class="headerlink" title="2. 引入仓库"></a>2. 引入仓库</h3><p>同redux</p>
<h3 id="3-使用仓库"><a href="#3-使用仓库" class="headerlink" title="3. 使用仓库"></a>3. 使用仓库</h3><h4 id="一、connect"><a href="#一、connect" class="headerlink" title="一、connect"></a>一、connect</h4><p>同redux模块化</p>
<h4 id="二、hooks式"><a href="#二、hooks式" class="headerlink" title="二、hooks式"></a>二、hooks式</h4><p>此方法只用于函数式组件和redux-toolkit中</p>
<ul>
<li><code>useSelector</code> 选择state</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择单个</span></span><br><span class="line"><span class="keyword">const</span> count = <span class="title function_">useSelector</span>(<span class="function"><span class="params">state</span>=&gt;</span> state.<span class="property">countStore</span>.<span class="property">count</span>)</span><br><span class="line"><span class="comment">//选择多个</span></span><br><span class="line"><span class="keyword">const</span> &#123; count, msg, person &#125; = <span class="title function_">useSelector</span>(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">    ...state.<span class="property">countReducer</span>,</span><br><span class="line">    ...state.<span class="property">msgReducer</span>,</span><br><span class="line">    ...state.<span class="property">deepReducer</span>,</span><br><span class="line">&#125;), shallowEqual)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>useDispatch</code> 获取dispatch</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> dispatch = <span class="title function_">useDispatch</span>()</span><br></pre></td></tr></table></figure>



<h3 id="异步方法"><a href="#异步方法" class="headerlink" title="异步方法"></a>异步方法</h3><ol>
<li><p><code>createAsyncThunk</code> 创建异步方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> changeCountThunk = <span class="title function_">createAsyncThunk</span>(<span class="string">&#x27;countSlice/changeNumAsync&#x27;</span>, <span class="keyword">async</span> (params, thunkAPI) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(params)</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//暴露, 依旧是action生成器</span></span><br><span class="line"><span class="keyword">export</span> &#123;changeCountThunk&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>给指定的切片添加<code>extraReducers</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> countSlice = <span class="title function_">createSlice</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;countSlice&#x27;</span>,</span><br><span class="line">    <span class="attr">initialState</span>: &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;,</span><br><span class="line">    <span class="attr">reducers</span>: &#123;&#125;,</span><br><span class="line">    <span class="title function_">extraReducers</span>(<span class="params">builder</span>)&#123;</span><br><span class="line">        builder.<span class="title function_">addCase</span>(changeCountThunk.<span class="property">pending</span>, <span class="function">(<span class="params">state, action</span>)=&gt;</span>&#123;&#125;)</span><br><span class="line">        .<span class="title function_">addCase</span>(changeCountThunk.<span class="property">fulfilled</span>,<span class="function">(<span class="params">state, action</span>)=&gt;</span>&#123;</span><br><span class="line">            state.<span class="property">count</span> = action.<span class="property">payload</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_">addCase</span>(changeCountThunk.<span class="property">rejected</span>,<span class="function">(<span class="params">state, action</span>)=&gt;</span>&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><p>根据promise状态调用对应方法</p>
</li>
<li><p>Thunk的返回值会作为action.payload</p>
</li>
</ol>
</blockquote>
</li>
<li><p>调用该异步方法</p>
<p>同上</p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>koa2笔记</title>
    <url>/2023/10/11/koa2%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="一、Koa2安装"><a href="#一、Koa2安装" class="headerlink" title="一、Koa2安装"></a>一、Koa2安装</h2><p>创建一个空白目录，然后进入终端，并在终端对koa进行安装：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 项目初始化</span><br><span class="line">npm init -y</span><br><span class="line"></span><br><span class="line"># 安装koa2 </span><br><span class="line">npm i koa2 -S </span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="二、入口文件"><a href="#二、入口文件" class="headerlink" title="二、入口文件"></a>二、入口文件</h2><p>在项目根目录创建 <code>index.js</code> 文件，并在上一步操作中生成的 <code>package.json</code> 里配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node index.js&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ul>
<li><strong>app.use</strong>  <ul>
<li>use 传入的中间件被放入一个middleware 缓存队列中（数组），这个队列会经由 <code>koa-compose</code> 进行串联</li>
<li>会返回自身this，可以链式调用</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa2&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">9000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	解释下面这段代码：</span></span><br><span class="line"><span class="comment">	app.use()方法是：将给定的中间件方法添加到此应用程序。简单说就是调用中间件</span></span><br><span class="line"><span class="comment">	app.use() 返回 this, 因此可以链式表达</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> (ctx)=&gt;&#123;</span><br><span class="line">    <span class="comment">// ctx.body是ctx.response.body的简写</span></span><br><span class="line">    ctx.<span class="property">body</span> = <span class="string">&quot;Hello, Koa&quot;</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(port, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server is running at http://localhost:&#x27;</span>+port);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然后运行 <code>npm start</code> ，并在浏览器输入 <code>http://localhost:9000/</code> 即可看到页面效果。</p>
<h2 id="三、洋葱模型"><a href="#三、洋葱模型" class="headerlink" title="三、洋葱模型"></a>三、洋葱模型</h2><ul>
<li><code>middleWare</code>： 就是一个个独立的函数</li>
</ul>
<p>学Koa必须要了解 <code>洋葱模型</code> :</p>
<img src="https://segmentfault.com/img/bV6DZG/view?w=478&h=435" style="1px solid">

<p><code>Koa</code> 和 <code>Express</code> 都会使用到中间件，Express的中间件是顺序执行，从第一个中间件执行到最后一个中间件，发出响应：</p>
<img src="https://upload-images.jianshu.io/upload_images/3663059-b6acea9ec3f0a8f9.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/883/format/webp" style="border: 1px solid">

<p>Koa是从第一个中间件开始执行，遇到 <code>next</code> 进入下一个中间件，一直执行到最后一个中间件，在逆序，执行上一个中间件 <code>next</code> 之后的代码，一直到第一个中间件执行结束才发出响应。</p>
<img src="https://upload-images.jianshu.io/upload_images/3663059-03622ea2a9ffce2a.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/814/format/webp" style="border: 1px solid">

<p>对于这个洋葱模型，我们用代码来解释一下。假如把上面的代码改写成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa2&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">9000</span>;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> (ctx, next)=&gt;&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> (ctx)=&gt;&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(port, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server is running at http://localhost:&#x27;</span>+port);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>那么在浏览器刷新后，控制台得到的顺序是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>现在可以看到，我们通过 <code>next</code>可以先运行下个中间件，等中间件结束后，再继续运行当前 <code>next()</code> 之后的代码。</p>
<h2 id="四、路由基本使用"><a href="#四、路由基本使用" class="headerlink" title="四、路由基本使用"></a>四、路由基本使用</h2><p>当需要匹配不同路由时，可以安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i koa-router</span><br></pre></td></tr></table></figure>

<p>将 <code>index.js</code> 修改：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa2&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"><span class="comment">//导入中间件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Router</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>);</span><br><span class="line"><span class="comment">//实例化路由中间件</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line"><span class="comment">//初始化时 定义前缀</span></span><br><span class="line"><span class="comment">//const router = new Router(&#123;prefix: &#x27;/user&#x27;&#125;)</span></span><br><span class="line"><span class="keyword">const</span> port = <span class="number">9000</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	ctx.url === ctx.request.url</span></span><br><span class="line"><span class="comment">	ctx.method === ctx.request.method</span></span><br><span class="line"><span class="comment">	ctx.body === ctx.response.body</span></span><br><span class="line"><span class="comment">	ctx.status === ctx.response.status</span></span><br><span class="line"><span class="comment">	ctx.throw(404) //抛出404</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">async</span> (ctx)=&gt;&#123;</span><br><span class="line">    ctx.<span class="property">body</span> = <span class="string">&quot;首页&quot;</span>;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//使用路由中间件</span></span><br><span class="line"><span class="comment">//router.allowedMethods() 帮助返回401或501</span></span><br><span class="line">app.<span class="title function_">use</span>(router.<span class="title function_">routes</span>()).<span class="title function_">use</span>(router.<span class="title function_">allowedMethods</span>());</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(port, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Server is running at http://localhost:&#x27;</span>+port);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>此时，到浏览器刷新并在地址栏最后添加 <code>/list</code> 即可得到首页和列表页。</p>
<p>备注：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用router.routes()来组装匹配好的路由，返回一个合并好的中间件</span></span><br><span class="line"><span class="comment">// 调用router.allowedMethods()获得一个中间件，当发送了不符合的请求时，会返回 `405 Method Not Allowed` 或 `501 Not Implemented`</span></span><br><span class="line"></span><br><span class="line">allowedMethods方法可以做以下配置：</span><br><span class="line">app.<span class="title function_">use</span>(router.<span class="title function_">allowedMethods</span>(&#123; </span><br><span class="line">    <span class="comment">// throw: true, // 抛出错误，代替设置响应头状态</span></span><br><span class="line">    <span class="comment">// notImplemented: () =&gt; &#x27;不支持当前请求所需要的功能&#x27;,</span></span><br><span class="line">    <span class="comment">// methodNotAllowed: () =&gt; &#x27;不支持的请求方式&#x27;</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<h3 id="路由解析"><a href="#路由解析" class="headerlink" title="路由解析"></a>路由解析</h3><ul>
<li><p>GET请求参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://localhost:9000/user/123/hello</span></span><br><span class="line"><span class="comment">//1. get+params 获取路由中的参数</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/user/:id&#x27;</span>, <span class="function">(<span class="params">ctx</span>)=&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> res = &#123;...ctx.<span class="property">params</span>&#125;</span><br><span class="line">    ctx.<span class="property">body</span> = res</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// http://localhost:9000/user2?canshu1=111&amp;canshu2=222</span></span><br><span class="line"><span class="comment">//2. get+query 获取url中的参数</span></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/user2&#x27;</span>, <span class="function">(<span class="params">ctx</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = &#123;...ctx.<span class="property">query</span>&#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;res&#x27;</span>,res);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    ctx.<span class="property">body</span> = res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>POST请求参数 </p>
<ul>
<li>参数在请求体中, 利用中间件来解析请求体</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install koa-body </span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">const</span> &#123;koaBody&#125; = <span class="built_in">require</span>(<span class="string">&#x27;koa-body&#x27;</span>)</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">koaBody</span>())</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ctx.request.body</code> 来获取参数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// http://localhost:9000/post/a</span></span><br><span class="line"><span class="comment">/* urlencoded参数为：  param1:123</span></span><br><span class="line"><span class="comment">					param2:canshu2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/post/a&#x27;</span>,<span class="function">(<span class="params">ctx</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> req = ctx.<span class="property">request</span>.<span class="property">body</span></span><br><span class="line">    ctx.<span class="property">body</span> = req</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="koa-body-与-koa-bodyparse的区别"><a href="#koa-body-与-koa-bodyparse的区别" class="headerlink" title="koa-body 与 koa-bodyparse的区别"></a>koa-body 与 koa-bodyparse的区别</h4><p>koa-body和koa-bodyparser都是Koa框架的中间件，用于解析HTTP请求中的请求体。</p>
<ul>
<li><code>koa-body</code>解析的是JSON格式的请求体</li>
<li><code>koa-bodyparser</code>支持多种请求体的格式，例如JSON、form、text、CSV等</li>
</ul>
<h2 id="五、路由拆分"><a href="#五、路由拆分" class="headerlink" title="五、路由拆分"></a>五、路由拆分</h2><p>有时候我们需要拆分路由，比如：</p>
<p>列表页下所有的子路由（即前端请求的api）与首页所有的子路由想分开处理，那么就需要拆分路由。</p>
<h3 id="1、创建-router-文件夹"><a href="#1、创建-router-文件夹" class="headerlink" title="1、创建 router 文件夹"></a>1、创建 <code>router</code> 文件夹</h3><p>创建router文件夹，并在其中创建：<code>index.js</code> （路由总入口文件）、<code>home.js</code> （首页总路由文件）、<code>list.js</code> （列表页总路由文件）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># index.<span class="property">js</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="built_in">require</span>(<span class="string">&#x27;./router/index&#x27;</span>)</span><br><span class="line">app.<span class="title function_">use</span>(router.<span class="title function_">routes</span>(), router.<span class="title function_">allowedMethods</span>());</span><br><span class="line"></span><br><span class="line"># index.<span class="property">js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Router</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line"><span class="keyword">const</span> home = <span class="built_in">require</span>(<span class="string">&#x27;./home&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> list = <span class="built_in">require</span>(<span class="string">&#x27;./list&#x27;</span>)</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">use</span>(<span class="string">&#x27;/home&#x27;</span>, home.<span class="title function_">routes</span>(), home.<span class="title function_">allowedMethods</span>());</span><br><span class="line">router.<span class="title function_">use</span>(<span class="string">&#x27;/list&#x27;</span>, list.<span class="title function_">routes</span>(), list.<span class="title function_">allowedMethods</span>());</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># home.<span class="property">js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Router</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> home = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 &#x27;/&#x27; 就是指向 index.js 中的 /home</span></span><br><span class="line">home.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">        ctx.<span class="property">body</span> = <span class="string">&quot;首页&quot;</span>;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = home;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># list.<span class="property">js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Router</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> list = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line">list.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">async</span> (ctx)=&gt;&#123;</span><br><span class="line">    ctx.<span class="property">body</span> = <span class="string">&quot;列表页&quot;</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = list;</span><br></pre></td></tr></table></figure>

<p>到浏览器刷新 <code>localhost:9000/home</code> 与 <code>localhost:9000/list</code> 即可得到首页与列表页。</p>
<h3 id="2、路由重定向"><a href="#2、路由重定向" class="headerlink" title="2、路由重定向"></a>2、路由重定向</h3><p>那么有同学会问了，如果我想直接从 <code>localhost:9000</code> 重定向到 <code>localhost:9000/home</code> 该怎么办？</p>
<p>我们可以在 <code>router/index.js</code> 中做如下配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.<span class="title function_">use</span>(<span class="string">&#x27;/home&#x27;</span>, home.<span class="title function_">routes</span>(), home.<span class="title function_">allowedMethods</span>());</span><br><span class="line">...</span><br><span class="line">router.<span class="title function_">redirect</span>(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;/home&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="3、404无效路由"><a href="#3、404无效路由" class="headerlink" title="3、404无效路由"></a>3、404无效路由</h3><p>如果被访问到无效路由，那么我们可以统一返回404页面：</p>
<p>在 <code>router</code> 下 <code>errorPage.js</code> :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Router</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> errorPage = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line">errorPage.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">    ctx.<span class="property">body</span> = <span class="string">&quot;访问页面不存在&quot;</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = errorPage;</span><br></pre></td></tr></table></figure>

<p>在 <code>index.js</code> 中引用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配不到页面的全部跳转去404</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">parseInt</span>(ctx.<span class="property">status</span>) === <span class="number">404</span>) &#123;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="title function_">redirect</span>(<span class="string">&quot;/404&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">use</span>(router.<span class="title function_">routes</span>(), router.<span class="title function_">allowedMethods</span>());</span><br></pre></td></tr></table></figure>

<h2 id="六、统一异常处理（可选）"><a href="#六、统一异常处理（可选）" class="headerlink" title="六、统一异常处理（可选）"></a>六、统一异常处理（可选）</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><h4 id="1-非原生异常处理"><a href="#1-非原生异常处理" class="headerlink" title="1. 非原生异常处理"></a>1. 非原生异常处理</h4><ul>
<li>404 : 请求资源找不到，或者<code>ctx.body</code>为空</li>
<li>500: 服务器运行时错误❌</li>
<li><code>ctx.throw()</code>手动抛出 或者直接<code>throw()</code><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.<span class="keyword">throw</span>([status], [msg], [properties])</span><br><span class="line"><span class="comment">//[status]： 响应码</span></span><br><span class="line"><span class="comment">//[msg]: 响应消息</span></span><br></pre></td></tr></table></figure></li>
</ul>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//解决不能被app.on 捕获到的问题</span></span><br><span class="line"><span class="comment">//不要与原生on/emit同时使用</span></span><br><span class="line"><span class="keyword">const</span> error = <span class="built_in">require</span>(<span class="string">&#x27;koa-json-error&#x27;</span>)</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">error</span>())</span><br><span class="line"><span class="comment">//返回json格式</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<pre><code> * 生产环境避免抛出stack
</code></pre>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 跨平台</span></span><br><span class="line">npm i cross-env </span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//package.json中</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;prod&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cross-env NODE_ENV=production node src/&quot;</span> <span class="comment">//生产环境变量NODE_ENV</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">error</span>(&#123;     <span class="comment">//高级使用（配合生产环境，避免暴露stack）</span></span><br><span class="line">    <span class="comment">/*format: (err)=&gt; &#123;</span></span><br><span class="line"><span class="comment">        return &#123;code: err.status, message: err.message, stack: err.stack&#125;</span></span><br><span class="line"><span class="comment">    &#125;,*/</span> </span><br><span class="line">    <span class="attr">postFormat</span>: <span class="function">(<span class="params">err, obj</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;stack, ...rest&#125; = obj</span><br><span class="line">        <span class="keyword">return</span> process.<span class="property">env</span>.<span class="property">NODE_ENV</span> == <span class="string">&#x27;production&#x27;</span>? <span class="attr">rest</span>: obj</span><br><span class="line">    &#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
<h4 id="2-原生异常处理"><a href="#2-原生异常处理" class="headerlink" title="2. 原生异常处理"></a>2. 原生异常处理</h4><ul>
<li><code>on</code>监听异常</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//监听错误（ctx.app.emit(&#x27;error&#x27;, &#123;&#125;)）,捕获到错误后浏览器状态码为200</span></span><br><span class="line"></span><br><span class="line">app.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">error,ctx</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(error);</span><br><span class="line">    ctx.<span class="property">body</span> = error</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>emit </code>抛出错误</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.<span class="property">app</span>.<span class="title function_">emit</span>(<span class="string">&#x27;error&#x27;</span>,&#123;<span class="attr">code</span>: <span class="number">404</span>,<span class="attr">message</span>: <span class="string">&#x27;resouse not found&#x27;</span>, &#125;,ctx)</span><br><span class="line"><span class="comment">//ctx.throw 无法被on监听</span></span><br><span class="line">ctx.<span class="keyword">throw</span>(<span class="number">402</span>)</span><br></pre></td></tr></table></figure>

<p>  ​</p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>作为后端开发，我们经常需要统一异常处理，避免每次都要自己手写404或200进行返回，因此我们可以创建 <code>utils/errorHandler.js</code> ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 统一异常处理</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">    app.<span class="title function_">use</span>(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> status = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> fileName = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">            status = ctx.<span class="property">status</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">            <span class="comment">//console.log(err);</span></span><br><span class="line">            status = <span class="number">500</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(status &gt;= <span class="number">400</span>)&#123;</span><br><span class="line">            <span class="keyword">switch</span>(status)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">400</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">404</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="number">500</span>:</span><br><span class="line">                    fileName = status;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="attr">default</span>:</span><br><span class="line">                    fileName = <span class="string">&quot;other&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.<span class="property">response</span>.<span class="property">status</span> = status;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(fileName);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 <code>index.js</code> 中引入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> errorHandler = <span class="built_in">require</span>(<span class="string">&#x27;./utils/errorHandler.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(router.<span class="title function_">routes</span>(), router.<span class="title function_">allowedMethods</span>());</span><br><span class="line">...</span><br><span class="line"><span class="title function_">errorHandler</span>(app);</span><br></pre></td></tr></table></figure>

<p>其实这一块不写关系也不大，但最好还是加上。</p>
<h2 id="七、操作mysql函数封装"><a href="#七、操作mysql函数封装" class="headerlink" title="七、操作mysql函数封装"></a>七、操作mysql函数封装</h2><p>这里已经给大家直接封装好了一个库，专门用来操作mysql的。至于mysql的学习，将在独立的mysql教程中呈现。</p>
<p>首先，项目内安装 <code>mysql</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">yarn add mysql</span><br></pre></td></tr></table></figure>

<p>在<code>/src/utils/db.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">&#x27;mysql&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pool = mysql.<span class="title function_">createPool</span>(&#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">3306</span>,</span><br><span class="line">    <span class="attr">database</span>: <span class="string">&#x27;mytest&#x27;</span>,</span><br><span class="line">    <span class="attr">user</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&#x27;252238Lzy&#x27;</span>,</span><br><span class="line">    <span class="attr">multipleStatements</span>: <span class="literal">true</span> <span class="comment">//允许一次执行多条sql</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> query = <span class="keyword">function</span> (<span class="params">sql, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        pool.<span class="title function_">getConnection</span>(<span class="keyword">function</span> (<span class="params">err, connection</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (err) <span class="title function_">reject</span>(err)</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                connection.<span class="title function_">query</span>(sql, <span class="keyword">function</span> (<span class="params">err, rows</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (err) <span class="title function_">reject</span>(err)</span><br><span class="line">                    <span class="keyword">else</span> <span class="title function_">resolve</span>(rows)</span><br><span class="line">                    connection.<span class="title function_">release</span>()</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = query</span><br></pre></td></tr></table></figure>

<p>在 <code>/src/sql/userSql.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> query = <span class="built_in">require</span>(<span class="string">&#x27;../utils/db&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> findUser = <span class="keyword">function</span> (<span class="params">id</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> _sql = <span class="string">`select * from users where id=<span class="subst">$&#123;id&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">query</span>(_sql)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    findUser</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八、后端允许跨域"><a href="#八、后端允许跨域" class="headerlink" title="八、后端允许跨域"></a>八、后端允许跨域</h2><p>前端想跨域，可以设置proxy。如果后端允许跨域，可以如下操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装koa2-cors</span></span><br><span class="line">cnpm i koa2-cors</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;koa2-cors&#x27;</span>)</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cors</span>())</span><br></pre></td></tr></table></figure>

<h2 id="九、读取静态资源文件"><a href="#九、读取静态资源文件" class="headerlink" title="九、读取静态资源文件"></a>九、读取静态资源文件</h2><p>首先，在项目的根目录下创建 <code>assets</code> 后，将图片资源文件夹 <code>images</code> 放到其中，并且执行以下操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 安装koa-static</span></span><br><span class="line">cnpm install koa-<span class="keyword">static</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa-static&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取静态资源文件夹</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">static</span>(path.<span class="title function_">join</span>(__dirname+<span class="string">&#x27;/assets&#x27;</span>)));</span><br><span class="line">...</span><br><span class="line">app.<span class="title function_">use</span>(router.<span class="title function_">routes</span>(), router.<span class="title function_">allowedMethods</span>())</span><br></pre></td></tr></table></figure>

<p>假设其中有一张图片叫做 <code>banner1.png</code>，那么我们打开浏览器，访问：<code>http://localhost:5050/images/banner1.png</code> 即可得到图片。这里注意：</p>
<blockquote>
<p>路径上不需要写assets，因为我们已经指定了访问资源时， <a href="http://localhost:5050/">http://localhost:5050</a> 自动指向 assets 文件夹。</p>
</blockquote>
<p>由此，我们知道数据库中图片的地址只需要填写 <code>/images/banner1.png</code> 即可。</p>
<h2 id="十、mysql录入数据"><a href="#十、mysql录入数据" class="headerlink" title="十、mysql录入数据"></a>十、mysql录入数据</h2><p>请参考当前目录下的《Chapter2-mysql2操作.md》。</p>
<h2 id="十一、POST请求"><a href="#十一、POST请求" class="headerlink" title="十一、POST请求"></a>十一、POST请求</h2><p>我们以登录举例讲post请求。</p>
<p>这里规定：前端发送 账号+密码 到后端，如果账号不存在于数据库，则注册账号。</p>
<p>如果账号存在于数据库中，则验证密码。</p>
<p>验证密码通过或注册账号成功，都返回token给前端。</p>
<h3 id="1、建表"><a href="#1、建表" class="headerlink" title="1、建表"></a>1、建表</h3><p>设定字段为account和pwd</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> users (</span><br><span class="line">	id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">	account <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;账号&#x27;</span>,</span><br><span class="line">	pwd <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  token LONGTEXT <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;令牌&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="2、form表单页面"><a href="#2、form表单页面" class="headerlink" title="2、form表单页面"></a>2、form表单页面</h3><p>在 <code>assets</code> 下创建 <code>index.html</code> ：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;account&quot;</span>&gt;</span>账号<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">name</span>=<span class="string">&quot;account&quot;</span> <span class="attr">class</span>=<span class="string">&quot;account&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入账号&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;pwd&quot;</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">class</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入密码&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>登录/注册<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    $(<span class="string">&#x27;.btn&#x27;</span>).<span class="title function_">click</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">        $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">url</span>: <span class="string">&quot;/login/register&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">account</span>: $(<span class="string">&#x27;.account&#x27;</span>).<span class="title function_">val</span>(),</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">pwd</span>: $(<span class="string">&#x27;.pwd&#x27;</span>).<span class="title function_">val</span>()</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">success</span>(<span class="params">res</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">error</span>(<span class="params">err</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在浏览器直接访问 <code>http://localhost:5050/index.html</code> 即可进入表单页。</p>
<h3 id="3、安装中间件"><a href="#3、安装中间件" class="headerlink" title="3、安装中间件"></a>3、安装中间件</h3><p>安装 <code>koa-bodyparser</code> 与 <code>jsonwebtoken</code> 中间件:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// koa-bodyparser用于获取post请求数据</span></span><br><span class="line">cnpm install koa-bodyparser --save</span><br><span class="line"></span><br><span class="line"><span class="comment">// jsonwebtoken用于生成token</span></span><br><span class="line">cnpm install jsonwebtoken --save</span><br></pre></td></tr></table></figure>

<h4 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h4><h5 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h5><ol>
<li><p>前端把表单数据发送给服务器（同过post+http，最好是SSL+https）</p>
</li>
<li><p>服务器把token当作登录成功的返回</p>
</li>
<li><p>浏览器把token存在<code>localStorage</code>或者<code>sessionStorage</code>或者<code>cookie</code>中，退出登录时让浏览器删除token</p>
<ul>
<li>以后每次进入页面（main.js中）先从本地读取token，若存在则修改vuex中登陆状态</li>
</ul>
</li>
<li><p>前端在每次请求时将token放入http Header中的Authorization位。</p>
<ul>
<li><p>Authorization: Bearer token </p>
<ul>
<li>符合w3c规范，指明认证规范</li>
</ul>
</li>
<li><p>解决XSS 跨站脚本攻击 和XSRF问题 跨站点请求伪造</p>
</li>
</ul>
</li>
<li><p>后端检查：签名正确，token是否过期</p>
</li>
<li><p>后端解析出token中包含的用户id来进行操作</p>
</li>
</ol>
<h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h6><ol>
<li><code>jwt</code>生成的token由 <code>head.payload.signature</code>组成<ol>
<li>header:  保存签名算法</li>
<li>payload： 存放数据</li>
<li>signature：根据header、payload、密钥加密得出</li>
</ol>
</li>
<li>密钥存在服务器中，只有服务器知道</li>
</ol>
<h5 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用了callback会当作异步函数，不用则是同步函数返回token值</span></span><br><span class="line"><span class="keyword">const</span> token = jwt.<span class="title function_">sign</span>(&#123; account &#125;, private_key [, &#123; <span class="attr">expiresIn</span>: <span class="string">&#x27;30s&#x27;</span> &#125;, callback])</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> info = jwt.<span class="title function_">verify</span>(token, private_key)</span><br><span class="line"><span class="comment">//访问： info.account</span></span><br></pre></td></tr></table></figure>



<h3 id="4、添加post接口"><a href="#4、添加post接口" class="headerlink" title="4、添加post接口"></a>4、添加post接口</h3><p>在 <code>router/login.js</code> 中加入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;koa-bodyparser&#x27;</span>)</span><br><span class="line"></span><br><span class="line">login.<span class="title function_">use</span>(<span class="title function_">bodyParser</span>());</span><br><span class="line"></span><br><span class="line">login.<span class="title function_">post</span>(<span class="string">&#x27;/register&#x27;</span>, <span class="keyword">async</span> (ctx)=&gt;&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(ctx.<span class="property">request</span>.<span class="property">body</span>);		<span class="comment">// 可以打印得到数据</span></span><br><span class="line">	ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&quot;登录或注册&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="5、登录与自动注册"><a href="#5、登录与自动注册" class="headerlink" title="5、登录与自动注册"></a>5、登录与自动注册</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Router</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> login = <span class="keyword">new</span> <span class="title class_">Router</span>()</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;koa-bodyparser&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> db = <span class="built_in">require</span>(<span class="string">&#x27;../utils/db&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> jwt = <span class="built_in">require</span>(<span class="string">&#x27;jsonwebtoken&#x27;</span>)</span><br><span class="line"></span><br><span class="line">login.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">	ctx.<span class="property">response</span>.<span class="property">body</span> = <span class="string">&quot;登录页面&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">login.<span class="title function_">use</span>(<span class="title function_">bodyParser</span>());</span><br><span class="line"></span><br><span class="line">login.<span class="title function_">post</span>(<span class="string">&#x27;/register&#x27;</span>, <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">	<span class="keyword">let</span> myaccount = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">account</span>;</span><br><span class="line">	<span class="keyword">let</span> mypwd = ctx.<span class="property">request</span>.<span class="property">body</span>.<span class="property">pwd</span>;</span><br><span class="line">	<span class="keyword">let</span> sql = <span class="string">`SELECT * FROM users WHERE account=&#x27;<span class="subst">$&#123;myaccount&#125;</span>&#x27;`</span>;</span><br><span class="line">	<span class="keyword">let</span> result = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> db.<span class="title function_">query</span>(sql, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">			<span class="keyword">if</span> (data.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="title function_">resolve</span>(data);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="title function_">resolve</span>(<span class="literal">false</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> (result) &#123;</span><br><span class="line">		<span class="comment">// 能找到对应的账号</span></span><br><span class="line">		<span class="keyword">if</span> (result[<span class="number">0</span>].<span class="property">pwd</span> == mypwd) &#123;</span><br><span class="line">			<span class="comment">// 账号密码正确，返回token</span></span><br><span class="line">			ctx.<span class="property">body</span> = &#123;</span><br><span class="line">				<span class="attr">token</span>: result[<span class="number">0</span>],</span><br><span class="line">				<span class="attr">msg</span>: <span class="string">&#x27;登录成功&#x27;</span>,</span><br><span class="line">				<span class="attr">account</span>: myaccount</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 密码错误</span></span><br><span class="line">			ctx.<span class="property">body</span> = &#123;</span><br><span class="line">				<span class="attr">msg</span>: <span class="string">&#x27;密码错误&#x27;</span>,</span><br><span class="line">				<span class="attr">account</span>: myaccount</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 找不到对应的账号，直接插入一个</span></span><br><span class="line">		<span class="keyword">let</span> result1 = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="comment">// 生成token</span></span><br><span class="line">			<span class="keyword">const</span> token = jwt.<span class="title function_">sign</span>(&#123; <span class="attr">myaccount</span>: myaccount, <span class="attr">mypwd</span>: mypwd &#125;, <span class="string">&#x27;secret&#x27;</span>, &#123; <span class="attr">expiresIn</span>: <span class="number">3600</span> &#125;)</span><br><span class="line">			<span class="keyword">return</span> db.<span class="title function_">query</span>(<span class="string">`INSERT INTO users (account, pwd, token) values (&#x27;<span class="subst">$&#123;myaccount&#125;</span>&#x27;, &#x27;<span class="subst">$&#123;mypwd&#125;</span>&#x27;, &#x27;<span class="subst">$&#123;token&#125;</span>&#x27;)`</span>, <span class="function">(<span class="params">error, datas</span>) =&gt;</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (error) <span class="keyword">throw</span> error;</span><br><span class="line">				<span class="comment">// 已插入数据，返回用户名与token</span></span><br><span class="line">				<span class="keyword">let</span> obj = &#123;</span><br><span class="line">					token,</span><br><span class="line">					<span class="attr">msg</span>: <span class="string">&#x27;登录成功&#x27;</span>,</span><br><span class="line">					<span class="attr">account</span>: myaccount</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="title function_">resolve</span>(obj)</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">if</span> (result1) &#123;</span><br><span class="line">			ctx.<span class="property">body</span> = result1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = login;</span><br></pre></td></tr></table></figure>

<p>此时，前端做这个post请求后，就会得到相应的数据。</p>
<h2 id="十二、部署到服务器上"><a href="#十二、部署到服务器上" class="headerlink" title="十二、部署到服务器上"></a>十二、部署到服务器上</h2><p>部署需要先购买服务器，下载filezilla软件。</p>
<p>服务器上需要安装node 、mysql、pm2</p>
<p>具体教程请参考下面这篇文章</p>
<p><a href="https://blog.csdn.net/yh8899abc/article/details/105201742">https://blog.csdn.net/yh8899abc/article/details/105201742</a></p>
<h1 id="十三、-koa与express"><a href="#十三、-koa与express" class="headerlink" title="十三、 koa与express"></a>十三、 koa与express</h1><p>主要优点： </p>
<ol>
<li>koa解决了回调地狱问题</li>
<li>拥抱async&#x2F;await</li>
</ol>
<h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><p>需要封装部分：</p>
<pre><code>   1. 基本全局配置： baseURL， timeout 等等
    2. Token
      3. 响应统一处理（错误处理）
      4. 封装请求方法： 对接口的请求封装为一个个函数
</code></pre>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//res.data 是响应体</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><ol>
<li>判断页面需不需要token &#x3D;&gt; 通过vue路由守卫</li>
<li>向服务器发送该页面相关的数据请求 </li>
<li>服务器验证token的正确性<ol>
<li>正确 &#x3D;&gt;  返回该用户数据</li>
<li>错误 &#x3D;&gt;  返回401状态码，前端检测状态码跳转回登陆页面</li>
</ol>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截成功&#x27;</span>,config);</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;throw了一个错误&#x27;</span></span><br><span class="line">&#125;， error=&gt; &#123;</span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;请求拦截失败&quot;</span>，error)</span><br><span class="line">    &#125;）</span><br><span class="line"></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="function"><span class="params">response</span>=&gt;</span> &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截成功&#x27;</span>，response)</span><br><span class="line">     &#125;, <span class="function"><span class="params">error</span>=&gt;</span> &#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;响应拦截失败&quot;</span>, error)</span><br><span class="line">     &#125;)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">请求拦截成功</span></span><br><span class="line"><span class="comment">响应拦截失败 throw了一个错误</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*请求拦截器抛出异常后，或者没有return config</span></span><br><span class="line"><span class="comment">  请求不会发送至服务器！*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//移除拦截器</span></span><br><span class="line"><span class="keyword">const</span> myInterceptor = axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;)</span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">eject</span>(myInterceptor)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器成功&#x27;</span>,config); </span><br><span class="line">    <span class="keyword">const</span> token = store.<span class="property">state</span>.<span class="property">token</span></span><br><span class="line">    <span class="keyword">if</span> (token)</span><br><span class="line">        config.<span class="property">headers</span>[<span class="string">&#x27;Authorization&#x27;</span>] = token</span><br><span class="line">    <span class="comment">//profile页面需要token</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(config.<span class="property">url</span>==<span class="string">&#x27;http://localhost:9000/profile&#x27;</span>)&#123;</span><br><span class="line">        router.<span class="title function_">replace</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;login&#x27;</span> &#125;)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;拦截-没有token,重定向回login&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求数据&#x27;</span>,config.<span class="property">data</span>)</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line"></span><br><span class="line">&#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;请求拦截器失败&#x27;</span>,error); </span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">axios.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;请求拦截器成功&quot;</span>,response)</span><br><span class="line">    <span class="keyword">if</span> (response.<span class="property">status</span> === <span class="number">200</span> || response.<span class="property">code</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(response)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(response)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;响应拦截器失败&#x27;</span>,error);</span><br><span class="line">    <span class="keyword">let</span> status = error.<span class="property">status</span> || error.<span class="property">code</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">401</span>: router.<span class="title function_">replace</span>(&#123;</span><br><span class="line">                <span class="attr">path</span>: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">                <span class="attr">name</span>: <span class="string">&#x27;login&#x27;</span>,</span><br><span class="line">                <span class="attr">params</span>: &#123;</span><br><span class="line">                    <span class="attr">message</span>: <span class="string">&#x27;请重新登录&#x27;</span>,</span><br><span class="line">                    <span class="attr">redirect</span>: router.<span class="property">currentRoute</span>.<span class="property">fullPath</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">403</span>:</span><br><span class="line">                <span class="title function_">alert</span>(<span class="string">&#x27;登录过期请重新登录&#x27;</span>)</span><br><span class="line">                <span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">                store.<span class="title function_">commit</span>(<span class="string">&#x27;loginSuccess&#x27;</span>)</span><br><span class="line">                router.<span class="title function_">replace</span>(&#123;</span><br><span class="line">                    <span class="attr">path</span>: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">                    <span class="attr">name</span>: <span class="string">&#x27;login&#x27;</span>,</span><br><span class="line">                    <span class="attr">params</span>: &#123;</span><br><span class="line">                        <span class="attr">redirect</span>: router.<span class="property">currentRoute</span>.<span class="property">fullPath</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">404</span>:</span><br><span class="line">                <span class="title function_">alert</span>(<span class="string">&#x27;404请求不存在&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="attr">default</span>:</span><br><span class="line">                <span class="title function_">alert</span>(<span class="string">&#x27;响应拦截器拦截失败&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="请求取消"><a href="#请求取消" class="headerlink" title="请求取消"></a>请求取消</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一(已弃用)</span></span><br><span class="line"><span class="keyword">let</span> cancel = <span class="literal">null</span>;</span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;url&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">cancelToken</span>: <span class="keyword">new</span> axios.<span class="title class_">CancelToken</span>(<span class="function"><span class="params">c</span>=&gt;</span>&#123;</span><br><span class="line">        cancel = c; <span class="comment">//拿到取消请求方法</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span>=&gt;</span> &#123;</span><br><span class="line">    cancel = <span class="literal">null</span>; <span class="comment">//初试化cancel</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="params">err</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用取消</span></span><br><span class="line"><span class="title function_">cancel</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="keyword">const</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;url&#x27;</span>,&#123;</span><br><span class="line">    <span class="attr">signal</span>: controller.<span class="property">signal</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="params">err</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">//调用取消</span></span><br><span class="line">controller.<span class="title function_">abort</span>()</span><br></pre></td></tr></table></figure>

<h2 id="post方法序列化"><a href="#post方法序列化" class="headerlink" title="post方法序列化"></a>post方法序列化</h2><p>序列化，就是将对象 序列化成URL的形式，以&amp;进行拼接。</p>
<p>为什么？ because：提交时候是直接以原始数据格式存储在body中的，而不是以键值对的形式附加到url中，所以服务端是无法直接识别的。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>koa2</tag>
      </tags>
  </entry>
  <entry>
    <title>vue2笔记</title>
    <url>/2023/10/11/vue2%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h1><span id="more"></span>

<h2 id="脚手架文件结构"><a href="#脚手架文件结构" class="headerlink" title="脚手架文件结构"></a>脚手架文件结构</h2><pre><code>├── node_modules 
├── public
│   ├── favicon.ico: 页签图标
│   └── index.html: 主页面
├── src
│   ├── assets: 存放静态资源
│   │   └── logo.png
│   │── component: 存放组件
│   │   └── HelloWorld.vue
│   │── App.vue: 汇总所有组件    
│   │── main.js: 入口文件
├── .gitignore: git版本管制忽略的配置
├── babel.config.js: babel的配置文件
├── package.json: 应用包配置文件 
├── README.md: 应用描述文件
├── package-lock.json：包版本控制文件
</code></pre>
<h2 id="关于不同版本的Vue"><a href="#关于不同版本的Vue" class="headerlink" title="关于不同版本的Vue"></a>关于不同版本的Vue</h2><ol>
<li>vue.js与vue.runtime.xxx.js的区别：<ol>
<li>vue.js是完整版的Vue，包含：核心功能 + 模板解析器。</li>
<li>vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。</li>
</ol>
</li>
<li>因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。</li>
</ol>
<h2 id="vue-config-js配置文件"><a href="#vue-config-js配置文件" class="headerlink" title="vue.config.js配置文件"></a>vue.config.js配置文件</h2><ol>
<li>使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。</li>
<li>使用vue.config.js可以对脚手架进行个性化定制，详情见：<a href="https://cli.vuejs.org/zh">https://cli.vuejs.org/zh</a></li>
</ol>
<h2 id="ref属性"><a href="#ref属性" class="headerlink" title="ref属性"></a>ref属性</h2><ol>
<li>被用来给元素或子组件注册引用信息（id的替代者）</li>
<li>应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）</li>
<li>使用方式：<ol>
<li>打标识：<code>&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;</code> 或 <code>&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;</code></li>
<li>获取：<code>this.$refs.xxx</code></li>
</ol>
</li>
</ol>
<h2 id="props配置项"><a href="#props配置项" class="headerlink" title="props配置项"></a>props配置项</h2><ol>
<li><p>功能：让组件接收外部传过来的数据</p>
</li>
<li><p>传递数据：<code>&lt;Demo name=&quot;xxx&quot;/&gt;</code>或者<code> &lt;Demo :name=&quot;obj&quot;/</code></p>
</li>
<li><p>接收数据：</p>
<ol>
<li><p>第一种方式（只接收）：<code>props:[&#39;name&#39;] </code></p>
</li>
<li><p>第二种方式（限制类型）：<code>props:&#123;name:String&#125;</code></p>
</li>
<li><p>第三种方式（限制类型、限制必要性、指定默认值）：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>:&#123;</span><br><span class="line">	<span class="attr">name</span>:&#123;</span><br><span class="line">		<span class="attr">type</span>:<span class="title class_">String</span>, <span class="comment">//类型</span></span><br><span class="line">		<span class="attr">required</span>:<span class="literal">true</span>, <span class="comment">//必要性</span></span><br><span class="line">		<span class="attr">default</span>:<span class="string">&#x27;老王&#x27;</span> <span class="comment">//默认值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>$attrs 和 inheritAttrs</p>
</li>
</ol>
<p>  首先$attrs 和 inheritAttrs没有任何关系</p>
<ul>
<li><p>$attrs: </p>
<ul>
<li>接收通过props传来的所有属性</li>
</ul>
</li>
<li><p>inheritAttrs: Boolean</p>
<ul>
<li>默认true，未被props接收的属性会被添加在标签属性上</li>
<li>false，不会再添加在标签的属性上了</li>
</ul>
<blockquote>
<p>备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。</p>
</blockquote>
</li>
</ul>
<h2 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin(混入)"></a>mixin(混入)</h2><ol>
<li><p>功能：可以把多个组件共用的配置提取成一个混入对象</p>
</li>
<li><p>使用方式：</p>
<p> 第一步定义混合, 抽出mixin.js文件中：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>)&#123;....&#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;....&#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 第二步使用混入：</p>
<p> ​	全局混入：<code>Vue.mixin(xxx)</code><br> ​	局部混入：<code>mixins:[&#39;xxx&#39;]	</code></p>
</li>
</ol>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ol>
<li><p>功能：用于增强Vue</p>
</li>
<li><p>本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。</p>
</li>
<li><p>定义插件：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">对象.<span class="property">install</span> = <span class="keyword">function</span> (<span class="params">Vue, options</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 添加全局过滤器</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">filter</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 添加全局指令</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">directive</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 配置全局混入(合)</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">mixin</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 添加实例方法</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;...&#125;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myProperty</span> = xxxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用插件：<code>Vue.use(pluginName,options)</code></p>
</li>
</ol>
<h2 id="scoped样式"><a href="#scoped样式" class="headerlink" title="scoped样式"></a>scoped样式</h2><ol>
<li>作用：让样式在局部生效，防止冲突。</li>
<li>写法：<code>&lt;style scoped&gt;</code></li>
</ol>
<h2 id="总结TodoList案例"><a href="#总结TodoList案例" class="headerlink" title="总结TodoList案例"></a>总结TodoList案例</h2><ol>
<li><p>组件化编码流程：</p>
<p> ​	(1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。</p>
<p> ​	(2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：</p>
<p> ​			1).一个组件在用：放在组件自身即可。</p>
<p> ​			2). 一些组件在用：放在他们共同的父组件上（<span style="color:red">状态提升</span>）。</p>
<p> ​	(3).实现交互：从绑定事件开始。</p>
</li>
<li><p>props适用于：</p>
<p> ​	(1).父组件 &#x3D;&#x3D;&gt; 子组件 通信</p>
<p> ​	(2).子组件 &#x3D;&#x3D;&gt; 父组件 通信（要求父先给子一个函数）</p>
<p> ​	(3).爷组件 &#x3D;&#x3D;&gt; 子组件 通信（链式）</p>
</li>
<li><p>使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！</p>
</li>
<li><p>props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。</p>
</li>
</ol>
<h2 id="webStorage"><a href="#webStorage" class="headerlink" title="webStorage"></a>webStorage</h2><ol>
<li><p>存储内容大小一般支持5MB左右（不同浏览器可能还不一样）</p>
</li>
<li><p>浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。</p>
</li>
<li><p>相关API：</p>
<ol>
<li><p><code>xxxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;);</code><br>             该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。</p>
</li>
<li><p><code>xxxxxStorage.getItem(&#39;person&#39;);</code></p>
<p> ​		该方法接受一个键名作为参数，返回键名对应的值。</p>
</li>
<li><p><code>xxxxxStorage.removeItem(&#39;key&#39;);</code></p>
<p> ​		该方法接受一个键名作为参数，并把该键名从存储中删除。</p>
</li>
<li><p><code> xxxxxStorage.clear()</code></p>
<p> ​		该方法会清空存储中的所有数据。</p>
</li>
</ol>
</li>
<li><p>备注：</p>
<ol>
<li>SessionStorage存储的内容会随着浏览器窗口关闭而消失。</li>
<li>LocalStorage存储的内容，需要手动清除才会消失。</li>
<li><code>xxxxxStorage.getItem(xxx)</code>如果xxx对应的value获取不到，那么getItem的返回值是null。</li>
<li><code>JSON.parse(null)</code>的结果依然是null。</li>
<li><code>JSON.stringify(p)</code>把对象转化为json格式</li>
</ol>
</li>
</ol>
<h2 id="组件的自定义事件"><a href="#组件的自定义事件" class="headerlink" title="组件的自定义事件"></a>组件的自定义事件</h2><ol>
<li><p>一种组件间通信的方式，适用于：<strong style="color:red">子组件 &#x3D;&#x3D;&#x3D;&gt; 父组件</strong></p>
</li>
<li><p>使用场景：父组件上给子组件标签注册绑定自定义事件函数，子组件触发事件调用函数传参</p>
</li>
<li><p>绑定自定义事件：</p>
<ol>
<li><p>第一种方式，</p>
<p>在父组件中：<code>&lt;Demo @eventName=&quot;methodName&quot;/&gt;</code> ,</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">methodName</span>(<span class="params">data</span>)&#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在子组件中:  <code> this.$emit(&#39;eventName&#39;, data)</code> </p>
</li>
<li><p>第二种方式，在父组件中：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Demo</span> ref=<span class="string">&quot;demo&quot;</span>/&gt;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">demo</span>.$on(<span class="string">&#x27;atguigu&#x27;</span>,<span class="variable language_">this</span>.<span class="property">test</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</p>
<p>触发自定义事件：<code>this.$emit(&#39;atguigu&#39;,数据)</code></p>
</li>
</ol>
<p>		</p>
</li>
<li><p>解绑自定义事件<code>this.$off(&#39;atguigu&#39;)</code> 或者 <code>this.$off([&#39;atguigu1&#39;,&#39;a2&#39;])</code>或者<code>this.$off()</code></p>
</li>
<li><p>组件上也可以绑定原生DOM事件，需要使用<code>native</code>修饰符。(例如<code>@click.native</code>)</p>
</li>
<li><p>注意：通过<code>this.$refs.xxx.$on(&#39;atguigu&#39;,回调)</code>绑定自定义事件时，回调<span style="color:red">要么配置在methods中</span>，<span style="color:red">要么用箭头函数</span>，否则this指向会出问题！</p>
</li>
</ol>
<h2 id="全局事件总线（GlobalEventBus）"><a href="#全局事件总线（GlobalEventBus）" class="headerlink" title="全局事件总线（GlobalEventBus）"></a>全局事件总线（GlobalEventBus）</h2><ol>
<li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li><p>安装全局事件总线：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span> = <span class="variable language_">this</span> <span class="comment">//安装全局事件总线，$bus就是当前应用的vm</span></span><br><span class="line">	&#125;,</span><br><span class="line">    ......</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>
</li>
<li><p>使用事件总线：</p>
<ol>
<li><p>接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的<span style="color:red">回调留在A组件自身。</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">methods</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">demo</span>(<span class="params">data</span>)&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$bus</span>.$on(<span class="string">&#x27;xxxx&#x27;</span>,<span class="variable language_">this</span>.<span class="property">demo</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提供数据：<code>this.$bus.$emit(&#39;xxxx&#39;,数据)</code></p>
</li>
</ol>
</li>
<li><p>最好在beforeDestroy钩子中，用$off去解绑<span style="color:red">当前组件所用到的</span>事件。</p>
</li>
</ol>
<h2 id="消息订阅与发布（pubsub）"><a href="#消息订阅与发布（pubsub）" class="headerlink" title="消息订阅与发布（pubsub）"></a>消息订阅与发布（pubsub）</h2><ol>
<li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li><p>使用步骤：</p>
<ol>
<li><p>安装pubsub：<code>npm i pubsub-js</code></p>
</li>
<li><p>引入: <code>import pubsub from &#39;pubsub-js&#39;</code></p>
</li>
<li><p>接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的<span style="color:red">回调留在A组件自身。</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">methods</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">demo</span>(<span class="params">data</span>)&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pid</span> = pubsub.<span class="title function_">subscribe</span>(<span class="string">&#x27;xxx&#x27;</span>,<span class="variable language_">this</span>.<span class="property">demo</span>) <span class="comment">//订阅消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>提供数据：<code>pubsub.publish(&#39;xxx&#39;,数据)</code></p>
</li>
<li><p>最好在beforeDestroy钩子中，用<code>pubSub.unsubscribe(pid)</code>去<span style="color:red">取消订阅。</span></p>
</li>
</ol>
</li>
</ol>
<h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><ol>
<li>语法：<code>this.$nextTick(回调函数)</code></li>
<li>作用：在下一次 DOM 更新结束后执行其指定的回调。</li>
<li>什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。</li>
</ol>
<h2 id="Vue封装的过度与动画"><a href="#Vue封装的过度与动画" class="headerlink" title="Vue封装的过度与动画"></a>Vue封装的过度与动画</h2><ol>
<li><p>作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。</p>
</li>
<li><p>图示：<img src="https://img04.sogoucdn.com/app/a/100520146/5990c1dff7dc7a8fb3b34b4462bd0105" style="width:60%"></p>
</li>
<li><p>写法：</p>
<ol>
<li><p>准备好样式：</p>
<ul>
<li>元素进入的样式：<ol>
<li>v-enter：进入的起点</li>
<li>v-enter-active：进入过程中</li>
<li>v-enter-to：进入的终点</li>
</ol>
</li>
<li>元素离开的样式：<ol>
<li>v-leave：离开的起点</li>
<li>v-leave-active：离开过程中</li>
<li>v-leave-to：离开的终点</li>
</ol>
</li>
</ul>
</li>
<li><p>使用<code>&lt;transition&gt;</code>包裹要过度的元素，并配置name属性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;transition name=&quot;hello&quot;&gt;</span><br><span class="line">	&lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>备注：若有多个元素需要过度，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值。</p>
</li>
<li><p>动画库，<a href><a href="https://animate.style/">Animate.css | A cross-browser library of CSS animations.</a></a></p>
<ol>
<li>npm install animate.css</li>
<li>import ‘animate.css’</li>
<li></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;transition-group </span><br><span class="line">	appear</span><br><span class="line">	name=&quot;animate__animated animate__bounce&quot; </span><br><span class="line">	enter-active-class=&quot;animate__swing&quot;      </span><br><span class="line">	leave-active-class=&quot;animate__backOutUp&quot;&gt;</span><br><span class="line">&lt;/transition-group&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="vue脚手架配置代理"><a href="#vue脚手架配置代理" class="headerlink" title="vue脚手架配置代理"></a>vue脚手架配置代理</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>​	在vue.config.js中添加如下配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">devServer</span>:&#123;</span><br><span class="line">  <span class="attr">proxy</span>:<span class="string">&quot;http://localhost:3000&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li><p>优点：配置简单，请求资源时直接发给前端（8080）即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&#x27;http://localhost:8080/hi&#x27;</span>)</span><br><span class="line"><span class="comment">//把端口自动转为发送至http://localhost:3000/hi</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</p>
</li>
<li><p>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</p>
</li>
</ol>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>​	编写vue.config.js配置具体代理规则：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">	<span class="attr">devServer</span>: &#123;</span><br><span class="line">      <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api1&#x27;</span>: &#123;<span class="comment">// 匹配所有以 &#x27;/api1&#x27;开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5000&#x27;</span>,<span class="comment">// 代理目标的基础路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;<span class="string">&#x27;^/api1&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&#x27;/api2&#x27;</span>: &#123;<span class="comment">// 匹配所有以 &#x27;/api2&#x27;开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5001&#x27;</span>,<span class="comment">// 代理目标的基础路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;<span class="string">&#x27;^/api2&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000</span></span><br><span class="line"><span class="comment">   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080</span></span><br><span class="line"><span class="comment">   changeOrigin默认值为true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li>
<li>缺点：配置略微繁琐，请求资源时必须加前缀。</li>
</ol>
<h2 id="mount"><a href="#mount" class="headerlink" title="$mount()"></a>$mount()</h2><p>可以把<code>vue</code>实例或者组件实例挂载到某个节点中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$mount(<span class="string">&#x27;#app&#x27;</span>) <span class="comment">//挂载在id=app的节点上</span></span><br><span class="line">vm.$mount() <span class="comment">//默认挂载在 body上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//除了vm可以挂载，组件实例也可以挂载</span></span><br><span class="line"><span class="keyword">const</span> vc = <span class="keyword">new</span> <span class="title class_">Vue</span>.<span class="title function_">extend</span>(<span class="title class_">ElementUI</span>.<span class="property">Popover</span>)</span><br><span class="line">vc.$mount()</span><br></pre></td></tr></table></figure>



<h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><ol>
<li><p>作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong style="color:red">父组件 &#x3D;&#x3D;&#x3D;&gt; 子组件</strong> 。</p>
</li>
<li><p>分类：默认插槽、具名插槽、作用域插槽</p>
</li>
<li><p>使用方式：</p>
<ol>
<li><p>默认插槽：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">        &lt;Category&gt;</span><br><span class="line">           &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">               &lt;!-- 定义插槽 --&gt;</span><br><span class="line">               &lt;slot&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具名插槽：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">        &lt;Category&gt;</span><br><span class="line">            &lt;template v-slot:footer&gt;</span><br><span class="line">			&lt;!-- 可以缩写为： #footer --&gt;</span><br><span class="line">               &lt;div&gt;html结构2&lt;/div&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">               &lt;!-- 定义插槽 --&gt;</span><br><span class="line">               &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">               &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>作用域插槽：</p>
<ol>
<li><p>理解：父组件要访问到子组件数据</p>
</li>
<li><p>具体编码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">		&lt;Category&gt;</span><br><span class="line">            &lt;!-- 子组件中没有name属性的slot，有个默认name=‘default --&gt;</span><br><span class="line">			&lt;template v-slot:default=&#x27;scopeData&#x27;&gt;</span><br><span class="line">				&lt;!-- 1. 当只有默认插槽时，v-slot:default=&#x27;&#x27; 可以简写为v-slot=&#x27;&#x27; </span><br><span class="line">					 2. scopeData 可以解构 &#123;data&#125;</span><br><span class="line">					 3. v-slot:default 可以缩写为 #default</span><br><span class="line">--&gt;</span><br><span class="line">				&lt;ul&gt;</span><br><span class="line">					&lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;</span><br><span class="line">				&lt;/ul&gt;</span><br><span class="line">			&lt;/template&gt;</span><br><span class="line">		&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">子组件中：</span><br><span class="line">        &lt;template&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">		</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            export default &#123;</span><br><span class="line">                name:&#x27;Category&#x27;,</span><br><span class="line">                props:[&#x27;title&#x27;],</span><br><span class="line">                //数据在子组件自身</span><br><span class="line">                data() &#123;</span><br><span class="line">                    return &#123;</span><br><span class="line">                        games:[&#x27;红色警戒&#x27;,&#x27;穿越火线&#x27;,&#x27;劲舞团&#x27;,&#x27;超级玛丽&#x27;]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</p>
</blockquote>
<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>​		在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方式，且适用于任意组件间通信。</p>
<h3 id="2-何时使用？"><a href="#2-何时使用？" class="headerlink" title="2.何时使用？"></a>2.何时使用？</h3><p>​		多个组件需要共享数据时</p>
<h3 id="3-搭建vuex环境"><a href="#3-搭建vuex环境" class="headerlink" title="3.搭建vuex环境"></a>3.搭建vuex环境</h3><ol>
<li><p>创建文件：<code>src/store/index.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入Vue核心库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//应用Vuex插件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备actions对象——响应组件中用户的动作</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;&#125;</span><br><span class="line"><span class="comment">//准备mutations对象——修改state中的数据</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;&#125;</span><br><span class="line"><span class="comment">//准备state对象——保存具体的数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">	actions,</span><br><span class="line">	mutations,</span><br><span class="line">	state</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>main.js</code>中创建vm时传入<code>store</code>配置项</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">//引入store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vm</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">	<span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">	<span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">	store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-基本使用"><a href="#4-基本使用" class="headerlink" title="4.基本使用"></a>4.基本使用</h3><ol>
<li><p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入Vue核心库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//引用Vuex</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">    <span class="comment">//响应组件中加的动作</span></span><br><span class="line">	<span class="title function_">jia</span>(<span class="params">context,value</span>)&#123;</span><br><span class="line">		<span class="comment">// console.log(&#x27;actions中的jia被调用了&#x27;,miniStore,value)</span></span><br><span class="line">		context.<span class="title function_">commit</span>(<span class="string">&#x27;JIA&#x27;</span>,value)</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">    <span class="comment">//执行加</span></span><br><span class="line">	<span class="title function_">JIA</span>(<span class="params">state,value</span>)&#123;</span><br><span class="line">		<span class="comment">// console.log(&#x27;mutations中的JIA被调用了&#x27;,state,value)</span></span><br><span class="line">		state.<span class="property">sum</span> += value</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">   <span class="attr">sum</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">	actions,</span><br><span class="line">	mutations,</span><br><span class="line">	state,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件中读取vuex中的数据：<code>$store.state.sum</code></p>
</li>
<li><p>组件中修改vuex中的数据：<code>$store.dispatch(&#39;action中的方法名&#39;,数据)</code> 或 <code>$store.commit(&#39;mutations中的方法名&#39;,数据)</code></p>
<blockquote>
<p> 备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p>
</blockquote>
</li>
</ol>
<h3 id="5-getters的使用"><a href="#5-getters的使用" class="headerlink" title="5.getters的使用"></a>5.getters的使用</h3><ol>
<li><p>概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。</p>
</li>
<li><p>在<code>store.js</code>中追加<code>getters</code>配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">	<span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> state.<span class="property">sum</span> * <span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">	......</span><br><span class="line">	getters</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件中读取数据：<code>$store.getters.bigSum</code></p>
</li>
</ol>
<h3 id="6-四个map方法的使用"><a href="#6-四个map方法的使用" class="headerlink" title="6.四个map方法的使用"></a>6.四个map方法的使用</h3><ol>
<li><p><strong>mapState方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">//借助mapState生成计算属性：sum、school、subject（对象写法）</span></span><br><span class="line">     ...<span class="title function_">mapState</span>(&#123;<span class="attr">sum</span>:<span class="string">&#x27;sum&#x27;</span>,<span class="attr">school</span>:<span class="string">&#x27;school&#x27;</span>,<span class="attr">subject</span>:<span class="string">&#x27;subject&#x27;</span>&#125;),</span><br><span class="line">         </span><br><span class="line">    <span class="comment">//借助mapState生成计算属性：sum、school、subject（数组写法）</span></span><br><span class="line">    ...<span class="title function_">mapState</span>([<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>]),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>mapGetters方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">//借助mapGetters生成计算属性：bigSum（对象写法）</span></span><br><span class="line">    ...<span class="title function_">mapGetters</span>(&#123;<span class="attr">bigSum</span>:<span class="string">&#x27;bigSum&#x27;</span>&#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//借助mapGetters生成计算属性：bigSum（数组写法）</span></span><br><span class="line">    ...<span class="title function_">mapGetters</span>([<span class="string">&#x27;bigSum&#x27;</span>])</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>mapActions方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="comment">//靠mapActions生成：incrementOdd、incrementWait（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapActions</span>(&#123;<span class="attr">incrementOdd</span>:<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="attr">incrementWait</span>:<span class="string">&#x27;jiaWait&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//靠mapActions生成：incrementOdd、incrementWait（数组形式）</span></span><br><span class="line">    ...<span class="title function_">mapActions</span>([<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="string">&#x27;jiaWait&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>mapMutations方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="comment">//靠mapActions生成：increment、decrement（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapMutations</span>(&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//靠mapMutations生成：JIA、JIAN（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapMutations</span>([<span class="string">&#x27;JIA&#x27;</span>,<span class="string">&#x27;JIAN&#x27;</span>]),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</p>
</blockquote>
<h3 id="7-模块化-命名空间"><a href="#7-模块化-命名空间" class="headerlink" title="7.模块化+命名空间"></a>7.模块化+命名空间</h3><ol>
<li><p>目的：让代码更好维护，让多种数据分类更加明确。</p>
</li>
<li><p>修改<code>idnex.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> countAbout = &#123;</span><br><span class="line">  <span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  <span class="attr">state</span>:&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> state.<span class="property">sum</span> * <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> personAbout = &#123;</span><br><span class="line">  <span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  <span class="attr">state</span>:&#123; ... &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;   <span class="comment">// modules 分模块</span></span><br><span class="line">    countAbout,</span><br><span class="line">    personAbout</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启命名空间后，组件中读取state数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">personAbout</span>.<span class="property">list</span></span><br><span class="line"><span class="comment">//方式二：借助mapState读取：</span></span><br><span class="line">...<span class="title function_">mapState</span>(<span class="string">&#x27;countAbout&#x27;</span>,[<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>]),</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启命名空间后，组件中读取getters数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>[<span class="string">&#x27;personAbout/firstPersonName&#x27;</span>]</span><br><span class="line"><span class="comment">//方式二：借助mapGetters读取：</span></span><br><span class="line">...<span class="title function_">mapGetters</span>(<span class="string">&#x27;countAbout&#x27;</span>,[<span class="string">&#x27;bigSum&#x27;</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启命名空间后，组件中调用dispatch</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接dispatch</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;personAbout/addPersonWang&#x27;</span>,person)</span><br><span class="line"><span class="comment">//方式二：借助mapActions：</span></span><br><span class="line">...<span class="title function_">mapActions</span>(<span class="string">&#x27;countAbout&#x27;</span>,&#123;<span class="attr">incrementOdd</span>:<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="attr">incrementWait</span>:<span class="string">&#x27;jiaWait&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启命名空间后，组件中调用commit</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接commit</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;personAbout/ADD_PERSON&#x27;</span>,person)</span><br><span class="line"><span class="comment">//方式二：借助mapMutations：</span></span><br><span class="line">...<span class="title function_">mapMutations</span>(<span class="string">&#x27;countAbout&#x27;</span>,&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ol>
<li>理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</li>
<li>前端路由：key是路径，value是组件。</li>
</ol>
<h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h3><ol>
<li><p>安装vue-router，命令：<code>npm i vue-router@3</code></p>
</li>
<li><p>应用插件：<code>Vue.use(VueRouter)</code></p>
</li>
<li><p>编写router配置项:</p>
<p><code>router/index.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入VueRouter</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="comment">//引入Luyou 组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;../components/About&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;../components/Home&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建router实例对象，去管理一组一组的路由规则</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">	<span class="attr">routes</span>:[</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">About</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">Home</span></span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴露router</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>
<p><code>main.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入VueRouter</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="comment">//引入路由器</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="comment">//应用插件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br><span class="line"><span class="comment">//创建vm</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">	<span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">	<span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">	router  <span class="comment">//注册路由</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>实现切换（active-class可配置高亮样式, 其实就是a标签）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定展示位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用路由进行页面切换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//app.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">        &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-几个注意点"><a href="#2-几个注意点" class="headerlink" title="2.几个注意点"></a>2.几个注意点</h3><ol>
<li><p>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</p>
</li>
<li><p>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</p>
</li>
<li><p>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</p>
</li>
<li><p>整个应用只有一个router，可以通过组件的<code>$router</code>属性获取到。</p>
</li>
</ol>
<h3 id="3-多级路由（多级路由）"><a href="#3-多级路由（多级路由）" class="headerlink" title="3.多级路由（多级路由）"></a>3.多级路由（多级路由）</h3><ol>
<li><p>配置路由规则，使用children配置项：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">routes</span>:[</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">path</span>:<span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">		<span class="attr">component</span>:<span class="title class_">About</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">		<span class="attr">component</span>:<span class="title class_">Home</span>,</span><br><span class="line">		<span class="attr">children</span>:[ <span class="comment">//通过children配置子级路由</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>, <span class="comment">//此处一定不要写：/news</span></span><br><span class="line">				<span class="attr">component</span>:<span class="title class_">News</span></span><br><span class="line">			&#125;,</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">path</span>:<span class="string">&#x27;message&#x27;</span>,<span class="comment">//此处一定不要写：/message</span></span><br><span class="line">				<span class="attr">component</span>:<span class="title class_">Message</span></span><br><span class="line">			&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>跳转（要写完整路径）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-路由的query参数"><a href="#4-路由的query参数" class="headerlink" title="4.路由的query参数"></a>4.路由的query参数</h3><ol>
<li><p>传递参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line">				</span><br><span class="line">&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">	:to=&quot;&#123;</span><br><span class="line">		path:&#x27;/home/message/detail&#x27;,</span><br><span class="line">		query:&#123;</span><br><span class="line">		   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接收参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$route.<span class="property">query</span>.<span class="property">id</span></span><br><span class="line">$route.<span class="property">query</span>.<span class="property">title</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="5-命名路由"><a href="#5-命名路由" class="headerlink" title="5.命名路由"></a>5.命名路由</h3><ol>
<li><p>作用：可以简化路由的跳转。</p>
</li>
<li><p>如何使用</p>
<ol>
<li><p>给路由命名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">path</span>:<span class="string">&#x27;/demo&#x27;</span>,</span><br><span class="line">	<span class="attr">component</span>:<span class="title class_">Demo</span>,</span><br><span class="line">	<span class="attr">children</span>:[</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">path</span>:<span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">Test</span>,</span><br><span class="line">			<span class="attr">children</span>:[</span><br><span class="line">				&#123;</span><br><span class="line">                      <span class="attr">name</span>:<span class="string">&#x27;hello&#x27;</span> <span class="comment">//给路由命名</span></span><br><span class="line">					<span class="attr">path</span>:<span class="string">&#x27;welcome&#x27;</span>,</span><br><span class="line">					<span class="attr">component</span>:<span class="title class_">Hello</span>,</span><br><span class="line">				&#125;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>简化跳转：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--简化前，需要写完整的路径 --&gt;</span><br><span class="line">&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--简化后，直接通过名字跳转 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;&#123;name:&#x27;hello&#x27;&#125;&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--简化写法配合传递参数 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">	:to=&quot;&#123;</span><br><span class="line">		name:&#x27;hello&#x27;,</span><br><span class="line">		query:&#123;</span><br><span class="line">		   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="6-路由的params参数"><a href="#6-路由的params参数" class="headerlink" title="6.路由的params参数"></a>6.路由的params参数</h3><ol>
<li><p>配置路由，声明接收params参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">	<span class="attr">component</span>:<span class="title class_">Home</span>,</span><br><span class="line">	<span class="attr">children</span>:[</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">News</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">Message</span>,</span><br><span class="line">			<span class="attr">children</span>:[</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>, <span class="comment">//params参数必须的</span></span><br><span class="line">					<span class="attr">path</span>:<span class="string">&#x27;detail/:id/:title&#x27;</span>, <span class="comment">//使用占位符声明接收params参数</span></span><br><span class="line">					<span class="attr">component</span>:<span class="title class_">Detail</span></span><br><span class="line">				&#125;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>传递参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line">				</span><br><span class="line">&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;</span><br><span class="line">&lt;router-link </span><br><span class="line">	:to=&quot;&#123;</span><br><span class="line">		name:&#x27;xiangqing&#x27;,</span><br><span class="line">		params:&#123;</span><br><span class="line">		   id:666,</span><br><span class="line">            title:&#x27;你好&#x27;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！</p>
</blockquote>
</li>
<li><p>接收参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$route.<span class="property">params</span>.<span class="property">id</span></span><br><span class="line">$route.<span class="property">params</span>.<span class="property">title</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="7-路由的props配置"><a href="#7-路由的props配置" class="headerlink" title="7.路由的props配置"></a>7.路由的props配置</h3><p>​	作用：让路由组件更方便的收到参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">	<span class="attr">path</span>:<span class="string">&#x27;detail/:id&#x27;</span>,</span><br><span class="line">	<span class="attr">component</span>:<span class="title class_">Detail</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件</span></span><br><span class="line">	<span class="comment">// props:&#123;a:900&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件</span></span><br><span class="line">	<span class="comment">// props:true</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件</span></span><br><span class="line">	<span class="title function_">props</span>(<span class="params">route</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="attr">id</span>:route.<span class="property">query</span>.<span class="property">id</span>,</span><br><span class="line">			<span class="attr">title</span>:route.<span class="property">query</span>.<span class="property">title</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-的replace属性"><a href="#8-的replace属性" class="headerlink" title="8.&lt;router-link&gt;的replace属性"></a>8.<code>&lt;router-link&gt;</code>的replace属性</h3><ol>
<li>作用：控制路由跳转时操作浏览器历史记录的模式</li>
<li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li>
<li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li>
</ol>
<h3 id="9-编程式路由导航"><a href="#9-编程式路由导航" class="headerlink" title="9.编程式路由导航"></a>9.编程式路由导航</h3><ol>
<li><p>作用：不借助<code>&lt;router-link&gt; </code>实现路由跳转，让路由跳转更加灵活</p>
</li>
<li><p>从vue@3开始都是Promise风格</p>
</li>
<li><p>具体编码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//$router的两个API</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123; <span class="comment">// push</span></span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>:&#123;</span><br><span class="line">        <span class="attr">id</span>:xxx,</span><br><span class="line">        <span class="attr">title</span>:xxx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">replace</span>(&#123; <span class="comment">// replace</span></span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">    <span class="attr">params</span>:&#123;</span><br><span class="line">        <span class="attr">id</span>:xxx,</span><br><span class="line">        <span class="attr">title</span>:xxx</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">forward</span>() <span class="comment">//前进</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">back</span>() <span class="comment">//后退</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>(<span class="title class_">Number</span> n) <span class="comment">//向前或者向后跳转n个页面，n可为正整数或负整数</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="10-缓存路由组件"><a href="#10-缓存路由组件" class="headerlink" title="10.缓存路由组件"></a>10.缓存路由组件</h3><ol>
<li><p>作用：让不展示的路由组件保持挂载，不被销毁。</p>
</li>
<li><p>具体编码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive include=&quot;News&quot;&gt; </span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="11-两个新的生命周期钩子"><a href="#11-两个新的生命周期钩子" class="headerlink" title="11.两个新的生命周期钩子"></a>11.两个新的生命周期钩子</h3><ol>
<li>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</li>
<li>具体名字：<ol>
<li><code>activated</code>路由组件被激活时触发。</li>
<li><code>deactivated</code>路由组件失活时触发。</li>
</ol>
</li>
</ol>
<h3 id="12-路由守卫"><a href="#12-路由守卫" class="headerlink" title="12.路由守卫"></a>12.路由守卫</h3><ol>
<li><p>作用：对路由进行权限控制</p>
</li>
<li><p>分类：全局守卫、独享守卫、组件内守卫</p>
</li>
<li><p>全局守卫:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局前置守卫：初始化时执行、每次路由切换前执行</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeEach&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line">	<span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">isAuth</span>)&#123; <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>)&#123; <span class="comment">//权限控制的具体规则</span></span><br><span class="line">			<span class="title function_">next</span>() <span class="comment">//放行</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="title function_">alert</span>(<span class="string">&#x27;暂无权限查看&#x27;</span>)</span><br><span class="line">			<span class="comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="title function_">next</span>() <span class="comment">//放行</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局后置守卫：初始化时执行、每次路由切换后执行</span></span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to,<span class="keyword">from</span></span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;afterEach&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line">	<span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">title</span>)&#123; </span><br><span class="line">		<span class="variable language_">document</span>.<span class="property">title</span> = to.<span class="property">meta</span>.<span class="property">title</span> <span class="comment">//修改网页的title</span></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;vue_test&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>独享守卫:</p>
<p><code>写在routes数组里的对象里</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">beforeEnter</span>(<span class="params">to,<span class="keyword">from</span>,next</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeEnter&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line">	<span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">isAuth</span>)&#123; <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>)&#123;</span><br><span class="line">			<span class="title function_">next</span>()</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="title function_">alert</span>(<span class="string">&#x27;暂无权限查看&#x27;</span>)</span><br><span class="line">			<span class="comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="title function_">next</span>()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件内守卫：</p>
<p><code>写在组件里</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进入守卫：通过路由规则，进入该组件时被调用</span></span><br><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//离开守卫：通过路由规则，离开该组件时被调用</span></span><br><span class="line">beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="13-路由器的两种工作模式"><a href="#13-路由器的两种工作模式" class="headerlink" title="13.路由器的两种工作模式"></a>13.路由器的两种工作模式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">mode</span>: <span class="string">&quot;history&quot;</span>, <span class="comment">//hash</span></span><br><span class="line"><span class="attr">routes</span>: []</span><br></pre></td></tr></table></figure>

<ol>
<li>对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。</li>
<li>hash模式：<ol>
<li>从#开始都是hash值，不会发送给服务器</li>
<li>若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。</li>
<li>兼容性较好。</li>
</ol>
</li>
<li>history模式：<ol>
<li>地址干净，美观 。</li>
<li>兼容性和hash模式相比略差。<ol start="3">
<li><p>应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用中间件解决 /npm i connection-history-api-fallback</span></span><br><span class="line"><span class="keyword">const</span> history = <span class="built_in">require</span>(<span class="string">&#x27;connection-history-api-fallback);</span></span><br><span class="line"><span class="string">app.use(history());</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue2</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3笔记</title>
    <url>/2023/10/11/vue3%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Vue3快速上手"><a href="#Vue3快速上手" class="headerlink" title="Vue3快速上手"></a>Vue3快速上手</h1><img src="https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png" style="width:200px">

<span id="more"></span>

<h2 id="1-Vue3简介"><a href="#1-Vue3简介" class="headerlink" title="1.Vue3简介"></a>1.Vue3简介</h2><ul>
<li>2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）</li>
<li>耗时2年多、<a href="https://github.com/vuejs/vue-next/graphs/commit-activity">2600+次提交</a>、<a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">30+个RFC</a>、<a href="https://github.com/vuejs/vue-next/pulls?q=is:pr+is:merged+-author:app/dependabot-preview+">600+次PR</a>、<a href="https://github.com/vuejs/vue-next/graphs/contributors">99位贡献者</a></li>
<li>github上的tags地址：<a href="https://github.com/vuejs/vue-next/releases/tag/v3.0.0">https://github.com/vuejs/vue-next/releases/tag/v3.0.0</a></li>
</ul>
<h2 id="2-Vue3带来了什么"><a href="#2-Vue3带来了什么" class="headerlink" title="2.Vue3带来了什么"></a>2.Vue3带来了什么</h2><h3 id="1-性能的提升"><a href="#1-性能的提升" class="headerlink" title="1.性能的提升"></a>1.性能的提升</h3><ul>
<li><p>打包大小减少41%</p>
</li>
<li><p>初次渲染快55%, 更新渲染快133%</p>
</li>
<li><p>内存减少54%</p>
<p>……</p>
</li>
</ul>
<h3 id="2-源码的升级"><a href="#2-源码的升级" class="headerlink" title="2.源码的升级"></a>2.源码的升级</h3><ul>
<li><p>使用Proxy代替defineProperty实现响应式</p>
</li>
<li><p>重写虚拟DOM的实现和Tree-Shaking</p>
<p>……</p>
</li>
</ul>
<h3 id="3-拥抱TypeScript"><a href="#3-拥抱TypeScript" class="headerlink" title="3.拥抱TypeScript"></a>3.拥抱TypeScript</h3><ul>
<li>Vue3可以更好的支持TypeScript</li>
</ul>
<h3 id="4-新的特性"><a href="#4-新的特性" class="headerlink" title="4.新的特性"></a>4.新的特性</h3><ol>
<li><p>Composition API（组合API）</p>
<ul>
<li>setup配置</li>
<li>ref与reactive</li>
<li>watch与watchEffect</li>
<li>provide与inject</li>
<li>……</li>
</ul>
</li>
<li><p>新的内置组件</p>
<ul>
<li>Fragment</li>
<li>Teleport</li>
<li>Suspense</li>
</ul>
</li>
<li><p>其他改变</p>
<ul>
<li>新的生命周期钩子</li>
<li>data 选项应始终被声明为一个函数</li>
<li>移除keyCode支持作为 v-on 的修饰符</li>
<li>……</li>
</ul>
</li>
</ol>
<h1 id="一、创建Vue3-0工程"><a href="#一、创建Vue3-0工程" class="headerlink" title="一、创建Vue3.0工程"></a>一、创建Vue3.0工程</h1><h2 id="1-使用-vue-cli-创建"><a href="#1-使用-vue-cli-创建" class="headerlink" title="1.使用 vue-cli 创建"></a>1.使用 vue-cli 创建</h2><p>官方文档：<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上</span></span><br><span class="line">vue --version</span><br><span class="line"><span class="comment">## 安装或者升级你的@vue/cli</span></span><br><span class="line">npm install -g @vue/cli</span><br><span class="line"><span class="comment">## 创建</span></span><br><span class="line">vue create vue_test</span><br><span class="line"><span class="comment">## 启动</span></span><br><span class="line"><span class="built_in">cd</span> vue_test</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure>

<h2 id="2-使用-vite-创建"><a href="#2-使用-vite-创建" class="headerlink" title="2.使用 vite 创建"></a>2.使用 vite 创建</h2><p>官方文档：<a href="https://v3.cn.vuejs.org/guide/installation.html#vite">https://v3.cn.vuejs.org/guide/installation.html#vite</a></p>
<p>vite官网：<a href="https://vitejs.cn/">https://vitejs.cn</a></p>
<ul>
<li>什么是vite？—— 新一代前端构建工具。</li>
<li>优势如下：<ul>
<li>开发环境中，无需打包操作，可快速的冷启动。</li>
<li>轻量快速的热重载（HMR）。</li>
<li>真正的按需编译，不再等待整个应用编译完成。</li>
</ul>
</li>
<li>传统构建 与 vite构建对比图</li>
</ul>
<p><img src="https://cn.vitejs.dev/assets/bundler.37740380.png" style="width:500px;height:280px;float:left"><img src="https://cn.vitejs.dev/assets/esm.3070012d.png" style="width:480px;height:280px"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 创建工程</span></span><br><span class="line">npm init vite-app &lt;project-name&gt;</span><br><span class="line"><span class="comment">## 进入工程目录</span></span><br><span class="line"><span class="built_in">cd</span> &lt;project-name&gt;</span><br><span class="line"><span class="comment">## 安装依赖</span></span><br><span class="line">npm install</span><br><span class="line"><span class="comment">## 运行</span></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<h1 id="二、常用-Composition-API"><a href="#二、常用-Composition-API" class="headerlink" title="二、常用 Composition API"></a>二、常用 Composition API</h1><p>官方文档: <a href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">https://v3.cn.vuejs.org/guide/composition-api-introduction.html</a></p>
<h2 id="1-setup-props-context"><a href="#1-setup-props-context" class="headerlink" title="1.setup(props, context)"></a>1.setup(props, context)</h2><ol>
<li><p>理解：Vue3.0中一个新的配置项，值为一个函数。</p>
</li>
<li><p>setup是所有Composition API（组合API）“ 表演的舞台 ”。</p>
</li>
<li><p>组件中所用到的 <code>(props)</code> 一定要在其他选项里配置才行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">defineComponent</span>(</span><br><span class="line">  <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;div&#x27;</span>, props.<span class="property">num</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">num</span>: <span class="title class_">Number</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>props的原理</strong>：<ul>
<li>父组件的reactive通过props传递过来保持不变</li>
<li>父组件的ref通过props传递过来会在解包<ul>
<li>而深层的ref底层是Prox</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>setup函数的两种返回值：</p>
<ol>
<li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li>
<li><code>&lt;span style=&quot;color:#aad&quot;&gt;</code>若返回一个渲染函数：则可以自定义渲染内容。（了解）</li>
<li>返回一个Proimse对象</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回一个渲染函数</span></span><br><span class="line"><span class="keyword">import</span> &#123;h&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">()=&gt;</span> <span class="title function_">h</span>(<span class="string">&#x27;h1&#x27;</span>,<span class="string">&quot;title&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>&lt;script setup&gt;</code> 语法糖</p>
<ul>
<li><p>可以与 <code>&lt;script&gt;</code>混用，但是script里面的setup()会失效</p>
</li>
<li><p>直接写setup() 内部的内容</p>
</li>
<li><p>自动return顶层绑定,</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> b = <span class="title function_">ref</span>(<span class="number">2</span>)</span><br><span class="line"><span class="title function_">defineExpose</span>(b)  <span class="comment">//显示指定暴露给模板b</span></span><br></pre></td></tr></table></figure></li>
<li><p>如何接收props,slots, emits, 等等</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> props = <span class="title function_">defineProps</span>(&#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="title class_">String</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> emit = <span class="title function_">defineEmits</span>([<span class="string">&#x27;change&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>])</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>注意点：</p>
<ol>
<li>尽量不要与Vue2.x配置混用<ul>
<li>Vue2.x配置（data、methos、computed…）中可以访问到setup中的属性、方法.但在setup中不能访问到Vue2.x配置（data、methos、computed…）。</li>
<li>如果有重名, setup优先。</li>
</ul>
</li>
<li>setup可以是一个异步函数需要Suspense和异步引入组件的配合（详见Suspense）</li>
</ol>
</li>
</ol>
<h2 id="2-setup的两个注意点"><a href="#2-setup的两个注意点" class="headerlink" title="2.setup的两个注意点"></a>2.setup的两个注意点</h2><ul>
<li><p>setup执行的时机</p>
<ul>
<li>在beforeCreate之前执行一次，this是undefined。</li>
</ul>
</li>
<li><p>setup的参数</p>
<ul>
<li><p>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设父组件给子组件传了 三个参数 </span></span><br><span class="line">&lt;<span class="title class_">Son</span> param1=<span class="string">&quot;param1&quot;</span> param2=<span class="string">&quot;param2&quot;</span> param3=<span class="string">&quot;param3&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="attr">props</span>: [<span class="string">&#x27;param1&#x27;</span>, <span class="string">&#x27;param2&#x27;</span>] </span><br><span class="line"><span class="title function_">setup</span>(<span class="params">props, context</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(props) <span class="comment">//可以接收到param1 和 param2 ， 访问 props.param1</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(context.<span class="property">attrs</span>)<span class="comment">//可以接收到param3,  访问 context.attrs.param3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>context：上下文对象</p>
<ul>
<li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li>
<li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li>
<li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-ref函数"><a href="#3-ref函数" class="headerlink" title="3.ref函数"></a>3.ref函数</h2><ul>
<li><p>作用: 定义一个响应式的数据</p>
</li>
<li><p>语法: <code>const xxx = ref(initValue)</code></p>
<ul>
<li>创建一个包含响应式数据的引用对象（reference对象，简称ref对象</li>
<li>JS中操作数据： <code>xxx.value</code></li>
<li>模板中读取数据: 不需要.value，<code>直接：</code><div></div>&#96;&#96;</li>
</ul>
</li>
<li><p>备注：</p>
<ul>
<li><p>接收的数据可以是：基本类型、也可以是对象类型。</p>
</li>
<li><p>基本类型的数据：响应式依然是靠 <code>Object.defineProperty()</code>的 <code>get</code>与 <code>set</code>完成的。</p>
</li>
<li><p>对象、数组类型的数据：value值是调用 <code>reactive</code>函数</p>
<ul>
<li><pre><code class="js">RefImpl &#123;__v_isShallow: false, dep: undefined, __v_isRef: true, _rawValue: &#39;123&#39;, _value: &#39;123&#39;&#125;
    dep: undefined
    __v_isRef: true
    __v_isShallow: false
    _rawValue: &quot;123&quot;
    _value: &quot;123&quot;
    value: (...)
    [[Prototype]]: Object
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 4.reactive函数</span><br><span class="line"></span><br><span class="line">- 作用: 定义一个`&lt;strong style=&quot;color:#DD5145&quot;&gt;`对象类型`&lt;/strong&gt;`的响应式数据（基本类型不要用它，要用 ``ref``函数）</span><br><span class="line">- 语法：``const 代理对象= reactive(源对象)``接收一个对象（或数组），返回一个代理对象（Proxy的实例对象，简称proxy对象）</span><br><span class="line">- reactive定义的响应式数据是“深层次的”（可以相应通过下标修改的数组数据）</span><br><span class="line">- 内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</span><br><span class="line"></span><br><span class="line">## 5.Vue3.0中的响应式原理</span><br><span class="line"></span><br><span class="line">### vue2.x的响应式</span><br><span class="line"></span><br><span class="line">- 实现原理：</span><br><span class="line"></span><br><span class="line">  - 对象类型：通过 ``Object.defineProperty()``对属性的读取、修改进行拦截（数据劫持）。</span><br><span class="line">  - 数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</span><br><span class="line"></span><br><span class="line">    ```js</span><br><span class="line">    Object.defineProperty(data, &#x27;count&#x27;, &#123;</span><br><span class="line">        get () &#123;&#125;, </span><br><span class="line">        set () &#123;&#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>存在问题：</p>
<ul>
<li>新增属性、删除属性, 界面不会更新。</li>
<li>直接通过下标修改数组, 界面不会自动更新。</li>
</ul>
</li>
</ul>
<h3 id="Vue3-0的响应式"><a href="#Vue3-0的响应式" class="headerlink" title="Vue3.0的响应式"></a>Vue3.0的响应式</h3><ul>
<li><p>实现原理:</p>
<ul>
<li>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</li>
<li>通过Reflect（反射）:  对源对象的属性进行操作。</li>
<li>MDN文档中描述的Proxy与Reflect：<ul>
<li><p>Proxy：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p>
</li>
<li><p>Reflect：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span><br><span class="line">	<span class="comment">// 拦截读取属性值</span></span><br><span class="line">    get (target, prop) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, prop)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 拦截设置属性值或添加新属性</span></span><br><span class="line">    set (target, prop, value) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, prop, value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 拦截删除属性</span></span><br><span class="line">    deleteProperty (target, prop) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, prop)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span> = <span class="string">&#x27;tom&#x27;</span>   </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>Reflect</p>
<ul>
<li><pre><code class="js">Reflect.get(target, propertyKey[, receiver])
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- ```js</span><br><span class="line">  Reflect.set(target, propertyKey, value[, receiver])</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="js">Reflect.deleteProperty(target, propertyKey)
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- .defineProperty()</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">let obj = &#123;a:1, b:2&#125;</span><br><span class="line">Reflect.defineProperty(obj, &#x27;c&#x27;, 3) //给obj添加一个c: 3，返回true</span><br><span class="line">Reflect.defineProperty(obj, &#x27;c&#x27;, 4) //不生效，会返回false</span><br><span class="line">//Object.defineProperty 会直接报错</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="6-reactive对比ref"><a href="#6-reactive对比ref" class="headerlink" title="6.reactive对比ref"></a>6.reactive对比ref</h2><ul>
<li>从定义数据角度对比：<ul>
<li>ref用来定义：<code>&lt;strong style=&quot;color:#DD5145&quot;&gt;</code>基本类型数据<code>&lt;/strong&gt;</code>。</li>
<li>reactive用来定义：<code>&lt;strong style=&quot;color:#DD5145&quot;&gt;</code>对象（或数组）类型数据<code>&lt;/strong&gt;</code>。</li>
<li>备注：ref也可以用来定义<code>&lt;strong style=&quot;color:#DD5145&quot;&gt;</code>对象（或数组）类型数据<code>&lt;/strong&gt;</code>, 它内部会自动通过 <code>reactive</code>转为<code>&lt;strong style=&quot;color:#DD5145&quot;&gt;</code>代理对象<code>&lt;/strong&gt;</code>。</li>
</ul>
</li>
<li>从原理角度对比：<ul>
<li>ref通过 <code>Object.defineProperty()</code>的 <code>get</code>与 <code>set</code>来实现响应式（数据劫持）。</li>
<li>reactive通过使用<code>&lt;strong style=&quot;color:#DD5145&quot;&gt;</code>Proxy<code>&lt;/strong&gt;</code>来实现响应式（数据劫持）, 并通过<code>&lt;strong style=&quot;color:#DD5145&quot;&gt;</code>Reflect<code>&lt;/strong&gt;</code>操作<code>&lt;strong style=&quot;color:orange&quot;&gt;</code>源对象<code>&lt;/strong&gt;</code>内部的数据。</li>
</ul>
</li>
<li>从使用角度对比：<ul>
<li>ref定义的数据：操作数据<code>&lt;strong style=&quot;color:#DD5145&quot;&gt;</code>需要<code>&lt;/strong&gt;```.value``，读取数据时模板中直接读取</code><strong style="color:#DD5145"><code>不需要</code></strong>&#96;&#96;&#96;.value&#96;&#96;。</li>
<li>reactive定义的数据：操作数据与读取数据：<code>&lt;strong style=&quot;color:#DD5145&quot;&gt;</code>均不需要&#96;&#96;&#96;&#96;.value&#96;&#96;。</li>
</ul>
</li>
</ul>
<h2 id="7-计算属性与监视"><a href="#7-计算属性与监视" class="headerlink" title="7.计算属性与监视"></a>7.计算属性与监视</h2><h3 id="1-computed函数"><a href="#1-computed函数" class="headerlink" title="1.computed函数"></a>1.computed函数</h3><ul>
<li><p>与Vue2.x中computed配置功能一致</p>
</li>
<li><p>写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;computed&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">//计算属性——简写</span></span><br><span class="line">    <span class="keyword">let</span> fullName = <span class="title function_">computed</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person.<span class="property">firstName</span> + <span class="string">&#x27;-&#x27;</span> + person.<span class="property">lastName</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//计算属性——完整</span></span><br><span class="line">    <span class="keyword">let</span> fullName = <span class="title function_">computed</span>(&#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> person.<span class="property">firstName</span> + <span class="string">&#x27;-&#x27;</span> + person.<span class="property">lastName</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">value</span>)&#123;</span><br><span class="line">            <span class="keyword">const</span> nameArr = value.<span class="title function_">split</span>(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            person.<span class="property">firstName</span> = nameArr[<span class="number">0</span>]</span><br><span class="line">            person.<span class="property">lastName</span> = nameArr[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-watch函数"><a href="#2-watch函数" class="headerlink" title="2.watch函数"></a>2.watch函数</h3><ul>
<li><p>与Vue2.x中watch配置功能一致</p>
</li>
<li><p>两个小“坑”：</p>
<ul>
<li>监视reactive定义的响应式数据中某个属性时：deep配置有效。</li>
</ul>
</li>
<li><p><code>&lt;text style=&quot;color:red&quot;&gt;</code>重要<code>&lt;/text&gt;</code></p>
<ul>
<li>默认情况下，侦听器回调会在父组件更新 (如有) 之后、所属组件的 DOM 更新之前被调用</li>
<li><code>flush: post</code> 在组件渲染后执行</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> domNode = <span class="title function_">ref</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="title function_">watch</span>(domNode,<span class="function">(<span class="params">value</span>)=&gt;</span> &#123;&#125;, &#123;<span class="attr">flush</span>: post&#125;)</span><br><span class="line">...</span><br><span class="line">&lt;div ref=<span class="string">&#x27;domNode&#x27;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>watch 第一个参数可以是 getter, ref, proxy,</p>
<ul>
<li>getter:</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">watch</span>(</span><br><span class="line">  <span class="function">() =&gt;</span> x.<span class="property">value</span> + y.<span class="property">value</span>,</span><br><span class="line">  <span class="function">(<span class="params">sum</span>) =&gt;</span>  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`sum of x + y is: <span class="subst">$&#123;sum&#125;</span>`</span>) </span><br><span class="line">) </span><br></pre></td></tr></table></figure>

<ul>
<li>ref:<ul>
<li>自动对x深层监听（因为ref有深层对象时底层调用reactive）</li>
<li>newValue自动解包</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">watch</span>(x, <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`x is <span class="subst">$&#123;newX&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>proxy:<ul>
<li>自动深层监听</li>
<li>监听对象是proxy时，newVal 和 oldVal 是同一个对象</li>
<li>只监听某个属性则要写成getter写法<ul>
<li>getter不会自动开启deep</li>
<li>getter如果返回原始类型则 oldVal有效；</li>
<li>getter如果返回引用类型则 只有更改了对象或者开启deep才能监听到</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title function_">reactive</span>(&#123;<span class="attr">count</span>: <span class="number">0</span>&#125;)</span><br><span class="line"><span class="title function_">watch</span>(obj, <span class="function">(<span class="params">newVal, oldVal</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`count is: <span class="subst">$&#123;obj.newVal&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>obj.<span class="property">count</span>, <span class="function">()=&gt;</span>&#123;&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-watchEffect函数"><a href="#3-watchEffect函数" class="headerlink" title="3.watchEffect函数"></a>3.watchEffect函数</h3><ul>
<li><p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p>
</li>
<li><p>watchEffect的套路是：<code>&lt;u&gt;</code>不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性<code>&lt;/u&gt;</code>。</p>
</li>
<li><p>watchEffect有点像computed：</p>
<ul>
<li>但是watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li>
<li>默认开启immediate : true</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。</span></span><br><span class="line"><span class="keyword">const</span> watch1 = <span class="title function_">watchEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> x1 = sum.<span class="property">value</span></span><br><span class="line">    <span class="keyword">const</span> x2 = person.<span class="property">age</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;watchEffect配置的回调执行了&#x27;</span>)</span><br><span class="line">&#125;，&#123;</span><br><span class="line">       <span class="attr">flush</span>:<span class="string">&#x27;post&#x27;</span> <span class="comment">//Dom更新后触发侦听器回调</span></span><br><span class="line">            &#125;)</span><br><span class="line"><span class="comment">//停止侦听器</span></span><br><span class="line"><span class="title function_">watch1</span>()</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>注意： 当依赖项改变后，先触发侦听器回调再触发update，所以侦听器回调访问到的是更新前的Dom</p>
</blockquote>
<h2 id="8-生命周期"><a href="#8-生命周期" class="headerlink" title="8.生命周期"></a>8.生命周期</h2><p>vue3的生命周期 <code>&lt;img src=&quot;https://cn.vuejs.org/assets/lifecycle.16e4c08e.png&quot; alt=&quot;lifecycle_2&quot;  /&gt;</code></p>
<ul>
<li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子—(选项式api)，但有有两个被更名：<ul>
<li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li>
<li><code>destroyed</code>改名为 <code>unmounted</code></li>
</ul>
</li>
<li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：<ul>
<li><code>beforeCreate</code>&#x3D;&#x3D;&#x3D;&gt;<code>setup()</code></li>
<li><code>created</code>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>setup()</code></li>
<li><code>beforeMount</code> &#x3D;&#x3D;&#x3D;&gt;<code>onBeforeMount</code></li>
<li><code>mounted</code>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onMounted</code></li>
<li><code>beforeUpdate</code>&#x3D;&#x3D;&#x3D;&gt;<code>onBeforeUpdate</code></li>
<li><code>updated</code> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onUpdated</code></li>
<li><code>beforeUnmount</code> &#x3D;&#x3D;&gt;<code>onBeforeUnmount</code></li>
<li><code>unmounted</code> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;<code>onUnmounted</code></li>
</ul>
</li>
</ul>
<h2 id="9-自定义hook函数"><a href="#9-自定义hook函数" class="headerlink" title="9.自定义hook函数"></a>9.自定义hook函数</h2><ul>
<li><p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &quot;/hook/useHook.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// ... 一系列变量</span></span><br><span class="line">    <span class="comment">// ... 一系列方法</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &quot;/app.vue/&quot;</span></span><br><span class="line"><span class="keyword">import</span> useHook <span class="keyword">from</span> <span class="string">&#x27;./hook/useHook.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">       <span class="comment">// ...一系列操作</span></span><br><span class="line">        <span class="keyword">const</span> result = <span class="title function_">useHook</span>(); <span class="comment">//接收过来了</span></span><br><span class="line">        <span class="keyword">return</span> &#123;result&#125; <span class="comment">//可以放到模板里</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="10-toRef"><a href="#10-toRef" class="headerlink" title="10.toRef"></a>10.toRef</h2><ul>
<li><p>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。</p>
</li>
<li><p>语法：<code>const name = toRef(person,&#39;propName&#39;)</code></p>
</li>
<li><p>应用:   要将响应式对象中的某个属性单独提供给外部使用时。</p>
</li>
<li><p>扩展：<code>toRefs</code> 与 <code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;</span><br><span class="line">    	<span class="attr">key1</span>: <span class="number">1</span>,</span><br><span class="line">    	<span class="attr">key2</span>: <span class="number">2</span>,</span><br><span class="line">    	<span class="attr">key3</span>: <span class="number">3</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        ...<span class="title function_">toRefs</span>(obj)<span class="comment">//把所有属性暴露给模板</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//torefs(obj) </span></span><br><span class="line">&#123;<span class="attr">key1</span>: <span class="title class_">ObjectRefImpl</span>, <span class="attr">key2</span>: <span class="title class_">ObjectRefImpl</span>, <span class="attr">key3</span>: <span class="title class_">ObjectRefImpl</span>&#125;</span><br><span class="line"><span class="attr">key1</span>: <span class="title class_">ObjectRefImpl</span> &#123;<span class="attr">_object</span>: <span class="title class_">Proxy</span>(<span class="title class_">Object</span>), <span class="attr">_key</span>: <span class="string">&#x27;key1&#x27;</span>, <span class="attr">_defaultValue</span>: <span class="literal">undefined</span>, <span class="attr">__v_isRef</span>: <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">key2</span>: <span class="title class_">ObjectRefImpl</span> &#123;<span class="attr">_object</span>: <span class="title class_">Proxy</span>(<span class="title class_">Object</span>), <span class="attr">_key</span>: <span class="string">&#x27;key2&#x27;</span>, <span class="attr">_defaultValue</span>: <span class="literal">undefined</span>, <span class="attr">__v_isRef</span>: <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">key3</span>: <span class="title class_">ObjectRefImpl</span> &#123;<span class="attr">_object</span>: <span class="title class_">Proxy</span>(<span class="title class_">Object</span>), <span class="attr">_key</span>: <span class="string">&#x27;key3&#x27;</span>, <span class="attr">_defaultValue</span>: <span class="literal">undefined</span>, <span class="attr">__v_isRef</span>: <span class="literal">true</span>&#125;</span><br><span class="line"></span><br><span class="line">[[<span class="title class_">Prototype</span>]]: <span class="title class_">Object</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="11-ref引用"><a href="#11-ref引用" class="headerlink" title="11.ref引用"></a>11.ref引用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;input ref=&quot;inputRef&quot;&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123;ref&#125; from &#x27;vue&#x27;</span><br><span class="line">//inputRef.value ===&gt;  input元素的引用</span><br><span class="line">const inputRef = ref(null)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>####在v-for的标签上使用ref引用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 获得元素数组 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;itemRefs&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123; item &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="在组件上使用ref引用"><a href="#在组件上使用ref引用" class="headerlink" title="在组件上使用ref引用"></a>在组件上使用ref引用</h4><ol>
<li>获得组件实例</li>
<li>如果子组件用了 <code>&lt;script setup&gt;</code>，则<strong>默认组件私有</strong>，得不到任何东西。<ol>
<li>可以在子组件中 <code>defineExpose(&#123;&#125;)</code>宏显式暴露</li>
</ol>
</li>
</ol>
<h2 id="12-定义组件"><a href="#12-定义组件" class="headerlink" title="12.定义组件"></a>12.定义组件</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123; count &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;button @click=&quot;count++&quot;&gt;</span></span><br><span class="line"><span class="string">      You clicked me &#123;&#123; count &#125;&#125; times.</span></span><br><span class="line"><span class="string">    &lt;/button&gt;`</span></span><br><span class="line">  <span class="comment">// 也可以针对一个 DOM 内联模板：</span></span><br><span class="line">  <span class="comment">// template: &#x27;#my-template-element&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式二</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;button-counter&quot;</span>,</span><br><span class="line">    <span class="attr">props</span>: [<span class="string">&quot;count&quot;</span>],</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="title function_">onClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.$emit(<span class="string">&quot;change&quot;</span>, <span class="variable language_">this</span>.<span class="property">count</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// console.log(&quot;render.this&quot;, this) //指向vc</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.onClick&#125;</span>&gt;</span>数量 &#123;this.count&#125;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="动态组件-is"><a href="#动态组件-is" class="headerlink" title="动态组件 :is"></a>动态组件 :is</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;component :is=&quot;被注册的组件名、导入的组件对象&quot;&gt;&lt;/component&gt;</span><br></pre></td></tr></table></figure>

<p><strong>is的另一种用法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;tr is=&quot;vue:blog-post-row&quot;&gt;&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>

<h3 id="注册组件"><a href="#注册组件" class="headerlink" title="注册组件"></a>注册组件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> componentName <span class="keyword">from</span> <span class="string">&#x27;./component/componentName&#x27;</span></span><br><span class="line">app.<span class="title function_">component</span>(<span class="string">&#x27;componentName&#x27;</span>,componentName)</span><br></pre></td></tr></table></figure>

<h2 id="13-传递props"><a href="#13-传递props" class="headerlink" title="13.传递props"></a>13.传递props</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  	//defineProps来接收父组件props </span><br><span class="line">	const props = defineProps([&#x27;title&#x27;])</span><br><span class="line">    //props.title 使用</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="14-自定义事件"><a href="#14-自定义事件" class="headerlink" title="14.自定义事件"></a>14.自定义事件</h2><p>同vue2</p>
<h2 id="15-路由"><a href="#15-路由" class="headerlink" title="15.  路由"></a>15.  路由</h2><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ol>
<li><pre><code class="bash">npm i vue-router@4
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2. ```js</span><br><span class="line">   // 在src/router/index.js</span><br><span class="line">   import &#123; createRouter,createWebHashHistory &#125; from &quot;vue-router&quot;;</span><br><span class="line"></span><br><span class="line">   const routes = [&#123;</span><br><span class="line">       path: &#x27;/&#x27;,</span><br><span class="line">       name: &#x27;index&#x27;,</span><br><span class="line">       component: App</span><br><span class="line">   &#125;]</span><br><span class="line"></span><br><span class="line">   const router = createRouter(&#123;</span><br><span class="line">     	history:createWebHashHistory(),</span><br><span class="line">       routes</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   export default router</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="js">//在 main.js
import router from &#39;./router&#39;
...
app.use(router)
...
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 使用</span><br><span class="line"></span><br><span class="line">```vue</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">    import &#123; useRouter &#125; from &#x27;vue-router&#x27;</span><br><span class="line">    const router = useRouter()</span><br><span class="line">    ...</span><br><span class="line">    const gotoAbout = () =&gt; &#123;</span><br><span class="line">      router.push(&#x27;/about&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt; </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h1 id="三、其它-Composition-API"><a href="#三、其它-Composition-API" class="headerlink" title="三、其它 Composition API"></a>三、其它 Composition API</h1><h2 id="1-shallowReactive-与-shallowRef"><a href="#1-shallowReactive-与-shallowRef" class="headerlink" title="1.shallowReactive 与 shallowRef"></a>1.shallowReactive 与 shallowRef</h2><ul>
<li><p><code>shallowReactive</code>：只处理对象<strong>最外层</strong>属性的响应式（浅响应式）。</p>
</li>
<li><p><code>shallowRef</code>：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p>
</li>
<li><p>什么时候使用?</p>
<ul>
<li>如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 &#x3D;&#x3D;&#x3D;&gt; shallowReactive。</li>
<li>如果有一个对象数据，后续功能不会修改该对象中的属性，而是产生新的对象来替换 &#x3D;&#x3D;&#x3D;&gt; shallowRef。</li>
</ul>
</li>
</ul>
<h2 id="2-readonly-与-shallowReadonly"><a href="#2-readonly-与-shallowReadonly" class="headerlink" title="2.readonly 与 shallowReadonly"></a>2.readonly 与 shallowReadonly</h2><ul>
<li>readonly: 让一个响应式数据变为只读的（深只读）。</li>
<li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li>
<li>应用场景: 不希望数据被修改时。</li>
</ul>
<h2 id="3-toRaw-与-markRaw"><a href="#3-toRaw-与-markRaw" class="headerlink" title="3.toRaw 与 markRaw"></a>3.toRaw 与 markRaw</h2><ul>
<li>toRaw：<ul>
<li>作用：将一个由 <code>reactive</code>生成的响应式对象<strong>转为普通对象</strong>。</li>
<li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li>
</ul>
</li>
<li>markRaw：<ul>
<li>作用：标记一个对象，使其<em>永远不会再成为响应式对象</em>。</li>
<li>应用场景:<ol>
<li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li>
<li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="4-customRef"><a href="#4-customRef" class="headerlink" title="4.customRef"></a>4.customRef</h2><ul>
<li><p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p>
</li>
<li><p>实现防抖效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;</span><br><span class="line">	&lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	import &#123;ref,customRef&#125; from &#x27;vue&#x27;</span><br><span class="line">	export default &#123;</span><br><span class="line">		name:&#x27;Demo&#x27;,</span><br><span class="line">		setup()&#123;</span><br><span class="line">			// let keyword = ref(&#x27;hello&#x27;) //使用Vue准备好的内置ref</span><br><span class="line">			//自定义一个myRef</span><br><span class="line">			function myRef(value,delay)&#123;</span><br><span class="line">				let timer</span><br><span class="line">				//通过customRef去实现自定义</span><br><span class="line">				return customRef((track,trigger)=&gt;&#123;</span><br><span class="line">					return&#123;</span><br><span class="line">						get()&#123;</span><br><span class="line">							track() //告诉Vue这个value值是需要被“追踪”的</span><br><span class="line">							return value</span><br><span class="line">						&#125;,</span><br><span class="line">						set(newValue)&#123;</span><br><span class="line">							clearTimeout(timer)</span><br><span class="line">							timer = setTimeout(()=&gt;&#123;</span><br><span class="line">								value = newValue</span><br><span class="line">								trigger() //告诉Vue去更新界面</span><br><span class="line">							&#125;,delay)</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">			let keyword = myRef(&#x27;hello&#x27;,500) //使用程序员自定义的ref</span><br><span class="line">			return &#123;</span><br><span class="line">				keyword</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-provide-与-inject"><a href="#5-provide-与-inject" class="headerlink" title="5.provide 与 inject"></a>5.provide 与 inject</h2><ul>
<li><p><strong>底层</strong>：不做任何处理直接提供引用 （与props不同）</p>
</li>
<li><p>作用：实现<strong>祖与后代</strong>组件间通信</p>
</li>
<li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p>
</li>
<li><p>具体写法：</p>
<ol>
<li><p>祖组件中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">let</span> car = <span class="title function_">reactive</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;奔驰&#x27;</span>,<span class="attr">price</span>:<span class="string">&#x27;40万&#x27;</span>&#125;)</span><br><span class="line">    <span class="keyword">let</span> something = <span class="title function_">ref</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="title function_">provide</span>(<span class="string">&#x27;car&#x27;</span>,car) <span class="comment">//分别是 *注入名 *注入属性（可以是响应式的）</span></span><br><span class="line">    <span class="title function_">provide</span>(<span class="string">&#x27;something&#x27;</span>, something) <span class="comment">//不需要something.value</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>后代组件中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params">props,context</span>)&#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">const</span> car = <span class="title function_">inject</span>(<span class="string">&#x27;car&#x27;</span> [,<span class="keyword">default</span>]) <span class="comment">//按照注入名来接收, 可以有默认值</span></span><br><span class="line">    <span class="keyword">const</span> something = <span class="title function_">inject</span>(<span class="string">&#x27;something&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;car, something&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h2 id="6-响应式数据的判断"><a href="#6-响应式数据的判断" class="headerlink" title="6.响应式数据的判断"></a>6.响应式数据的判断</h2><ul>
<li><p><code>isRef</code>: 检查一个值是否为一个 ref 对象</p>
</li>
<li><p><code>isReactive</code>: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</p>
</li>
<li><p><code>isReadonly</code>: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</p>
</li>
<li><p><code>isProxy</code>: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="title function_">ref</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="title function_">isProxy</span>(arr) <span class="comment">//false</span></span><br><span class="line"><span class="title function_">isProxy</span>(arr.<span class="property">value</span>) <span class="comment">// true !</span></span><br><span class="line"><span class="comment">//说明对象类型的ref的value是借助reactive实现，而reactive用到了Proxy</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="四、Composition-API-的优势"><a href="#四、Composition-API-的优势" class="headerlink" title="四、Composition API 的优势"></a>四、Composition API 的优势</h1><h2 id="1-Options-API-存在的问题"><a href="#1-Options-API-存在的问题" class="headerlink" title="1.Options API 存在的问题"></a>1.Options API 存在的问题</h2><p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p>
<div style="width:600px;height:370px;overflow:hidden;float:left">
    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image" style="width:600px;float:left">
</div>
<div style="width:300px;height:370px;overflow:hidden;float:left">
    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image" style="zoom:50%;width:560px;left"> 
</div>

<h2 id="2-Composition-API-的优势"><a href="#2-Composition-API-的优势" class="headerlink" title="2.Composition API 的优势"></a>2.Composition API 的优势</h2><p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p>
<div style="width:500px;height:340px;overflow:hidden;float:left">
    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image" style="height:360px">
</div>
<div style="width:430px;height:340px;overflow:hidden;float:left">
    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image" style="height:360px">
</div>

<h1 id="五、新的组件"><a href="#五、新的组件" class="headerlink" title="五、新的组件"></a>五、新的组件</h1><h2 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1.Fragment"></a>1.Fragment</h2><ul>
<li>在Vue2中: 组件必须有一个根标签</li>
<li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li>
<li>好处: 减少标签层级, 减小内存占用</li>
</ul>
<h2 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h2><ul>
<li><p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的组件html结构移动到指定位置的技术。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 可以写css选择器 --&gt;</span><br><span class="line">&lt;teleport to=&quot;body&quot;&gt;    &lt;!-- 移动到body标签里的最下面 --&gt;</span><br><span class="line">	&lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;</span><br><span class="line">		&lt;div class=&quot;dialog&quot;&gt;</span><br><span class="line">			&lt;h3&gt;我是一个弹窗&lt;/h3&gt;</span><br><span class="line">			&lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/teleport&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-Suspense"><a href="#3-Suspense" class="headerlink" title="3.Suspense"></a>3.Suspense</h2><ul>
<li><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p>
</li>
<li><p>使用步骤：</p>
<ul>
<li><p><strong>异步引入组件</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;defineAsyncComponent&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;./components/Child.vue&#x27;</span>))</span><br></pre></td></tr></table></figure></li>
<li><p>使用 <code>Suspense</code>包裹组件，并配置好 <code>default</code> 与 <code>fallback</code></p>
<ul>
<li>Suspense组件内部有两个 <code>具名插槽</code>，分别表示需要 <code>正常展示</code>的内容和 <code>没有加载出来</code>时的内容</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div class=&quot;app&quot;&gt;</span><br><span class="line">		&lt;h3&gt;我是App组件&lt;/h3&gt;</span><br><span class="line">		&lt;Suspense&gt;</span><br><span class="line">			&lt;template v-slot:default&gt;</span><br><span class="line">				&lt;Child/&gt;</span><br><span class="line">			&lt;/template&gt;</span><br><span class="line">			&lt;template v-slot:fallback&gt;</span><br><span class="line">				&lt;h3&gt;加载中.....&lt;/h3&gt;</span><br><span class="line">			&lt;/template&gt;</span><br><span class="line">		&lt;/Suspense&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>setup返回promise对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 父组件必须异步引入子组件</span></span><br><span class="line"><span class="comment">//2. 父组件必需</span></span><br><span class="line">&lt;<span class="title class_">Suspense</span>&gt;</span><br><span class="line">    &lt;<span class="title class_">Child</span>&gt;<span class="language-xml"><span class="tag">&lt;<span class="name">Child</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Suspense</span>/&gt;</span></span></span><br><span class="line"><span class="comment">//2. 子组件中</span></span><br><span class="line">setup () &#123;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="title function_">ref</span>(<span class="number">0</span>); </span><br><span class="line">   		<span class="comment">//setup 返回一个Pormise对象，其中PromiseResult是RefImpl对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span> &#123; </span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="title function_">resolve</span>(&#123;count&#125;) <span class="comment">//! count要用&#123;&#125;包裹</span></span><br><span class="line">            &#125;, <span class="number">1200</span>);</span><br><span class="line">        &#125;)  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//另一种</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="title function_">ref</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> asyncCount = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123; </span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(&#123; count &#125;)</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">    &#125;) </span><br><span class="line">    <span class="comment">// console.log(await asyncCount) //&#123;count: RefImpl&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> asyncCount </span><br><span class="line">    <span class="comment">//返回不了？？？ =&gt; 看上一行，是count， 所以模板里面不要用asyncCount</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="3-KeepAlive"><a href="#3-KeepAlive" class="headerlink" title="3.KeepAlive"></a>3.KeepAlive</h2><ul>
<li>多个组件间动态切换时缓存被移除的组件实例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;KeepAlive&gt;</span><br><span class="line">  &lt;component :is=&quot;activeComponent&quot; /&gt;</span><br><span class="line">&lt;/KeepAlive&gt;</span><br></pre></td></tr></table></figure>

<h1 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h1><h2 id="1-全局API的转移"><a href="#1-全局API的转移" class="headerlink" title="1.全局API的转移"></a>1.全局API的转移</h2><ul>
<li><p>Vue 2.x 有许多全局 API 和配置。</p>
<ul>
<li><p>例如：注册全局组件、注册全局指令等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册全局组件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;MyButton&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册全局指令</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">inserted</span>: <span class="function"><span class="params">el</span> =&gt;</span> el.<span class="title function_">focus</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Vue3.0中对这些API做出了调整：</p>
<ul>
<li>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上<table>
<thead>
<tr>
<th>2.x 全局 API（<code>Vue</code>）</th>
<th>3.x 实例 API (<code>app</code>)</th>
</tr>
</thead>
<tbody><tr>
<td>Vue.config.xxxx</td>
<td>app.config.xxxx</td>
</tr>
<tr>
<td>Vue.config.productionTip</td>
<td>移除</td>
</tr>
<tr>
<td>Vue.component</td>
<td>app.component</td>
</tr>
<tr>
<td>Vue.directive</td>
<td>app.directive</td>
</tr>
<tr>
<td>Vue.mixin</td>
<td>app.mixin</td>
</tr>
<tr>
<td>Vue.use</td>
<td>app.use</td>
</tr>
<tr>
<td>Vue.prototype</td>
<td>app.config.globalProperties</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="title function_">create</span>(<span class="title class_">App</span>).<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br><span class="line"><span class="comment">//修改为</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">create</span>(<span class="title class_">App</span>) <span class="comment">//此时拿到了app</span></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="2-其他改变"><a href="#2-其他改变" class="headerlink" title="2.其他改变"></a>2.其他改变</h2><ul>
<li><p>data选项应始终被声明为一个函数。</p>
</li>
<li><p>过度类名的更改：</p>
<ul>
<li><p>Vue2.x写法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.v-enter</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.v-leave</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Vue3.x写法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.v-enter-from</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.v-leave-from</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持 <code>config.keyCodes</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue.config.keyCodes.huiche = 13</span><br><span class="line">&lt;p @keydown.13=&quot;fn&quot;&gt;asd&lt;p/&gt;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>移除</strong> <code>v-on.native</code>修饰符</p>
<ul>
<li><p>父组件中绑定事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;my-component</span><br><span class="line">  v-on:close=&quot;handleComponentEvent&quot;</span><br><span class="line">  v-on:click=&quot;handleNativeClickEvent&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>子组件中声明自定义事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    emits: [&#x27;close&#x27;] //接收了close代表是自定义事件，没接收的click代表是原生事件</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>移除</strong>过滤器（filter）</p>
<blockquote>
<p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p>
</blockquote>
</li>
<li><p>……</p>
</li>
</ul>
<h1 id="七、pinia"><a href="#七、pinia" class="headerlink" title="七、pinia"></a>七、pinia</h1><h2 id="1-storeToRefs"><a href="#1-storeToRefs" class="headerlink" title="1.storeToRefs"></a>1.storeToRefs</h2><ul>
<li>只需要响应式state时使用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; storeToRefs &#125; from &#x27;pinia&#x27;</span><br><span class="line">const store = useCounterStore()</span><br><span class="line">// `name` 和 `doubleCount` 是响应式的 ref</span><br><span class="line">// 同时通过插件添加的属性也会被提取为 ref</span><br><span class="line">// 并且会跳过所有的 action 或非响应式 (不是 ref 或 reactive) 的属性</span><br><span class="line">const &#123; name, doubleCount &#125; = storeToRefs(store)</span><br><span class="line">// 作为 action 的 increment 可以直接解构</span><br><span class="line">const &#123; increment &#125; = store</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="2-reset-–-仅选项式可用"><a href="#2-reset-–-仅选项式可用" class="headerlink" title="2.$reset() – 仅选项式可用"></a>2.$reset() – 仅选项式可用</h2><ul>
<li>重置为初始值</li>
<li>仅选项式可用</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="title function_">useStore</span>()</span><br><span class="line">store.$reset()</span><br></pre></td></tr></table></figure>

<h2 id="3-patch"><a href="#3-patch" class="headerlink" title="3.$patch"></a>3.$patch</h2><ul>
<li>同时修改多个属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.$patch(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">  state.<span class="property">items</span>.<span class="title function_">push</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;shoes&#x27;</span>, <span class="attr">quantity</span>: <span class="number">1</span> &#125;)</span><br><span class="line">  state.<span class="property">hasChanged</span> = <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>替换属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这实际上并没有替换`$state`</span></span><br><span class="line">store.<span class="property">$state</span> = &#123; <span class="attr">count</span>: <span class="number">24</span> &#125;</span><br><span class="line"><span class="comment">// 在它内部调用 `$patch()`：</span></span><br><span class="line">store.$patch(&#123; <span class="attr">count</span>: <span class="number">24</span> &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="八、Vue-for-Typescript"><a href="#八、Vue-for-Typescript" class="headerlink" title="八、Vue for Typescript"></a>八、Vue for Typescript</h1><h2 id="为props标注类型"><a href="#为props标注类型" class="headerlink" title="为props标注类型"></a>为props标注类型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在泛型里标注</span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">//写法一：</span><br><span class="line">const props = defineProps&lt;&#123;</span><br><span class="line">  foo: string</span><br><span class="line">  bar?: number</span><br><span class="line">&#125;&gt;()</span><br><span class="line"></span><br><span class="line">//写法二：抽成接口</span><br><span class="line">interface Props &#123;</span><br><span class="line">  foo: string</span><br><span class="line">  bar?: number</span><br><span class="line">&#125;</span><br><span class="line">const props = defineProps&lt;Props&gt;()</span><br><span class="line"></span><br><span class="line">// 解构默认值</span><br><span class="line">const props = </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="解构默认值"><a href="#解构默认值" class="headerlink" title="解构默认值"></a>解构默认值</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> props = <span class="title function_">withDefaults</span>(defineProps&lt;<span class="title class_">Props</span>&gt;(), &#123;</span><br><span class="line">  <span class="attr">msg</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">labels</span>: <span class="function">() =&gt;</span> [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="为emits标注类型"><a href="#为emits标注类型" class="headerlink" title="为emits标注类型"></a>为emits标注类型</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> emit = defineEmits&lt;&#123;</span><br><span class="line">    <span class="attr">change</span>: [<span class="attr">id</span>: <span class="built_in">number</span>]</span><br><span class="line">    <span class="attr">update</span>: [<span class="attr">value</span>: <span class="built_in">string</span>]</span><br><span class="line">  <span class="comment">//自定义事件名： [参数名: 类型]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为ref标注"><a href="#为ref标注" class="headerlink" title="为ref标注"></a>为ref标注</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> year = ref&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt;(<span class="string">&#x27;2020&#x27;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 推导得到的类型：Ref&lt;number | undefined&gt;</span></span><br><span class="line"><span class="keyword">const</span> n = ref&lt;<span class="built_in">number</span>&gt;()</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="为reactive标注"><a href="#为reactive标注" class="headerlink" title="为reactive标注"></a>为reactive标注</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以接口的形式</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span></span><br><span class="line">  year?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">book</span>: <span class="title class_">Book</span> = <span class="title function_">reactive</span>(&#123; <span class="attr">title</span>: <span class="string">&#x27;Vue3&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="为computed-标注"><a href="#为computed-标注" class="headerlink" title="为computed() 标注"></a>为computed() 标注</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以泛型的方式</span></span><br><span class="line"><span class="keyword">const</span> double = computed&lt;<span class="built_in">number</span>&gt;(<span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="为事件处理函数标注"><a href="#为事件处理函数标注" class="headerlink" title="为事件处理函数标注"></a>为事件处理函数标注</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该函数是事件处理调用的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleChange</span>(<span class="params">event: Event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>((event.<span class="property">target</span> <span class="keyword">as</span> <span class="title class_">HTMLInputElement</span>).<span class="property">value</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为provide-inject-函数标注类型"><a href="#为provide-inject-函数标注类型" class="headerlink" title="为provide&#x2F; inject 函数标注类型"></a>为provide&#x2F; inject 函数标注类型</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 创建一个 /provision/index.ts</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">InjectionKey</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> key = <span class="title class_">Symbol</span>() <span class="keyword">as</span> <span class="title class_">InjectionKey</span>&lt;<span class="built_in">string</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> key</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 父组件的setup里</span></span><br><span class="line"><span class="keyword">import</span> key <span class="keyword">from</span> <span class="string">&#x27;./provisions/index&#x27;</span></span><br><span class="line"><span class="title function_">provide</span>(key, <span class="string">&quot;I&#x27;m from App.vue by provide&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 子组件</span></span><br><span class="line"><span class="keyword">const</span> inj = inject&lt;<span class="built_in">string</span>&gt;(key)</span><br></pre></td></tr></table></figure>

<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="样式作用到全局"><a href="#样式作用到全局" class="headerlink" title="样式作用到全局"></a>样式作用到全局</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">:<span class="built_in">global</span>(body ) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="triggerRef-触发shallowRef的内部变量的副作用"><a href="#triggerRef-触发shallowRef的内部变量的副作用" class="headerlink" title="triggerRef() 触发shallowRef的内部变量的副作用"></a>triggerRef() 触发shallowRef的内部变量的副作用</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">state</span>: <span class="title class_">ShallowRef</span> = <span class="title function_">shallowRef</span>(&#123;<span class="attr">count</span>: <span class="number">0</span>&#125;)</span><br><span class="line"><span class="title function_">watch</span>(state, <span class="function">(<span class="params">val</span>)=&gt;</span><span class="variable language_">console</span>.<span class="title function_">log</span>(val))</span><br><span class="line"></span><br><span class="line">state.<span class="property">value</span>.<span class="property">count</span>++</span><br><span class="line"><span class="title function_">triggerRef</span>(state);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="app-directive"><a href="#app-directive" class="headerlink" title="app.directive"></a>app.directive</h2><p>全局指令必须在app.mount之前注册！</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack学习</title>
    <url>/2023/11/05/webpack%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><p>webpack本身</p>
<ul>
<li>支持CommonJs语法</li>
<li>只能编译js json, <ul>
<li>js的es语法,这样可以让浏览器识别es语法,但是对于ES6老浏览器不支持，需要用babel转成ES5</li>
</ul>
</li>
</ul>
<span id="more"></span>

<h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><h3 id="处理css资源"><a href="#处理css资源" class="headerlink" title="处理css资源"></a>处理css资源</h3><ol>
<li><pre><code class="shell">npm i css-loader style-loader -D
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```js</span><br><span class="line">           //使用loader</span><br><span class="line">           rules: [&#123;</span><br><span class="line">               //test： 正则匹配 文件</span><br><span class="line">               //use: 按数组顺序从右向左执行</span><br><span class="line">               test:  /\.css$/,</span><br><span class="line">               use: [&#x27;style-loader&#x27;,&#x27;css-loader&#x27;]</span><br><span class="line">           &#125;</span><br><span class="line">       ],</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p><code>public/index.html</code>下引入</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 导入webpack打包的文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../dist/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>src/index.js</code>下导入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./css/index.css&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>打包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p><code>style-loader</code>的作用是把 <code>CSS</code> 插入到 <code>DOM</code> 中，就是处理<code>css-loader</code>导出的模块数组，然后将样式通过<code>style</code>标签或者其他形式插入到<code>DOM</code>中。</p>
</blockquote>
<h3 id="处理sass"><a href="#处理sass" class="headerlink" title="处理sass"></a>处理sass</h3><ol>
<li><pre><code class="shell">npm i sass-loader sass -D
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```js</span><br><span class="line">           //使用loader</span><br><span class="line">           rules: [&#123;</span><br><span class="line">               //test： 正则匹配 文件</span><br><span class="line">               //use: 按数组顺序从右向左执行</span><br><span class="line">               test:  /\.less$/,</span><br><span class="line">               use: [&#x27;style-loader&#x27;,&#x27;css-loader&#x27;,&#x27;less-loader&#x27;]</span><br><span class="line">           &#125;</span><br><span class="line">       ],</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<blockquote>
<p>less-loader的作用：把less转化成css</p>
<p>sass 的作用：less-loader依赖包</p>
</blockquote>
<h3 id="处理stylus"><a href="#处理stylus" class="headerlink" title="处理stylus"></a>处理stylus</h3><ol>
<li><pre><code class="shell">npm i stylus-loader -D
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```js</span><br><span class="line">   &#123;</span><br><span class="line">       test: /\.styl$/,</span><br><span class="line">       use: [&#x27;style-loader&#x27;,&#x27;css-loader&#x27;,&#x27;stylus-loader&#x27;]</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h3 id="处理图片"><a href="#处理图片" class="headerlink" title="处理图片"></a>处理图片</h3><p><code>file-loader</code> <code> url-loader</code> 已内置在webpack5里面</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|webp)$/</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;asset&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打包后：&#x2F;dist下出现了图片</p>
<blockquote>
<p>而样式文件被打包到index.js 文件里了</p>
</blockquote>
<h4 id="把小图片转换成base64"><a href="#把小图片转换成base64" class="headerlink" title="把小图片转换成base64"></a>把小图片转换成base64</h4><p>优缺：减少请求，文件体积变大</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|webp)$/</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">    <span class="attr">parser</span>: &#123;</span><br><span class="line">        <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">            <span class="attr">maxSize</span>: <span class="number">10</span>*<span class="number">1024</span> <span class="comment">//小于10kb的图片被转成base64</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p>作用：ES6 &#x3D;&gt; ES5</p>
<ol>
<li><pre><code class="shell">npm i babel-loader @babel/core @babel/preset-env -D
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2.  `webpack.config.js `导入babel loader</span><br><span class="line"></span><br><span class="line">   ```js</span><br><span class="line">   &#123;</span><br><span class="line">       test: /\.js$/,</span><br><span class="line">       exclude: /node_modules/, // 排除node_modules代码不编译</span><br><span class="line">       loader: &quot;babel-loader&quot;,</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>在根目录下新建 <code>babel.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">//预设</span></span><br><span class="line">    <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>@babel/preset-env</code>: 一个智能预设，允许您使用最新的 JavaScript。<br><code>@babel/preset-react</code>：一个用来编译 React jsx 语法的预设<br><code>@babel/preset-typescript</code>：一个用来编译 TypeScript 语法的预设</p>
</blockquote>
</li>
</ol>
<h3 id="Webpack配置"><a href="#Webpack配置" class="headerlink" title="Webpack配置"></a>Webpack配置</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack 配置文件使用CommonJs语法</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&quot;./src/index.js&quot;</span>,</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="comment">//打包文件输出目录（绝对路径）</span></span><br><span class="line">        <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;dist&quot;</span>),</span><br><span class="line">        <span class="comment">//打包后的入口文件在dist里的路径</span></span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&quot;src/index.js&quot;</span>,</span><br><span class="line">        <span class="comment">//自动清空上次打包的内容</span></span><br><span class="line">        <span class="attr">clean</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="comment">//使用loader</span></span><br><span class="line">        <span class="attr">rules</span>: [&#123;</span><br><span class="line">            <span class="comment">//test： 正则匹配 文件</span></span><br><span class="line">            <span class="comment">//use: 按数组顺序从右向左执行</span></span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">            <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,</span><br><span class="line">            <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;less-loader&#x27;</span>]</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/</span>,</span><br><span class="line">            <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;sass-loader&#x27;</span>]</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">            <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;stylus-loader&#x27;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|webp)$/</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&quot;asset&quot;</span>,</span><br><span class="line">            <span class="attr">parser</span>: &#123;</span><br><span class="line">                <span class="attr">dataUrlCondition</span>: &#123;</span><br><span class="line">                    <span class="attr">maxSize</span>: <span class="number">10</span> * <span class="number">1024</span> <span class="comment">//小于10kb的图片被转成base64</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">generator</span>: &#123;</span><br><span class="line">                <span class="comment">// 将图片文件输出到 static/imgs 目录中</span></span><br><span class="line">                <span class="comment">// 将图片文件命名 [hash:8][ext][query]</span></span><br><span class="line">                <span class="attr">filename</span>: <span class="string">&quot;static/images/[hash:8][ext][query]&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.(ttf|woff2?|mp4|mp3|avi)$/</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&quot;asset/resource&quot;</span>,</span><br><span class="line">            <span class="attr">generator</span>: &#123;</span><br><span class="line">                <span class="attr">filename</span>: <span class="string">&quot;static/media/[hash:8][ext][query]&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        ],</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">plugins</span>: [],</span><br><span class="line">    <span class="comment">//development || production || none</span></span><br><span class="line">    <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>type: &quot;asset/resource&quot;</code> 将文件转化成 Webpack 能识别的资源，其他不做处理</li>
<li><code>type: &quot;asset&quot;</code> 相当于<code>url-loader</code>, 将文件转化成 Webpack 能识别的资源，同时小于某个大小的资源会处理成 data URI (base64)形式</li>
<li><code>mode</code> <ul>
<li>none: <em>此时webpack不会对入口文件进行任何的优化</em>，webpack直接把模块打包至数组之中</li>
<li>development:  它实现了3个插件功能<ul>
<li>NamedModulesPlugin 对打包出来的模块加上名字</li>
<li>NamedChunksPlugin 对每个chunks命名</li>
<li>DefinePlugin 对环境变量<code>process.env.NODE_ENV </code>的值设置为 <code>&#39;development&#39;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p> [ hash:8 ]:  hash值取8位, 文件名长度</p>
<p> [ chunkhash] ：根据一个入口文件一个hash</p>
<p> [ contenthash ] : 根据内容生成hash </p>
</blockquote>
<h2 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h2><h3 id="Eslint"><a href="#Eslint" class="headerlink" title="Eslint"></a>Eslint</h3><ol>
<li><pre><code class="shell">npm i eslint-webpack-plugin eslint -D
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. `webpack.config.js `导入eslint 插件</span><br><span class="line"></span><br><span class="line">   ```js</span><br><span class="line">   const ESLintWebpackPlugin = require(&quot;eslint-webpack-plugin&quot;);</span><br><span class="line">   module.export = &#123;</span><br><span class="line">       ...</span><br><span class="line">       plugin: [&#123;new ESLintWebpackPlugin(&#123;</span><br><span class="line">                 //指定要检查的根目录</span><br><span class="line">                 context: path.resolve(__dirname, &quot;src&quot;)</span><br><span class="line">                &#125;)&#125;，]</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>在根目录下新建 <code>.eslintrc.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">//1. 解析选项</span></span><br><span class="line">    <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">        <span class="attr">ecmaVersion</span>: <span class="number">6</span>,</span><br><span class="line">        <span class="attr">sourceType</span>: <span class="string">&quot;module&quot;</span>, <span class="comment">//ES模块化</span></span><br><span class="line">        <span class="attr">ecmaFeatures</span>: &#123;</span><br><span class="line">            <span class="attr">jsx</span>: <span class="literal">true</span>   <span class="comment">//ES其他特性-jsx</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="comment">/* 2. 检查规则</span></span><br><span class="line"><span class="comment">    off / 0     关闭规则</span></span><br><span class="line"><span class="comment">    warn/ 1     开启规则，报警告</span></span><br><span class="line"><span class="comment">    error/2     开启规则，直接报错</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="attr">rules</span>: &#123;</span><br><span class="line">        <span class="attr">semi</span>: <span class="string">&quot;off&quot;</span>, <span class="comment">//是否使用分号</span></span><br><span class="line">        <span class="string">&#x27;array-callback-return&#x27;</span>: <span class="string">&#x27;warn&#x27;</span>,<span class="comment">//数组方法回调函数里有return</span></span><br><span class="line">        <span class="string">&#x27;default-case&#x27;</span>: [<span class="comment">//switch-case 语法必须要有default</span></span><br><span class="line">            <span class="string">&#x27;warn&#x27;</span>,</span><br><span class="line">            &#123;<span class="attr">commentPattern</span>: <span class="string">&#x27;^no default$&#x27;</span>&#125; <span class="comment">//允许在最后注释no default，就不会报警告</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">eqeqeq</span>: [</span><br><span class="line">            <span class="string">&#x27;warn&#x27;</span>, <span class="comment">//强制使用=== 和 !==</span></span><br><span class="line">            <span class="string">&#x27;smart&#x27;</span>, <span class="comment">//少数情况不会报警告</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">&#x27;no-var&#x27;</span>: <span class="string">&#x27;error&#x27;</span><span class="comment">//禁止使用var定义变量</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/* 3. 继承其他规则</span></span><br><span class="line"><span class="comment">    Eslint官方规则： eslint:recommended</span></span><br><span class="line"><span class="comment">    VueCli ： plugin:vue/essential</span></span><br><span class="line"><span class="comment">    ReactCli: react-app</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">extends</span>  :[<span class="string">&#x27;eslint:recommended&#x27;</span>],</span><br><span class="line">    <span class="attr">env</span>: &#123;</span><br><span class="line">        <span class="attr">node</span>: <span class="literal">true</span>, <span class="comment">//启用node中全局变量</span></span><br><span class="line">        <span class="attr">browser</span>: <span class="literal">true</span>, <span class="comment">//启用浏览器中全局变量</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="处理HTML资源"><a href="#处理HTML资源" class="headerlink" title="处理HTML资源"></a>处理HTML资源</h3><p>生成的index.html有两个特性</p>
<ul>
<li><p>内容与public&#x2F;index.html 一致</p>
</li>
<li><p>自动引入打包好的js等资源</p>
</li>
</ul>
<p><strong>使用</strong></p>
<ol>
<li><pre><code class="shell">npm i html-webpack-plugin
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```js</span><br><span class="line">   //webpack.config.js</span><br><span class="line">   const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)</span><br><span class="line">   ...</span><br><span class="line">   &#123;</span><br><span class="line">       new HtmlWebpackPlugin(&#123;</span><br><span class="line">               template: &quot;./public/index.html&quot;,</span><br><span class="line">               filename: &quot;index.html&quot;,</span><br><span class="line">               minify: &#123;</span><br><span class="line">                   removeAttributeQuotes: true,</span><br><span class="line">                   collapseWhitespace: true,</span><br><span class="line">                   removeComments: true</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h3 id="处理CSS—高级"><a href="#处理CSS—高级" class="headerlink" title="处理CSS—高级"></a>处理CSS—高级</h3><h4 id="提取css"><a href="#提取css" class="headerlink" title="提取css"></a>提取css</h4><blockquote>
<p> index.js 引入css文件，然后index.html再引入index.js的模式会创建一个style标签来生成样式，可能会有闪屏现象</p>
</blockquote>
<ol>
<li><pre><code class="shell">npm i mini-css-extract-plugin -D
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```js</span><br><span class="line">   //webpack.prod.js</span><br><span class="line">   const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;)</span><br><span class="line">   ...</span><br><span class="line">   MiniCssExtractPlugin.loader替换掉所有&quot;style-loader&quot;</span><br><span class="line">   ...</span><br><span class="line">   plugins: [</span><br><span class="line">       new MiniCssExtractPlugin(&#123;</span><br><span class="line">       	//输出目录和文件名</span><br><span class="line">       	filename: &quot;src/index.css&quot;</span><br><span class="line">   	&#125;)</span><br><span class="line">   ]</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h4 id="兼容性处理"><a href="#兼容性处理" class="headerlink" title="兼容性处理"></a>兼容性处理</h4><ol>
<li><pre><code class="shell">npm i postcss-loader postcss postcss-preset-env -D
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```js</span><br><span class="line">   //webpack.prod.js</span><br><span class="line">   rules: [&#123;</span><br><span class="line">       test: /\.css$/,</span><br><span class="line">       use: [MiniCssExtractPlugin.loader, &#x27;css-loader&#x27;,</span><br><span class="line">         //放在所有css-loader后面</span><br><span class="line">         &#123;</span><br><span class="line">           loader: &#x27;postcss-loader&#x27;,</span><br><span class="line">           options: &#123;</span><br><span class="line">               postcssOptions: &#123;</span><br><span class="line">                   plugins: [</span><br><span class="line">                       //可解决大多数兼容问题</span><br><span class="line">                       &quot;postcss-preset-env&quot;    </span><br><span class="line">                   ]</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;]</span><br><span class="line">   	&#125;,</span><br><span class="line">       ...</span><br><span class="line">   ]</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h4 id="兼容性控制"><a href="#兼容性控制" class="headerlink" title="兼容性控制"></a>兼容性控制</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  package.json */</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;browserslist&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;last 2 version&quot;</span><span class="punctuation">,</span> <span class="string">&quot;&gt; 1%&quot;</span><span class="punctuation">,</span> <span class="string">&quot;not dead&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="合并配置"><a href="#合并配置" class="headerlink" title="合并配置"></a>合并配置</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getStyleLoaders</span> = (<span class="params">preProcessor</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="title class_">MiniCssExtractPlugin</span>.<span class="property">loader</span>,</span><br><span class="line">        <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">loader</span>: <span class="string">&quot;postcss-loader&quot;</span>,</span><br><span class="line">            <span class="attr">options</span>: &#123;</span><br><span class="line">                <span class="attr">postcssOptions</span>: &#123;</span><br><span class="line">                    <span class="attr">plugins</span>: [</span><br><span class="line">                        <span class="string">&quot;postcss-preset-env&quot;</span>,</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        preProcessor,</span><br><span class="line">    ].<span class="title function_">filter</span>(<span class="title class_">Boolean</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>filter 相当于 arr.filter(item&#x3D;&gt;Boolean(item)) 可以过滤所有Boolean()返回false的值： 例如 <code>0</code> <code>false</code> <code>null</code> <code>undefined</code> <code>&#39;&#39;</code> &#96;&#96; </p>
</blockquote>
<h2 id="开发服务器-自动化"><a href="#开发服务器-自动化" class="headerlink" title="开发服务器&amp;自动化"></a>开发服务器&amp;自动化</h2><ol>
<li><pre><code class="shell">npm i webpack-dev-server -D
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```js</span><br><span class="line">   //webpack.config.js</span><br><span class="line">       devServer: &#123;</span><br><span class="line">           host: &quot;localhost&quot;,</span><br><span class="line">           port: 8080,</span><br><span class="line">           open: true,     //是否自动打开浏览器</span><br><span class="line">           hot: true,      //是否开启热更新</span><br><span class="line">           //自动刷新</span><br><span class="line">           // proxy: &#123;</span><br><span class="line">           //     &#x27;/api&#x27;: &#123;</span><br><span class="line">           //         target: &#x27;http://localhost:3000&#x27;,</span><br><span class="line">           //         changeOrigin: true,</span><br><span class="line">           //         pathRewrite: &#123;</span><br><span class="line">           //             &#x27;^/api&#x27;: &#x27;&#x27;</span><br><span class="line">           //         &#125;</span><br><span class="line">           //     &#125;</span><br><span class="line">           // &#125;</span><br><span class="line">       &#125;,</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="shell">npx webpack server
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 开发和生产环境</span><br><span class="line"></span><br><span class="line">在`/config/webpack.prod.js` `/config/webpack.dev.js` </span><br><span class="line"></span><br><span class="line">运行对应配置:</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">npx webpack --config ./config/webpack.prod.js</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h3 id="配置脚本"><a href="#配置脚本" class="headerlink" title="配置脚本"></a>配置脚本</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//package.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npx webpack serve --config ./config/webpack.dev.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npx webpack --config ./config/webpack.prod.js&quot;</span>，</span><br><span class="line">    <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm run dev&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>





<h2 id="减少代码体积"><a href="#减少代码体积" class="headerlink" title="减少代码体积"></a>减少代码体积</h2><h3 id="SourceMap"><a href="#SourceMap" class="headerlink" title="SourceMap"></a>SourceMap</h3><p>构建后的文件内容和开发时的代码的映射文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">devtool</span>: <span class="string">&quot;cheap-module-source-map&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>cheap-module-source-map: 只包含行映射，打包快</li>
<li>source-map：包含行列映射</li>
</ul>
<h3 id="HotModuleReplacement"><a href="#HotModuleReplacement" class="headerlink" title="HotModuleReplacement"></a>HotModuleReplacement</h3><p>webpack默认修改后重新打包所有模块</p>
<p>配置后：让开发时只重新编译打包更新变化了的代码，不变的代码使用缓存，从而使更新速度更快。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>= &#123;</span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">host</span>: <span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">        <span class="attr">port</span>: <span class="string">&#x27;8081&#x27;</span>,</span><br><span class="line">        <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">hot</span>: <span class="literal">true</span>, 	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此时css以及可以热HMR了，但是js不行，</p>
<p>一般用vue-loader 或者 react-hot-loader 来</p>
</blockquote>
<h3 id="OneOf"><a href="#OneOf" class="headerlink" title="OneOf"></a>OneOf</h3><p>一个文件有可能被多个rules命中，所以每个文件要和所有规则去test一次</p>
<p>配置后：一个文件只要匹配到一个loader就不继续匹配了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>= &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">oneOf</span>:[</span><br><span class="line">                    &#123;&#125;,&#123;&#125;,&#123;&#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p>每次打包js要经过Eslint和Babel</p>
<p>配置后：可以缓存之前的Eslint检查和Babel编译结果，打包变快</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js </span></span><br><span class="line"><span class="comment">//1. babel-loader</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">test</span>: /\.<span class="property">js</span></span><br><span class="line">    <span class="attr">include</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../src&quot;</span>), <span class="comment">// 也可以用包含</span></span><br><span class="line">    <span class="attr">loader</span>: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">      <span class="attr">cacheDirectory</span>: <span class="literal">true</span>, <span class="comment">// 开启babel编译缓存</span></span><br><span class="line">      <span class="attr">cacheCompression</span>: <span class="literal">false</span>, <span class="comment">// 缓存文件不要压缩</span></span><br><span class="line">&#125;,</span><br><span class="line">    </span><br><span class="line"><span class="comment">//2. Eslint</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">EsLintWebpackPlugin</span>(&#123;</span><br><span class="line">	<span class="attr">context</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../src&#x27;</span>),</span><br><span class="line">    <span class="attr">exclude</span>: <span class="string">&quot;node_modules&quot;</span>,</span><br><span class="line">    <span class="attr">cache</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">cacheLocation</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&quot;../node_modules/.cache/.eslintcache&quot;</span>),</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h3><p>对 js 文件处理主要就是 eslint 、babel、Terser 三个工具，所以我们要提升它们的运行速度。</p>
<p>我们可以开启多进程同时处理 js 文件，这样速度就比之前的单进程打包更快了</p>
<p>略。。。</p>
<h3 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h3><p>是一个术语，通常用于描述移除 JavaScript 中的没有使用上的代码。</p>
<p>引用第三方工具函数库或组件库，如果没有特殊处理的话我们打包时会引入整个库，但是实际上可能我们可能只用上极小部分的功能</p>
<p>依赖ES Module</p>
<blockquote>
<p>webpack 默认开启</p>
</blockquote>
<h2 id="优化代码运行性能"><a href="#优化代码运行性能" class="headerlink" title="优化代码运行性能"></a>优化代码运行性能</h2><h3 id="code-split"><a href="#code-split" class="headerlink" title="code split"></a>code split</h3><p>将所有 js 文件打包到一个文件中，体积太大了</p>
<p>渲染哪个页面就只加载某个 js 文件，这样加载的资源就少，速度就更快。</p>
<p>实现了：</p>
<ol>
<li>分割文件</li>
<li>按需加载</li>
</ol>
<h4 id="1-多入口"><a href="#1-多入口" class="headerlink" title="1. 多入口"></a>1. 多入口</h4><p>几个entry，就有几个output</p>
<ol>
<li><pre><code class="shell">npm i webpack webpack-cli html-webpack-plugin -D
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 修改配置文件</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">//webpack.config.js</span><br><span class="line">module.exports= &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        //两个入口文件</span><br><span class="line">        main: &#x27;./src/main.js&#x27;,</span><br><span class="line">        index: &#x27;./src/index.js&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, &quot;../dist&quot;),</span><br><span class="line">        filename: &quot;src/[name].js&quot;,</span><br><span class="line">        clean: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h4 id="2-提取重复代码"><a href="#2-提取重复代码" class="headerlink" title="2. 提取重复代码"></a>2. 提取重复代码</h4><p>如果多个入口文件用到同一份代码，我们不希望这份代码被打包到两个文件中，导致代码重复</p>
<p>我们需要提取多入口的重复代码生成一个 js 文件，其他文件引用它就好。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js </span></span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="comment">// 代码分割配置</span></span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">      <span class="attr">chunks</span>: <span class="string">&quot;all&quot;</span>, <span class="comment">// 对所有模块都进行分割</span></span><br><span class="line">      <span class="comment">// 以下是默认值</span></span><br><span class="line">      <span class="comment">// minSize: 20000, // 分割代码最小的大小</span></span><br><span class="line">      <span class="comment">// minRemainingSize: 0, // 类似于minSize，最后确保提取的文件大小不能为0</span></span><br><span class="line">      <span class="comment">// minChunks: 1, // 至少被引用的次数，满足条件才会代码分割</span></span><br><span class="line">      <span class="comment">// maxAsyncRequests: 30, // 按需加载时并行加载的文件的最大数量</span></span><br><span class="line">      <span class="comment">// maxInitialRequests: 30, // 入口js文件最大并行请求数量</span></span><br><span class="line">      <span class="comment">// enforceSizeThreshold: 50000, // 超过50kb一定会单独打包（此时会忽略minRemainingSize、maxAsyncRequests、maxInitialRequests）</span></span><br><span class="line">      <span class="comment">// cacheGroups: &#123; // 组，哪些模块要打包到一个组</span></span><br><span class="line">      <span class="comment">//   defaultVendors: &#123; // 组名</span></span><br><span class="line">      <span class="comment">//     test: /[\\/]node_modules[\\/]/, // 需要打包到一起的模块</span></span><br><span class="line">      <span class="comment">//     priority: -10, // 权重（越大越高）</span></span><br><span class="line">      <span class="comment">//     reuseExistingChunk: true, // 如果当前 chunk 包含已从主 bundle 中拆分出的模块，则它将被重用，而不是生成新的模块</span></span><br><span class="line">      <span class="comment">//   &#125;,</span></span><br><span class="line">      <span class="comment">//   default: &#123; // 其他没有写的配置会使用上面的默认值</span></span><br><span class="line">      <span class="comment">//     minChunks: 2, // 这里的minChunks权重更大</span></span><br><span class="line">      <span class="comment">//     priority: -20,</span></span><br><span class="line">      <span class="comment">//     reuseExistingChunk: true,</span></span><br><span class="line">      <span class="comment">//   &#125;,</span></span><br><span class="line">      <span class="comment">// &#125;,</span></span><br><span class="line">      <span class="comment">// 修改配置</span></span><br><span class="line">      <span class="attr">cacheGroups</span>: &#123;</span><br><span class="line">        <span class="comment">// 组，哪些模块要打包到一个组</span></span><br><span class="line">        <span class="comment">// defaultVendors: &#123; // 组名</span></span><br><span class="line">        <span class="comment">//   test: /[\\/]node_modules[\\/]/, // 需要打包到一起的模块</span></span><br><span class="line">        <span class="comment">//   priority: -10, // 权重（越大越高）</span></span><br><span class="line">        <span class="comment">//   reuseExistingChunk: true, // 如果当前 chunk 包含已从主 bundle 中拆分出的模块，则它将被重用，而不是生成新的模块</span></span><br><span class="line">        <span class="comment">// &#125;,</span></span><br><span class="line">        <span class="attr">default</span>: &#123;</span><br><span class="line">          <span class="comment">// 其他没有写的配置会使用上面的默认值</span></span><br><span class="line">          <span class="attr">minSize</span>: <span class="number">0</span>, <span class="comment">// 我们定义的文件体积太小了，所以要改打包的最小文件体积</span></span><br><span class="line">          <span class="attr">minChunks</span>: <span class="number">2</span>,</span><br><span class="line">          <span class="attr">priority</span>: -<span class="number">20</span>,</span><br><span class="line">          <span class="attr">reuseExistingChunk</span>: <span class="literal">true</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>



<h4 id="3-按需加载，动态导入"><a href="#3-按需加载，动态导入" class="headerlink" title="3. 按需加载，动态导入"></a>3. 按需加载，动态导入</h4><p><strong>动态导入</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&quot;./math.js&quot;</span>).<span class="title function_">then</span>(&#123;sum&#125;=&gt;&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p> <strong>动态导入文件命名</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpackChunkName: &quot;math&quot;：这是webpack动态导入模块命名的方式</span></span><br><span class="line"><span class="comment">// &quot;math&quot;将来就会作为[name]的值显示。</span></span><br><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;math&quot; */</span> <span class="string">&quot;./math.js&quot;</span>).<span class="title function_">then</span>(&#123;sum&#125;=&gt;&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种写法会导致eslint报错：webpack.config.js里取消使用Eslint</p>
</blockquote>
<p><strong>命名配置</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&quot;src/js/[name].js&quot;</span>,</span><br><span class="line">        <span class="attr">chunkFilename</span>: <span class="string">&quot;static/js/[name].chunk.js&quot;</span>,</span><br><span class="line">        <span class="comment">//自动识别type: asset 或 type: asset/resource</span></span><br><span class="line">        <span class="attr">assetModuleFilename</span>: <span class="string">&quot;static/media/[name].[hash][ext]&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>打包出来的文件会叫作：math.chunk.js</p>
</blockquote>
<h3 id="runtime-文件"><a href="#runtime-文件" class="headerlink" title="runtime 文件"></a>runtime 文件</h3><p>如果：a.js 导入了 b.js ，那么b文件修改后，b的hash值发生变化，a导入b时也会发送变化，所以a和b的都发生了更新。这是我们不想看到的。</p>
<p>runtime文件 里面保存  文件地址，这样当某文件改变时，只有该文件和runtime文件会改变，其他文件不会改变hash值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>=&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">runtimeChunk</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="function">(<span class="params">entrypoint</span>)=&gt;</span> <span class="string">`runtime~<span class="subst">$&#123;entrypoint.name&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Core-js"><a href="#Core-js" class="headerlink" title="Core.js"></a>Core.js</h3><ul>
<li><p>babel对Es6 的箭头函数，import等编译，但是对于es7的await&#x2F;async proimise等一些无法解决</p>
</li>
<li><p><code>core-js</code> 是专门用来做 ES6 以及以上 API 的 <code>polyfill</code>。</p>
<p><code>polyfill</code> 翻译过来叫做垫片&#x2F;补丁。就是用社区上提供的一段代码，让我们在不兼容某些新特性的浏览器上，使用该新特性。</p>
</li>
</ul>
<ol>
<li><pre><code class="shell">npm i core-js
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```js</span><br><span class="line">   //需要兼容的js文件里</span><br><span class="line">   import &quot;core-js&quot; //全局引入</span><br><span class="line">   import &quot;core-js/es/promise&quot;	//局部引入</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h3 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h3><p>在 <strong>离线(offline)</strong> 时应用程序能够继续运行功能。</p>
<p>内部通过 <a href="'/11/5/%E6%B5%85%E8%B0%88Service-Worker'">Service Workers</a> 技术实现的。</p>
<ol>
<li><pre><code class="shell">npm i workbox-webpack-plugin -D
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. ```js</span><br><span class="line">   //webpack.config.js</span><br><span class="line">   const WorkboxPlugin = require(&quot;workbox-webpack-plugin&quot;);</span><br><span class="line">   </span><br><span class="line">   //plugins 中</span><br><span class="line">       new WorkboxPlugin.GenerateSW(&#123;</span><br><span class="line">         // 这些选项帮助快速启用 ServiceWorkers</span><br><span class="line">         // 不允许遗留任何“旧的” ServiceWorkers</span><br><span class="line">         clientsClaim: true,</span><br><span class="line">         skipWaiting: true,</span><br><span class="line">       &#125;),</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="js">//index.js 中
if(&quot;serviceWorker&quot; in navigator) &#123;
    window.addEventListener(&quot;load&quot;,()=&gt; &#123;
        navigator.serviceWorker.register(&quot;/dist/service-worker.js&quot;)
        .then((registration)=&gt; &#123;
            console.log(&quot;SW registered&quot;, registration)
        &#125;).catch((registrationError)=&gt; &#123;
            console.log(&quot;SW registraion failed: &quot;, registrationError);
        &#125;)
    &#125;)
&#125;
</code></pre>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们从 4 个角度对 webpack 和代码进行了优化：</p>
<h3 id="提升开发体验"><a href="#提升开发体验" class="headerlink" title="提升开发体验"></a>提升开发体验</h3><ul>
<li>使用 <code>Source Map</code> 让开发或上线时代码报错能有更加准确的错误提示。</li>
</ul>
<h3 id="提升-webpack-提升打包构建速度"><a href="#提升-webpack-提升打包构建速度" class="headerlink" title="提升 webpack 提升打包构建速度"></a>提升 webpack 提升打包构建速度</h3><ul>
<li>使用 <code>HotModuleReplacement</code> 让开发时只重新编译打包更新变化了的代码，不变的代码使用缓存，从而使更新速度更快。</li>
<li>使用 <code>OneOf</code> 让资源文件一旦被某个 loader 处理了，就不会继续遍历了，打包速度更快。</li>
<li>使用 <code>Include/Exclude</code> 排除或只检测某些文件，处理的文件更少，速度更快。</li>
<li>使用 <code>Cache</code> 对 eslint 和 babel 处理的结果进行缓存，让第二次打包速度更快。</li>
<li>使用 <code>Thead</code> 多进程处理 eslint 和 babel 任务，速度更快。（需要注意的是，进程启动通信都有开销的，要在比较多代码处理时使用才有效果）</li>
</ul>
<h3 id="减少代码体积-1"><a href="#减少代码体积-1" class="headerlink" title="减少代码体积"></a>减少代码体积</h3><ul>
<li>使用 <code>Tree Shaking</code> 剔除了没有使用的多余代码，让代码体积更小。</li>
<li>使用 <code>@babel/plugin-transform-runtime</code> 插件对 babel 进行处理，让辅助代码从中引入，而不是每个文件都生成辅助代码，从而体积更小。</li>
<li>使用 <code>Image Minimizer</code> 对项目中图片进行压缩，体积更小，请求速度更快。（需要注意的是，如果项目中图片都是在线链接，那么就不需要了。本地项目静态图片才需要进行压缩。）</li>
</ul>
<h3 id="优化代码运行性能-1"><a href="#优化代码运行性能-1" class="headerlink" title="优化代码运行性能"></a>优化代码运行性能</h3><ul>
<li>使用 <code>Code Split</code> 对代码进行分割成多个 js 文件，从而使单个文件体积更小，并行加载 js 速度更快。并通过 import 动态导入语法进行按需加载，从而达到需要使用时才加载该资源，不用时不加载资源。</li>
<li>使用 <code>Preload / Prefetch</code> 对代码进行提前加载，等未来需要使用时就能直接使用，从而用户体验更好。</li>
<li>使用 <code>Network Cache</code> 能对输出资源文件进行更好的命名，将来好做缓存，从而用户体验更好。</li>
<li>使用 <code>Core-js</code> 对 js 进行兼容性处理，让我们代码能运行在低版本浏览器。</li>
<li>使用 <code>PWA</code> 能让代码离线也能访问，从而提升用户体验。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>算法总结</title>
    <url>/2024/03/31/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h1><p><strong>大部分算法可以看作对于二叉树的操作</strong></p>
<p>二叉树解题的思维模式分两类：</p>
<p> <strong>1、是否可以通过遍历一遍二叉树得到答案</strong> ？如果可以，用一个 <code>traverse</code> 函数配合外部变量来实现，这叫「遍历」的思维模式。</p>
<p> <strong>2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案</strong> ？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。</p>
<p>无论使用哪种思维模式，你都需要思考：</p>
<p> <strong>如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前&#x2F;中&#x2F;后序位置）做</strong> ？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。</p>
<ul>
<li>比如快排是二叉树前序遍历</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    <span class="comment">/****** 前序遍历位置 ******/</span></span><br><span class="line">    <span class="comment">// 通过交换元素构建分界点 p</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> partition(nums, lo, hi);</span><br><span class="line">    <span class="comment">/************************/</span></span><br><span class="line"></span><br><span class="line">    sort(nums, lo, p - <span class="number">1</span>);</span><br><span class="line">    sort(nums, p + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>归并排序是二叉树后序遍历</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (lo + hi) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 排序 nums[lo..mid]</span></span><br><span class="line">    sort(nums, lo, mid);</span><br><span class="line">    <span class="comment">// 排序 nums[mid+1..hi]</span></span><br><span class="line">    sort(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/****** 后序位置 ******/</span></span><br><span class="line">    <span class="comment">// 合并 nums[lo..mid] 和 nums[mid+1..hi]</span></span><br><span class="line">    merge(nums, lo, mid, hi);</span><br><span class="line">    <span class="comment">/*********************/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点</strong></p>
<ol>
<li>前序位置的代码在刚刚进入一个二叉树节点的时候执行；</li>
<li>后序位置的代码在将要离开一个二叉树节点的时候执行；</li>
<li>中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。</li>
</ol>
</blockquote>
<span id="more"></span>

<h2 id="两大框架"><a href="#两大框架" class="headerlink" title="两大框架"></a>两大框架</h2><h3 id="回溯框架【遍历】"><a href="#回溯框架【遍历】" class="headerlink" title="回溯框架【遍历】"></a>回溯框架【遍历】</h3><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><p>DFS 的关注点在单个 <strong>节点</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DFS 算法把「做选择」「撤销选择」的逻辑放在 for 循环外面</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 做选择</span></span><br><span class="line">    print(<span class="string">&quot;我已经进入节点 %s 啦&quot;</span>, root)</span><br><span class="line">    <span class="keyword">for</span> (Node child : root.children) &#123;</span><br><span class="line">        dfs(child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 撤销选择</span></span><br><span class="line">    print(<span class="string">&quot;我将要离开节点 %s 啦&quot;</span>, root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h4><p>回溯算法的关注点在节点间的 <strong>树枝</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回溯算法把「做选择」「撤销选择」的逻辑放在 for 循环里面</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node child : root.children) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        print(<span class="string">&quot;我站在节点 %s 到节点 %s 的树枝上&quot;</span>, root, child)</span><br><span class="line">        backtrack(child);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        print(<span class="string">&quot;我将要离开节点 %s 到节点 %s 的树枝上&quot;</span>, child, root)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>站在一个节点上我们需要考虑三个问题：</p>
<ol>
<li><p>路径：也就是已经做出的选择。</p>
</li>
<li><p>选择列表：也就是你当前可以做的选择。</p>
</li>
<li><p>结束条件：也就是到达决策树底层，无法再做选择的条件。</p>
</li>
</ol>
<h5 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h5><p>分为三种情况：</p>
<ol>
<li><p><strong>元素无重不可复选</strong> (基础)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">backtrack</span> = (<span class="params">start</span>) =&gt; &#123;</span><br><span class="line">       <span class="comment">// 前序遍历位置，每个节点的值都是一个子集</span></span><br><span class="line">       result.<span class="title function_">push</span>([...onPath]);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 回溯算法 --- 组合</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">           onPath.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">           <span class="title function_">backtrack</span>(i + <span class="number">1</span>);<span class="comment">// 回溯遍历下一层节点</span></span><br><span class="line">           onPath.<span class="title function_">pop</span>();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><u>不可复选，则start代表从索引start开始选，无需考虑前面的因为已经选过了。</u></li>
</ul>
</li>
<li><p><strong>元素可重不可复选</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b); <span class="comment">//排序</span></span><br><span class="line"><span class="comment">//... ...</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">backtrack</span> = (<span class="params">start=<span class="number">0</span></span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 前序遍历位置，每个节点的值都是一个子集</span></span><br><span class="line">        result.<span class="title function_">push</span>([...onPath]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回溯 --- 组合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;start &amp;&amp; nums[i]==nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">//剪枝</span></span><br><span class="line">            onPath.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">            <span class="title function_">backtrack</span>(i + <span class="number">1</span>);<span class="comment">// 回溯遍历---从下一个元素开始</span></span><br><span class="line">            onPath.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><u>因为元素可重但是选择不可重，所以需要剪枝。</u></li>
<li>先给nums排序，方便后面剪枝</li>
</ul>
</li>
<li><p><strong>元素无重可复选</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b); <span class="comment">//排序</span></span><br><span class="line"><span class="comment">//... ...</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">backtrack</span> = (<span class="params">start=<span class="number">0</span></span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 前序遍历位置，每个节点的值都是一个子集</span></span><br><span class="line">        result.<span class="title function_">push</span>([...onPath]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回溯 --- 组合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = start; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//剪枝</span></span><br><span class="line">            onPath.<span class="title function_">push</span>(nums[i]);</span><br><span class="line">            <span class="title function_">backtrack</span>(i);<span class="comment">// 回溯遍历---从此元素开始</span></span><br><span class="line">            onPath.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><p>层序遍历属于迭代遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入一棵二叉树的根节点，层序遍历这棵二叉树</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">levelTraverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line">	<span class="type">let</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从上到下遍历二叉树的每一层</span></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="comment">// 从左到右遍历每一层的每个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="comment">// 将下一层节点放入队列</span></span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                q.offer(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                q.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        depth ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="变形递归"><a href="#变形递归" class="headerlink" title="变形递归"></a>变形递归</h4><h5 id="二叉当作三叉"><a href="#二叉当作三叉" class="headerlink" title="二叉当作三叉"></a>二叉当作三叉</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三叉树遍历框架</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">traverse</span>(<span class="params">node1, node2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (node1 === <span class="literal">null</span> || node2 === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**** 前序位置 ****/</span></span><br><span class="line">    <span class="comment">// 将传入的两个节点穿起来</span></span><br><span class="line">    node1.<span class="property">next</span> = node2;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 连接相同父节点的两个子节点</span></span><br><span class="line">    <span class="title function_">traverse</span>(node1.<span class="property">left</span>, node1.<span class="property">right</span>);</span><br><span class="line">    <span class="title function_">traverse</span>(node2.<span class="property">left</span>, node2.<span class="property">right</span>);</span><br><span class="line">    <span class="comment">// 连接跨越父节点的两个子节点</span></span><br><span class="line">    <span class="title function_">traverse</span>(node1.<span class="property">right</span>, node2.<span class="property">left</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="从右向左的中序-倒序二叉搜索树"><a href="#从右向左的中序-倒序二叉搜索树" class="headerlink" title="从右向左的中序-倒序二叉搜索树"></a>从右向左的中序-倒序二叉搜索树</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> traverse = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 先递归遍历右子树</span></span><br><span class="line">    <span class="title function_">traverse</span>(root.<span class="property">right</span>);</span><br><span class="line">    <span class="comment">// 中序遍历代码位置</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(root.<span class="property">val</span>);</span><br><span class="line">    <span class="comment">// 后递归遍历左子树</span></span><br><span class="line">    <span class="title function_">traverse</span>(root.<span class="property">left</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动规框架【分解】"><a href="#动规框架【分解】" class="headerlink" title="动规框架【分解】"></a>动规框架【分解】</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自顶向下递归的动态规划</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">状态<span class="number">1</span>, 状态<span class="number">2</span>, ...</span>):</span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 所有可能的选择:</span><br><span class="line">        <span class="comment"># 此时的状态已经因为做了选择而改变</span></span><br><span class="line">        result = 求最值(result, dp(状态<span class="number">1</span>, 状态<span class="number">2</span>, ...))</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自底向上迭代的动态规划</span></span><br><span class="line"><span class="comment"># 初始化 base case</span></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][...] = base <span class="keyword">case</span></span><br><span class="line"><span class="comment"># 进行状态转移</span></span><br><span class="line"><span class="keyword">for</span> 状态<span class="number">1</span> <span class="keyword">in</span> 状态<span class="number">1</span>的所有取值：</span><br><span class="line">    <span class="keyword">for</span> 状态<span class="number">2</span> <span class="keyword">in</span> 状态<span class="number">2</span>的所有取值：</span><br><span class="line">        <span class="keyword">for</span> ...</span><br><span class="line">            dp[状态<span class="number">1</span>][状态<span class="number">2</span>][...] = 求最值(选择<span class="number">1</span>，选择<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure>


<blockquote>
<p>动态规划问题必须符合 <strong>最优子结构</strong></p>
<p>例如换零钱： 面值分别为 1，2，5，用最少硬币凑到总金额 <code>amount = 11</code></p>
<p>子结构就是 凑到 10, 9, 6 的硬币数+12</p>
<p><strong>子问题必须独立</strong></p>
<p>因为每种硬币无限多，即凑到10元的结果，不影响凑到9元的结果</p>
</blockquote>
<div style="color:red"><b>总结</b></div>

<p>对于动态规划的题目， 题目求什么，<code>dp[i][j]</code> 的值就代表什么。</p>
<h4 id="DP树"><a href="#DP树" class="headerlink" title="DP树"></a>DP树</h4><p><img src="/2024/03/31/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/DP%E6%A0%91.png" alt="DP树"></p>
<h4 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h4><p><strong>如果计算状态 <code>dp[i][j]</code> 需要的都是 <code>dp[i][j]</code> 相邻的状态，那么就可以使用空间压缩技巧</strong></p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><ul>
<li>双指针</li>
<li>虚拟头节点: 需要创建新链表时</li>
</ul>
<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>递归方式</p>
<blockquote>
<p><strong>输入一个节点 <code>head</code>，将「以 <code>head</code> 为起点」的链表反转，并返回反转之后的头结点</strong> 。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverse(head.next);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="大根堆"><a href="#大根堆" class="headerlink" title="大根堆"></a>大根堆</h2><p>求 n 个数字中的最大值</p>
<ul>
<li>由数组构成的完全二叉树</li>
<li>两个功能: 插入和弹出<ul>
<li>插入: 插入队尾,队尾冒泡</li>
<li>弹出: 队头和队尾交换,弹出队尾,队头下沉</li>
<li><blockquote>
<p>所有操作都在头尾</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxPQ</span></span><br><span class="line">    &lt;Key <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;Key&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// 存储元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> Key[] pq;</span><br><span class="line">    <span class="comment">// 当前 Priority Queue 中的元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxPQ</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">        <span class="comment">// 索引 0 不用，所以多分配一个空间</span></span><br><span class="line">        pq = (Key[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[cap + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 返回当前队列中最大元素 */</span></span><br><span class="line">    <span class="keyword">public</span> Key <span class="title function_">max</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pq[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 插入元素 e</span></span><br><span class="line"><span class="comment">    要插入的元素添加到堆底的最后，然后让其上浮到正确位置。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Key e)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除并返回当前队列中最大元素</span></span><br><span class="line"><span class="comment">    堆顶元素 A 和堆底最后的元素 B 对调，然后删除 A，最后让 B 下沉到正确位置。 */</span></span><br><span class="line">    <span class="keyword">public</span> Key <span class="title function_">delMax</span><span class="params">()</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 上浮第 x 个元素，以维护最大堆性质 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果浮到堆顶，就不能再上浮了</span></span><br><span class="line">        <span class="keyword">while</span> (x &gt; <span class="number">1</span> &amp;&amp; less(parent(x), x)) &#123;</span><br><span class="line">            <span class="comment">// 如果第 x 个元素比上层大</span></span><br><span class="line">            <span class="comment">// 将 x 换上去</span></span><br><span class="line">            swap(parent(x), x);</span><br><span class="line">            x = parent(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 下沉第 x 个元素，以维护最大堆性质 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (left(x) &lt;= size) &#123;</span><br><span class="line">            <span class="comment">// 先假设左边节点较大</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> left(x);</span><br><span class="line">            <span class="comment">// 如果右边节点存在，比一下大小</span></span><br><span class="line">            <span class="keyword">if</span> (right(x) &lt;= size &amp;&amp; less(max, right(x)))</span><br><span class="line">                max = right(x);</span><br><span class="line">            <span class="comment">// 结点 x 比俩孩子都大，就不必下沉了</span></span><br><span class="line">            <span class="keyword">if</span> (less(max, x)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 否则，不符合最大堆的结构，下沉 x 结点</span></span><br><span class="line">            swap(x, max);</span><br><span class="line">            x = max;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 交换数组的两个元素 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pq[i] 是否比 pq[j] 小？ */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pq[i].compareTo(pq[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 还有 left, right, parent 三个方法</span></span><br><span class="line"><span class="comment">    分别表示节点的左儿子、右儿子、父亲 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意 js 除法不会自动取整</p>
</blockquote>
<h2 id="倒数第-k-个"><a href="#倒数第-k-个" class="headerlink" title="倒数第 k 个"></a>倒数第 k 个</h2><ul>
<li>双指针<ul>
<li>p1 走出 k 步之后, p1 和 p2 再同步移动<blockquote>
<p>只用遍历一次链表</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="链表-环"><a href="#链表-环" class="headerlink" title="链表-环"></a>链表-环</h2><ul>
<li>双指针<ul>
<li>p1 走一步,p2 走两步, while 循环<ul>
<li>如果 p2 &#x3D;&#x3D;&#x3D; null, 说明没有环</li>
<li>如果 p2 &#x3D;&#x3D;&#x3D; p1 , 说明有环</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="找到环的起点"><a href="#找到环的起点" class="headerlink" title="找到环的起点"></a>找到环的起点</h1><ol>
<li>使用上述双指针方法，知道快慢指针指向同一个位置。</li>
<li>再让一个指针回第一个节点，两个指针同步移动相同距离，</li>
<li>再次相遇位置即为环的起点</li>
</ol>
<p><img src="/2024/03/31/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E9%93%BE%E8%A1%A8%E7%8E%AF%E8%B5%B7%E7%82%B9.jpeg"></p>
<h2 id="返回两链表相交点"><a href="#返回两链表相交点" class="headerlink" title="返回两链表相交点"></a>返回两链表相交点</h2><blockquote>
<p>p1 &#x3D; [1,2,3,4]<br>p2 &#x3D; [a,b,c,3,4]<br>则 3 是相交点<br>p1+p2 &#x3D; [1,2,3,4,a,b,c,3,4]<br>p2+p1 &#x3D; [a,b,c,3,4,1,2,3,4]</p>
</blockquote>
<ul>
<li>拼接 p1+p2 和 p2+p1<ul>
<li>此时两个链表同步遍历下去, 若遇到两者相同的节点,则它就是相交点</li>
</ul>
</li>
</ul>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><ul>
<li>维护一个差分数组 <code>diff[n] = arr[n] - arr[n-1]</code></li>
<li>主要适用场景是频繁对原始数组的某个<strong>区间</strong>的元素进行<strong>增减</strong> 。</li>
</ul>
<blockquote>
<p>例如：在 [ i , j ] 之间 所有元素都加1<br>只需要 diff[ i ] +&#x3D; 1 ; diff[ j+1 ] -&#x3D; 1;</p>
</blockquote>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><ul>
<li>旋转矩阵<ul>
<li>沿着主对角线对折后，再rever每行元素 &#x3D; 顺时针旋转90°</li>
</ul>
</li>
<li>螺旋遍历矩阵<ol>
<li><p>用一个d 和 一个flag 辅助数组 遍历 ， 空间复杂度O(m*n)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> d = &#123;</span><br><span class="line">    <span class="number">0</span>: [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">    <span class="number">1</span>: [<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    <span class="number">2</span>: [<span class="number">0</span>, -<span class="number">1</span>],</span><br><span class="line">    <span class="number">3</span>: [-<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>空间复杂度O(1)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> upper_bound = <span class="number">0</span>, lower_bound = m - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> left_bound = <span class="number">0</span>, right_bound = n - <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<blockquote>
<p>T54  T54</p>
</blockquote>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable language_">window</span> = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line"><span class="keyword">let</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> valid = <span class="number">0</span>; <span class="comment">//记录收集完成的字母的数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; right &lt; s.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="comment">// 增大窗口</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">set</span>(s[right], <span class="variable language_">window</span>.<span class="title function_">get</span>(s[right])?<span class="variable language_">window</span>.<span class="title function_">get</span>(s[right])+<span class="number">1</span>: <span class="number">1</span>);</span><br><span class="line">    right++;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> (<span class="variable language_">window</span> needs shrink) &#123;</span><br><span class="line">        <span class="comment">// 缩小窗口</span></span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">set</span>(s[left], <span class="variable language_">window</span>.<span class="title function_">get</span>(s[left])-<span class="number">1</span>);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h2><ul>
<li>防止溢出 <code>(l+r)/2 === l + (r - l)/2</code></li>
</ul>
<h3 id="左侧边界优先二分搜索"><a href="#左侧边界优先二分搜索" class="headerlink" title="左侧边界优先二分搜索"></a>左侧边界优先二分搜索</h3><p>不同的二分搜索对于 <code>[1,2,2,2,3]</code> return 2 而不是 1</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">left_bound_binary_search</span> (nums, target) &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 搜索区间为 [left, right]</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (nums[mid] == target)&#123;</span><br><span class="line">            <span class="comment">// 收缩右侧边界 ⭐不return</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [mid+1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [left, mid-1]</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断 target 是否存在于 nums 中</span></span><br><span class="line">    <span class="comment">// 如果越界，target 肯定不存在，返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; <span class="number">0</span> || left &gt;= nums.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断一下 nums[left] 是不是 target</span></span><br><span class="line">    <span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="右侧边界优先二分搜索"><a href="#右侧边界优先二分搜索" class="headerlink" title="右侧边界优先二分搜索"></a>右侧边界优先二分搜索</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">right_bound_binary_search</span> (nums, target) &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        int mid = left + (right - left) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (nums[mid] == target)&#123;</span><br><span class="line">            <span class="comment">//【区别1】</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 【区别2】</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span> || right &gt;= nums.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 【区别3】</span></span><br><span class="line">    <span class="keyword">return</span> nums[right] == target ? right : -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><ul>
<li>搜索</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable constant_">BST</span> = <span class="keyword">function</span>(<span class="params">root, target</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root.<span class="property">val</span> === target) &#123;</span><br><span class="line">        <span class="comment">// 找到目标，做点什么</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.<span class="property">val</span> &lt; target) &#123; </span><br><span class="line">        <span class="title function_">BST</span>(root.<span class="property">right</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.<span class="property">val</span> &gt; target) &#123;</span><br><span class="line">        <span class="title function_">BST</span>(root.<span class="property">left</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>插入</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> insertIntoBST = <span class="keyword">function</span>(<span class="params">root, val</span>) &#123;</span><br><span class="line">    <span class="comment">// 找到空位置插入新节点</span></span><br><span class="line">    <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">    <span class="comment">// if (root.val == val)</span></span><br><span class="line">    <span class="comment">//     BST 中一般不会插入已存在元素</span></span><br><span class="line">    <span class="keyword">if</span> (root.<span class="property">val</span> &lt; val) </span><br><span class="line">        root.<span class="property">right</span> = <span class="title function_">insertIntoBST</span>(root.<span class="property">right</span>, val);</span><br><span class="line">    <span class="keyword">if</span> (root.<span class="property">val</span> &gt; val) </span><br><span class="line">        root.<span class="property">left</span> = <span class="title function_">insertIntoBST</span>(root.<span class="property">left</span>, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除 BST 中的一个节点并返回根节点。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span> - 二叉树的根节点。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">key</span> - 待删除节点的值。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125; - 删除节点后的 BST。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> deleteNode = <span class="keyword">function</span>(<span class="params">root, key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.<span class="property">val</span> == key) &#123;</span><br><span class="line">        <span class="comment">// 这两个 if 把情况 1 和 2 都正确处理了</span></span><br><span class="line">        <span class="keyword">if</span> (root.<span class="property">left</span> == <span class="literal">null</span>) <span class="keyword">return</span> root.<span class="property">right</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.<span class="property">right</span> == <span class="literal">null</span>) <span class="keyword">return</span> root.<span class="property">left</span>;</span><br><span class="line">        <span class="comment">// 处理情况 3</span></span><br><span class="line">        <span class="comment">// 获得右子树最小的节点</span></span><br><span class="line">        <span class="keyword">let</span> minNode = <span class="title function_">getMin</span>(root.<span class="property">right</span>);</span><br><span class="line">        <span class="comment">// 删除右子树最小的节点</span></span><br><span class="line">        root.<span class="property">right</span> = <span class="title function_">deleteNode</span>(root.<span class="property">right</span>, minNode.<span class="property">val</span>);</span><br><span class="line">        <span class="comment">// 用右子树最小的节点替换 root 节点</span></span><br><span class="line">        minNode.<span class="property">left</span> = root.<span class="property">left</span>;</span><br><span class="line">        minNode.<span class="property">right</span> = root.<span class="property">right</span>;</span><br><span class="line">        root = minNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.<span class="property">val</span> &gt; key) &#123;</span><br><span class="line">        root.<span class="property">left</span> = <span class="title function_">deleteNode</span>(root.<span class="property">left</span>, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.<span class="property">val</span> &lt; key) &#123;</span><br><span class="line">        root.<span class="property">right</span> = <span class="title function_">deleteNode</span>(root.<span class="property">right</span>, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得 BST 中最小的节点。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">node</span> - 待查找 BST。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">TreeNode</span>&#125; - BST 中最小的节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getMin = <span class="keyword">function</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="comment">// BST 最左边的就是最小的</span></span><br><span class="line">    <span class="keyword">while</span> (node.<span class="property">left</span> != <span class="literal">null</span>) node = node.<span class="property">left</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="dfs遍历"><a href="#dfs遍历" class="headerlink" title="dfs遍历"></a>dfs遍历</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> visited = [];</span><br><span class="line"><span class="keyword">var</span> onPath = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 图遍历框架 */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">traverse</span>(<span class="params">graph, s</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (visited[s]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 经过节点 s，标记为已遍历</span></span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 做选择：标记节点 s 在路径上</span></span><br><span class="line">    onPath[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; graph.<span class="title function_">neighbors</span>(s).<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> neighbor = graph.<span class="title function_">neighbors</span>(s)[i];</span><br><span class="line">        <span class="title function_">traverse</span>(graph, neighbor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 撤销选择：节点 s 离开路径</span></span><br><span class="line">    onPath[s] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>图的拓扑排序就是图的dfs后序排序再reverse</p>
</blockquote>
<h2 id="判断环"><a href="#判断环" class="headerlink" title="判断环"></a>判断环</h2><h3 id="基于dfs，通过onPath-includes-cur-判断"><a href="#基于dfs，通过onPath-includes-cur-判断" class="headerlink" title="基于dfs，通过onPath.includes(cur)判断"></a>基于dfs，通过onPath.includes(cur)判断</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findOrder = <span class="keyword">function</span> (<span class="params">numCourses, prerequisites</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> visited = <span class="keyword">new</span> <span class="title class_">Array</span>(numCourses).<span class="title function_">fill</span>(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">const</span> onPath = [];</span><br><span class="line">    <span class="keyword">const</span> graph = <span class="title function_">generateGraph</span>(numCourses, prerequisites)</span><br><span class="line">    <span class="keyword">let</span> hasCircle = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="title function_">dfs</span>(i)</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> hasCircle </span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">dfs</span>(<span class="params">cur</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (onPath.<span class="title function_">includes</span>(cur))<span class="comment">//判断是否有环</span></span><br><span class="line">            hasCircle = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (visited[cur] || hasCircle) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        visited[cur] = <span class="literal">true</span>;</span><br><span class="line">        onPath.<span class="title function_">push</span>(cur)</span><br><span class="line">        <span class="keyword">let</span> p = graph[cur].<span class="property">next</span>;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            <span class="title function_">dfs</span>(p.<span class="property">val</span>);</span><br><span class="line">            p = p.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        onPath.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="基于拓扑排序-拓扑顺序count-num"><a href="#基于拓扑排序-拓扑顺序count-num" class="headerlink" title="基于拓扑排序 拓扑顺序count&#x3D;&#x3D;&#x3D;num"></a>基于拓扑排序 拓扑顺序count&#x3D;&#x3D;&#x3D;num</h3><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><ul>
<li><strong>dfs后序遍历再翻转</strong></li>
<li><strong>基于bfs</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建邻接表、入度数组</span></span><br><span class="line"><span class="keyword">let</span> indegree = <span class="keyword">new</span> <span class="title class_">Array</span>(numCourses).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> graph = <span class="title function_">buildGraph2</span>(numCourses, prerequisites, indegree);</span><br><span class="line"><span class="comment">// 初始化，入度为0直接加入队列中</span></span><br><span class="line"><span class="keyword">let</span> q = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">        q.<span class="title function_">push</span>(i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始执行 BFS 循环</span></span><br><span class="line"><span class="keyword">while</span> (q.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 弹出一个节点，代表遍历了一个节点。</span></span><br><span class="line">    <span class="keyword">let</span> cur = q.<span class="title function_">shift</span>();</span><br><span class="line">    <span class="keyword">let</span> p = graph[cur].<span class="property">next</span>;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        indegree[p.<span class="property">val</span>]--; </span><br><span class="line">        <span class="keyword">if</span> (indegree[p.<span class="property">val</span>] === <span class="number">0</span>) &#123; <span class="comment">//此节点入度为0，可以入队</span></span><br><span class="line">            q.<span class="title function_">push</span>(p.<span class="property">val</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<blockquote>
<p>拓扑排序与dfs区别：使用indegree[]而不是visited[]</p>
</blockquote>
<h1 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h1><h2 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h2><p>要么装进包里，要么不装，不能说切成两块装一半</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于前 i 个物品（从 1 开始计数），当前背包的容量为 w 时，这种情况下可以装下的最大价值是 dp[i][w]。</span></span><br><span class="line"><span class="keyword">const</span> dp[N+<span class="number">1</span>][W+<span class="number">1</span>]</span><br><span class="line">dp[<span class="number">0</span>][..] = <span class="number">0</span></span><br><span class="line">dp[..][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1.</span>.<span class="property">N</span>]:</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> [<span class="number">1.</span>.<span class="property">W</span>]:</span><br><span class="line">        dp[i][w] = <span class="title function_">max</span>(</span><br><span class="line">            把物品 i 装进背包,</span><br><span class="line">            不把物品 i 装进背包</span><br><span class="line">        )</span><br><span class="line"><span class="keyword">return</span> dp[N][W]</span><br></pre></td></tr></table></figure>



<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>一个物品可以装进无限次，也可以不装</p>
<h1 id="处理循环数组"><a href="#处理循环数组" class="headerlink" title="处理循环数组"></a>处理循环数组</h1><ol>
<li>下标取余</li>
<li>复制一份再首尾连接起来</li>
</ol>
<h1 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h1><p>最近最旧未使用</p>
<p><img src="/2024/03/31/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/LRU.png" alt="LRU"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
